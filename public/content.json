{"meta":{"title":"Tim上校的小屋","subtitle":"A fast, simple & powerful blog framework powered by Node.js.","description":"技术博客","author":"yongchao","url":"http://yongchao.tech:8080"},"pages":[],"posts":[{"title":"vue组件生命周期","slug":"vue组件生命周期","date":"2019-10-16T10:36:39.000Z","updated":"2019-10-16T06:21:52.967Z","comments":true,"path":"2019/10/16/vue组件生命周期/","link":"","permalink":"http://yongchao.tech:8080/2019/10/16/vue组件生命周期/","excerpt":"","text":"单个组件的生命周期 分为三个阶段： 初始化阶段： 只有默认的事件，没有data,methods beforeCreate 监听对象和初始化事件坚挺 created 此时已经可以访问data和methods 内存中编译好模版 beforeMount 此时页面仍然是旧的，没有挂载到上面 vm.$el 替换 el ，挂载页面 mounted 挂载完成，页面此时是最新的 运行阶段： 监听数据变化 beforeUpdate diff, 虚拟dom 重新绘制, patch updated 销毁阶段： beforeDestroy 此时仍然可以正常访问data, methods 关闭watchers和子组件的事件监听 destroyed Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：加载渲染过程父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted 子组件更新过程父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated 父组件更新过程父 beforeUpdate -&gt; 父 updated 销毁过程父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yongchao.tech:8080/tags/vue/"}]},{"title":"webpack配置","slug":"webpack配置","date":"2019-10-11T00:26:56.000Z","updated":"2019-10-16T02:16:33.629Z","comments":true,"path":"2019/10/11/webpack配置/","link":"","permalink":"http://yongchao.tech:8080/2019/10/11/webpack配置/","excerpt":"","text":"devtool如果是生产环境,压根不应该有devtool这个选项，这样build之后不会产生map文件，如果需要map文件用来方便查找问题，则设置devtool就行 performance123456789performance: &#123; hints: &apos;warning&apos;, // false | warning | error maxEntrypointSize: 1048576, // 入口文件最大值为1M maxAssetSize: 3145728, // 资源文件最大值为3M assetFilter: function (assetFilename) &#123; // 只给出js文件的性能提示 return assetFilename.endsWith(&apos;.js&apos;) &#125; &#125; resolve.alias用来设置快捷方式123456789101112resolve: &#123; alias: &#123; // 只能匹配到vue$结尾的字符串 // 比如：import Test1 from &apos;vue&apos;; // 不能匹配 import Test1 from &apos;vue-router&apos;; vue$: &apos;vue/dist/vue.esm.js&apos; &#125;, // 自动解析确定的扩展, ps: import File from &apos;../path/to/file&apos;; extensions: [&apos;*&apos;, &apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;]&#125;, externals防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖(external dependencies)。 例如，从 CDN 引入 jQuery，而不是把它打包12345678externals: &#123; highcharts: &#123; root: &apos;Highcharts&apos;, commonjs: &apos;highcharts&apos;, commonjs2: &apos;highcharts&apos;, amd: &apos;highcharts&apos; &#125; &#125;, library 和 libraryTarget123456789output: &#123; filename: &apos;[name].js&apos;, // 以何种形式暴露library， 指的是暴露出来的名字 library: &apos;HighchartsVueXyc&apos;, // 选项将导致 bundle 带有更完整的模块头部，以确保与各种模块系统的兼容性。 // 将你的 library 暴露为所有的模块定义下都可运行的方式。它将在 CommonJS, AMD 环境下运行，或将模块导出到 global 下的变量。 libraryTarget: &apos;umd&apos;, path: path.resolve(__dirname, &apos;./dist&apos;) &#125;,","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"},{"name":"webpack","slug":"webpack","permalink":"http://yongchao.tech:8080/tags/webpack/"}]},{"title":"webpack前端页面分析插件","slug":"webpack前端页面分析插件","date":"2019-09-17T19:23:07.000Z","updated":"2019-09-17T11:48:53.079Z","comments":true,"path":"2019/09/18/webpack前端页面分析插件/","link":"","permalink":"http://yongchao.tech:8080/2019/09/18/webpack前端页面分析插件/","excerpt":"","text":"1.添加插件1cnpm install webpack-bundle-analyzer -save vue.config.js文件12345678chainWebpack: config =&gt; &#123; // 运行npm run analyze 显示性能分析 if (process.env.analyze &amp;&amp; process.NODE_ENV === production) &#123; config .plugin(&quot;webpack-bundle-analyzer&quot;) .use(require(&quot;webpack-bundle-analyzer&quot;).BundleAnalyzerPlugin); &#125; &#125;, 3.scripts中添加1&quot;analyz&quot;: &quot;NODE_ENV=production analyze=true npm run build&quot; 运行1npm run analyze","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yongchao.tech:8080/tags/vue/"},{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"},{"name":"webpack","slug":"webpack","permalink":"http://yongchao.tech:8080/tags/webpack/"}]},{"title":"vue-cli3中iview按需引入","slug":"vue-cli3中iview按需引入","date":"2019-09-17T19:16:59.000Z","updated":"2019-09-17T11:22:30.012Z","comments":true,"path":"2019/09/18/vue-cli3中iview按需引入/","link":"","permalink":"http://yongchao.tech:8080/2019/09/18/vue-cli3中iview按需引入/","excerpt":"","text":"1.安装babel-plugin-import插件1cnpm install babel-plugin-import --save-dev 在文件.babelrc中添加配置 12345678&quot;plugins&quot;: [ &quot;transform-vue-jsx&quot;, &quot;transform-runtime&quot;, [&quot;import&quot;, &#123; &quot;libraryName&quot;: &quot;iview&quot;, &quot;libraryDirectory&quot;: &quot;src/components&quot; &#125;] ]] 在plugins文件夹中新建一个iview.js文件 Vue from 'vue'1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import &apos;iview/dist/styles/iview.css&apos;import &#123; Row, Col, Switch, Form, FormItem, Select, Input, InputNumber, Button, Icon, Card, Modal, Menu, MenuItem, Submenu, Message, Notice, Layout, Sider, Content, Tag, Table, Poptip, Page, Timeline, TimelineItem, Tabs, TabPane, Tooltip, Alert, Checkbox, CheckboxGroup, RadioGroup, Radio&#125; from &apos;iview&apos;Vue.component(&apos;Row&apos;, Row)Vue.component(&apos;Col&apos;, Col)Vue.component(&apos;iSwitch&apos;, Switch)Vue.component(&apos;Form&apos;, Form)Vue.component(&apos;FormItem&apos;, FormItem)Vue.component(&apos;Select&apos;, Select)Vue.component(&apos;Input&apos;, Input)Vue.component(&apos;InputNumber&apos;, InputNumber)Vue.component(&apos;Button&apos;, Button)Vue.component(&apos;Icon&apos;, Icon)Vue.component(&apos;Card&apos;, Card)Vue.component(&apos;Modal&apos;, Modal)Vue.component(&apos;Card&apos;, Card)Vue.component(&apos;Menu&apos;, Menu)Vue.component(&apos;Submenu&apos;, Submenu)Vue.component(&apos;MenuItem&apos;, MenuItem)Vue.component(&apos;Layout&apos;, Layout)Vue.component(&apos;Sider&apos;, Sider)Vue.component(&apos;Content&apos;, Content)Vue.component(&apos;Tag&apos;, Tag)Vue.component(&apos;Table&apos;, Table)Vue.component(&apos;Poptip&apos;, Poptip)Vue.component(&apos;Page&apos;, Page)Vue.component(&apos;Timeline&apos;, Timeline)Vue.component(&apos;TimelineItem&apos;, TimelineItem)Vue.component(&apos;Tabs&apos;, Tabs)Vue.component(&apos;TabPane&apos;, TabPane)Vue.component(&apos;Tooltip&apos;, Tooltip)Vue.component(&apos;Alert&apos;, Alert)Vue.component(&apos;Checkbox&apos;, Checkbox)Vue.component(&apos;CheckboxGroup&apos;, CheckboxGroup)Vue.component(&apos;RadioGroup&apos;, RadioGroup)Vue.component(&apos;Radio&apos;, Radio)Vue.component(&apos;Message&apos;, Message)Vue.component(&apos;Notice&apos;, Notice) 4.在main.js文件中123// import iView from &apos;iview&apos;// Vue.use(iView)import &apos;@/plugins/iview 到这里基本完成，但是还有一些iview的全局API是需要额外处理的，这里就不多说了","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yongchao.tech:8080/tags/vue/"},{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"},{"name":"webpack","slug":"webpack","permalink":"http://yongchao.tech:8080/tags/webpack/"}]},{"title":"proxy体验","slug":"proxy体验","date":"2019-09-16T19:22:32.000Z","updated":"2019-09-16T12:45:46.327Z","comments":true,"path":"2019/09/17/proxy体验/","link":"","permalink":"http://yongchao.tech:8080/2019/09/17/proxy体验/","excerpt":"","text":"todoList1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;input&quot;&gt; &lt;div&gt; TODO: &lt;span id=&quot;text&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;button id=&quot;btn&quot;&gt;Add To Todo List&lt;/button&gt; &lt;ul id=&quot;list&quot;&gt;&lt;/ul&gt; &lt;/div&gt; &lt;script&gt; const input = document.getElementById(&apos;input&apos;) const text = document.getElementById(&apos;text&apos;) const list = document.getElementById(&apos;list&apos;) const btn = document.getElementById(&apos;btn&apos;) let render const inputObj = new Proxy(&#123;&#125;, &#123; get (target, key, receiver) &#123; return Reflect.get(target, key, receiver) &#125;, set (target, key, value, receiver) &#123; if (key === &apos;text&apos;) &#123; input.value = value text.innerHTML = value &#125; return Reflect.set(target, key, value, receiver) &#125; &#125;) class Render &#123; constructor (arr) &#123; this.arr = arr &#125; init () &#123; const fragment = document.createDocumentFragment() for (let i = 0; i &lt; this.arr.length; i++) &#123; const li = document.createElement(&apos;li&apos;) li.textContent = this.arr[i] fragment.appendChild(li) &#125; list.appendChild(fragment) &#125; addList (val) &#123; const li = document.createElement(&apos;li&apos;) li.textContent = val list.appendChild(li) &#125; &#125; const todoList = new Proxy([], &#123; get (target, key, receiver) &#123; return Reflect.get(target, key, receiver) &#125;, set (target, key, value, receiver) &#123; console.log(target, key, value, receiver) if (key !== &apos;length&apos;) &#123; render.addList(value) &#125; return Reflect.set(target, key, value, receiver) &#125; &#125;) window.onload = () =&gt; &#123; render = new Render([]) render.init() &#125; input.addEventListener(&apos;keyup&apos;, e =&gt; &#123; inputObj.text = e.target.value &#125;) btn.addEventListener(&apos;click&apos;, () =&gt; &#123; todoList.push(inputObj.text) // 每次 增加和删除 都会引起 length 的改变 inputObj.text = &apos;&apos; &#125;) console.log(todoList) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"es6","slug":"es6","permalink":"http://yongchao.tech:8080/categories/es6/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"},{"name":"proxy","slug":"proxy","permalink":"http://yongchao.tech:8080/tags/proxy/"}]},{"title":"css特性","slug":"css特性","date":"2019-09-16T00:11:25.000Z","updated":"2019-09-15T16:23:55.787Z","comments":true,"path":"2019/09/16/css特性/","link":"","permalink":"http://yongchao.tech:8080/2019/09/16/css特性/","excerpt":"权重 ！important Infinity 行间样式 1000 id 100 class |属性|伪类 10 标签选择器|伪元素 1 通配符 0 继承 不存在进位的情况，只要高位大，就不用比了，权重一定高","text":"权重 ！important Infinity 行间样式 1000 id 100 class |属性|伪类 10 标签选择器|伪元素 1 通配符 0 继承 不存在进位的情况，只要高位大，就不用比了，权重一定高 层叠性当同一个元素的有多个样式且权重相同时，后面覆盖前面的 盒模型 content padding border margin box-sizing属性可以设置盒模型","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yongchao.tech:8080/tags/css/"},{"name":"权重","slug":"权重","permalink":"http://yongchao.tech:8080/tags/权重/"},{"name":"盒模型","slug":"盒模型","permalink":"http://yongchao.tech:8080/tags/盒模型/"}]},{"title":"模拟一些常见的js函数","slug":"模拟一些常见的js函数","date":"2019-09-15T23:29:42.000Z","updated":"2019-09-15T15:31:02.142Z","comments":true,"path":"2019/09/16/模拟一些常见的js函数/","link":"","permalink":"http://yongchao.tech:8080/2019/09/16/模拟一些常见的js函数/","excerpt":"","text":"apply123456789101112131415161718Function.prototype.myapply = function(context, arr) &#123; var context = Object(context) || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push(&quot;arr[&quot; + i + &quot;]&quot;); &#125; result = eval(&quot;context.fn(&quot; + args + &quot;)&quot;); &#125; delete context.fn; return result;&#125;; call1234567Function.prototype.myCall = function(context) &#123; context.fn = this let args = Array.prototype.slice(arguments, 1) let result = context.fn(...args) delete context.fn return result&#125; instanceof都知道instanceof实际上是用来判断对象的原型链上面能不能找到指定类型的原型。然后就按照这个原理来写歌demo12345678910function instance_of(l, r)&#123; let proto = r.__proto__ l = l.__proto__ while(l) &#123; if (l === proto) return true if(l === null) return false l = l.__proto__ &#125; return false&#125;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"},{"name":"模拟函数","slug":"模拟函数","permalink":"http://yongchao.tech:8080/tags/模拟函数/"}]},{"title":"stopImmediatePropagation和stopPropagation的区别","slug":"stopImmediatePropagation和stopPropagation的区别","date":"2019-09-15T18:22:11.000Z","updated":"2019-09-15T10:28:02.921Z","comments":true,"path":"2019/09/16/stopImmediatePropagation和stopPropagation的区别/","link":"","permalink":"http://yongchao.tech:8080/2019/09/16/stopImmediatePropagation和stopPropagation的区别/","excerpt":"在事件处理程序中，每个事件处理程序中间都会有一个event对象，而这个event对象有两个方法，一个是stopPropagation方法，一个是stopImmediatePropagation方法，两个方法只差一个Immediate，这里就说说这两个方法的区别","text":"在事件处理程序中，每个事件处理程序中间都会有一个event对象，而这个event对象有两个方法，一个是stopPropagation方法，一个是stopImmediatePropagation方法，两个方法只差一个Immediate，这里就说说这两个方法的区别 stopImmediatePropagation方法：stopImmediatePropagation方法作用在当前节点以及事件链上的所有后续节点上，目的是在执行完当前事件处理程序之后，停止当前节点以及所有后续节点的事件处理程序的运行 stopPropagation方法stopPropagation方法作用在后续节点上，目的在执行完绑定到当前元素上的所有事件处理程序之后，停止执行所有后续节点的事件处理程序 区别：从概念上讲，在调用完stopPropagation函数之后，就会立即停止对后续节点的访问，但是会执行完绑定到当前节点上的所有事件处理程序；而调用stopImmediatePropagation函数之后，除了所有后续节点，绑定到当前元素上的、当前事件处理程序之后的事件处理程序就不会再执行了 Demo12345678910111213141516// html&lt;div id = &quot;div1&quot;&gt; &lt;button id = &quot;button1&quot;&gt;&lt;/button&gt;&lt;/div&gt;// js var div = document.getElementById(&quot;div1&quot;); var btn = document.getElementById(&quot;button1&quot;); div.addEventListener(&quot;click&quot; , function(e)&#123; // e.stopImmediatePropagation() e.stopPropagation() alert(&quot;第一次执行&quot;); &#125; , true); //1 div.addEventListener(&quot;click&quot; , function()&#123;alert(&quot;第二次执行&quot;);&#125; , true); //2 btn.addEventListener(&quot;click&quot; , function()&#123;alert(&quot;button 执行&quot;);&#125;); 1.在这里，给 1 函数alert后加上stopImmediatePropagation， 那么之后弹出窗口“第一次执行”2.但是如果给 1 函数alert后加上stopPropagation ， 那么之后会弹出窗口“第一次执行”，“第二次执行”两个窗口","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"}]},{"title":"js的事件模型","slug":"js的事件模型","date":"2019-09-15T18:21:20.000Z","updated":"2019-09-15T10:26:59.567Z","comments":true,"path":"2019/09/16/js的事件模型/","link":"","permalink":"http://yongchao.tech:8080/2019/09/16/js的事件模型/","excerpt":"引言其实，说起js的事件模型，有点基础的都能说几句， 分为三个阶段， 捕获-事件处理-冒泡，巴拉巴拉…。但是这并没有考虑到我们 “伟大” 的IE，有点考虑的不够全面。接下来系统性的详细的讲一波儿 事件模型的前世今生故事源于传说中的浏览器大战，微软的 IE 和网景的Netspace Navigator。IE的事件流是冒泡 从里面往上面冒, netscape是从外部元素往内部元素捕获;后来出来了个W3C委员会，想要统一，为了兼容，宣布了后来的W3C事件模型（捕获-事件处理-冒泡），从此天下一统。","text":"引言其实，说起js的事件模型，有点基础的都能说几句， 分为三个阶段， 捕获-事件处理-冒泡，巴拉巴拉…。但是这并没有考虑到我们 “伟大” 的IE，有点考虑的不够全面。接下来系统性的详细的讲一波儿 事件模型的前世今生故事源于传说中的浏览器大战，微软的 IE 和网景的Netspace Navigator。IE的事件流是冒泡 从里面往上面冒, netscape是从外部元素往内部元素捕获;后来出来了个W3C委员会，想要统一，为了兼容，宣布了后来的W3C事件模型（捕获-事件处理-冒泡），从此天下一统。 事件的三种模型DOM0(原始事件模型)12345&lt;input id=&quot;myButton&quot; type=&quot;button&quot; value=&quot;Press Me&quot; onclick=&quot;alert(&apos;thanks&apos;);&quot; &gt;ordocument.getElementById(&quot;myButton&quot;).onclick = function () &#123;alert(&apos;thanks&apos;);&#125; 通常情况下事件监听函数如果返回一个值并且是false，则会阻止浏览器执行默认的动作 优点： 所有浏览器都兼容 缺点： 代码耦合严重 事件监听器只能有一个，重复赋值，后面会覆盖前面的 没有事件的冒泡、委托等机制完成更为负载的情况 IEIE将event作为window的一个属性。IE的事件模型只有两步，执行处理函数，然后冒泡。添加和移除事件监听的方式1234attachEvent( &quot;eventType&quot;,&quot;handler&quot;)//其中evetType为事件的类型，如onclick，注意要加’on’。detachEvent(&quot;eventType&quot;,&quot;handler&quot; ) DOM2事件分为三个阶段： 捕获-处理目标-冒泡（IE8以及更早版本不支持DOM事件流） 捕获阶段： 事件被从document一直向下传播到目标元素,在这过程中依次检查经过的节点是否注册了该事件的监听函数，若有则执行。 事件处理： 事件到达目标元素,执行目标元素的事件处理函数 冒泡： 事件从目标元素上升一直到达document，同样依次检查经过的节点是否注册了该事件的监听函数，有则执行。 事件对象常用对象和属性 DOM事件模型中的事件对象常用属性: type用于获取事件类型 currentTarget 当前正在处理的事件的节点，在事件捕获或冒泡阶段 target获取事件目标 stopPropagation()阻止事件冒泡 preventDefault()阻止事件默认行为 keyCode：按下的键的值； stopImmediatePropagation() (DOM3)阻止任何事件的运行；详情看http://39.105.159.58:8080/2019/09/16/stopImmediatePropagation%E5%92%8CstopPropagation%E7%9A%84%E5%8C%BA%E5%88%AB/ IE事件模型中的事件对象常用属性: type用于获取事件类型 srcElement获取事件目标 cancelBubble阻止事件冒泡 returnValue阻止事件默认行为 事件对象中和定位相关的属性 x/y与clientX/clientY值一样，表示距浏览器可视区域（工具栏除外区域）左/上的距离； pageX/pageY，距页面左/上的距离，它与clientX/clientY的区别是不随滚动条的位置变化； screenX/screenY，距计算机显示器左/上的距离，拖动你的浏览器窗口位置可以看到变化； layerX/layerY与offsetX/offsetY值一样，表示距有定位属性的父元素左/上的距离。 事件委托/代理1234567891011121314151617181920&lt;ul id=&quot;parent&quot;&gt; &lt;li class=&quot;child&quot;&gt;1&lt;/li&gt; &lt;li class=&quot;child&quot;&gt;2&lt;/li&gt; &lt;li class=&quot;child&quot;&gt;3&lt;/li&gt;&lt;/ul&gt;&lt;script type=&quot;text/javascript&quot;&gt; //父元素 var dom= document.getElementById(&apos;parent&apos;); //父元素绑定事件，代理子元素的点击事件 dom.onclick= function(event) &#123; var event= event || window.event; var curTarget= event.target || event.srcElement; if (curTarget.tagName.toLowerCase() == &apos;li&apos;) &#123; //找到被代理的节点 //事件处理 &#125; &#125;&lt;/script&gt; 优点： 节省内存占用，减少事件注册 新增子对象时无需再次对其绑定事件，适合动态添加元素 eventBus的事件模型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * 完整的思路就是，使用一个map存储 type：处理函数 * 有两种存储形式 * type: function * type: [function, funciton, ...] * 删除和添加的时候考虑到这两种情况就行了 */class EventEmitter&#123; constructor () &#123; this._events = this._events || new Map() this._maxListeners = this._maxListeners || 10 &#125;&#125;EventEmitter.prototype.emit = function(type, ...args)&#123; let handler = this._events.get(type) if (Array.isArray(handler)) &#123; for(let i=0;i&lt;handler.length;i++) &#123; if(args.length &gt; 0) &#123; handler[i].apply(this, args) &#125;else &#123; handler[i].call(this) &#125; &#125; &#125;else &#123; if(args.length &gt;0) &#123; handler.apply(this, args) &#125; else &#123; handler.call(this) &#125; &#125; return true&#125;EventEmitter.prototype.addListener = function(type, fn) &#123; const handler = this._events.get(type) if(!handler) &#123; this._events.set(type, handler) &#125;else if(handler &amp;&amp; typeof handler === &apos;function&apos;) &#123; this._events.set(type, [handler, fn]) &#125;else &#123; handler.push(fn) &#125;&#125;EventEmitter.prototype.removeListener = function(type, fn) &#123; const handler = this._events.get(type) if(handler &amp;&amp; typeof handler === &apos;function&apos;) &#123; this._events.delete(type) &#125; else &#123; let position = -1 for (let i=0;i&lt;handler.length;i++) &#123; if (handler[i] === fn) &#123; position = i &#125; &#125; if (position !== -1) &#123; handler.splice(position, 1) if (handler.length === 1) &#123; this._events.set(type, handler[0]) &#125; &#125; else &#123; return this &#125; &#125;&#125;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"},{"name":"事件模型","slug":"事件模型","permalink":"http://yongchao.tech:8080/tags/事件模型/"}]},{"title":"装箱和拆箱","slug":"装箱和拆箱","date":"2019-09-12T11:07:11.000Z","updated":"2019-09-12T03:11:11.748Z","comments":true,"path":"2019/09/12/装箱和拆箱/","link":"","permalink":"http://yongchao.tech:8080/2019/09/12/装箱和拆箱/","excerpt":"装箱转换：把基本类型转换为对应的包装类型 拆箱操作：把引用类型转换为基本类型 既然原始类型不能扩展属性和方法，那么我们是如何使用原始类型调用方法的呢？ 每当我们操作一个基础类型时，后台就会自动创建一个包装类型的对象，从而让我们能够调用一些方法和属性，例如下面的代码：","text":"装箱转换：把基本类型转换为对应的包装类型 拆箱操作：把引用类型转换为基本类型 既然原始类型不能扩展属性和方法，那么我们是如何使用原始类型调用方法的呢？ 每当我们操作一个基础类型时，后台就会自动创建一个包装类型的对象，从而让我们能够调用一些方法和属性，例如下面的代码： 12var name = &quot;ConardLi&quot;;var name2 = name.substring(2); 实际上发生了以下几个过程： 创建一个String的包装类型实例 在实例上调用substring方法 销毁实例 也就是说，我们使用基本类型调用方法，就会自动进行装箱和拆箱操作，相同的，我们使用Number和Boolean类型时，也会发生这个过程。 从引用类型到基本类型的转换，也就是拆箱的过程中，会遵循ECMAScript规范规定的toPrimitive原则，一般会调用引用类型的valueOf和toString方法，你也可以直接重写toPeimitive方法。一般转换成不同类型的值遵循的原则不同，例如： 引用类型转换为Number类型，先调用valueOf，再调用toString 引用类型转换String类型, 先调用toString，再调用valueOf 若valueOf和toString都不存在，或者没有返回基本类型，则抛出TypeError异常。1234567891011121314151617181920const obj = &#123; valueOf: () =&gt; &#123; console.log(&apos;valueOf&apos;); return 123; &#125;, toString: () =&gt; &#123; console.log(&apos;toString&apos;); return &apos;ConardLi&apos;; &#125;,&#125;;console.log(obj - 1); // valueOf 122console.log(`$&#123;obj&#125;ConardLi`); // toString ConardLiConardLiconst obj2 = &#123; [Symbol.toPrimitive]: () =&gt; &#123; console.log(&apos;toPrimitive&apos;); return 123; &#125;,&#125;;console.log(obj2 - 1); // valueOf 122const obj3 = &#123; valueOf: () =&gt; &#123; console.log(&apos;valueOf&apos;); return &#123;&#125;; &#125;, toString: () =&gt; &#123; console.log(&apos;toString&apos;); return &#123;&#125;; &#125;,&#125;;console.log(obj3 - 1); // valueOf // toString// TypeError 除了程序中的自动拆箱和自动装箱，我们还可以手动进行拆箱和装箱操作。我们可以直接调用包装类型的valueOf或toString，实现拆箱操作：123var num =new Number(&quot;123&quot;); console.log( typeof num.valueOf() ); //numberconsole.log( typeof num.toString() ); //string","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"},{"name":"类型","slug":"类型","permalink":"http://yongchao.tech:8080/tags/类型/"}]},{"title":"判断类型的方式","slug":"判断类型的方式","date":"2019-09-12T11:04:47.000Z","updated":"2019-10-16T06:14:30.857Z","comments":true,"path":"2019/09/12/判断类型的方式/","link":"","permalink":"http://yongchao.tech:8080/2019/09/12/判断类型的方式/","excerpt":"typeof取值范围 number string object function boolean symbol boolean","text":"typeof取值范围 number string object function boolean symbol boolean 123456789typeof 12 // &apos;number&apos;typeof &apos;aa&apos; // &apos;string&apos;typeof false // &apos;boolean&apos;typeof &#123;&#125; // &apos;object&apos;typeof function()&#123;&#125; // &apos;function&apos;typeof [] // &apos;object&apos;typeof new Date() // &apos;object&apos;typeof Symbol() // &apos;symbol&apos;typeof /\\w+/ig // &apos;object&apos; instanceofinstanceof操作符可以帮助我们判断引用类型具体是什么类型的对象：123[] instanceof Array // truenew Date() instanceof Date // truenew RegExp() instanceof RegExp // true 我们先来回顾下原型链的几条规则： 1.所有引用类型都具有对象特性，即可以自由扩展属性 2.所有引用类型都具有一个__proto__（隐式原型）属性，是一个普通对象 3.所有的函数都具有prototype（显式原型）属性，也是一个普通对象 4.所有引用类型__proto__值指向它构造函数的prototype 5.当试图得到一个对象的属性时，如果变量本身没有这个属性，则会去他的__proto__中去找 [] instanceof Array实际上是判断Array.prototype是否在[]的原型链上。 所以，使用instanceof来检测数据类型，不会很准确，这不是它设计的初衷：12[] instanceof Object // truefunction()&#123;&#125; instanceof Object // true 另外，使用instanceof也不能检测基本数据类型，所以instanceof并不是一个很好的选择。 toString上面我们在拆箱操作中提到了toString函数，我们可以调用它实现从引用类型的转换。 每一个引用类型都有toString方法，默认情况下，toString()方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中type是对象的类型。12const obj = &#123;&#125;;obj.toString() // [object Object] 注意，上面提到了如果此方法在自定义对象中未被覆盖，toString才会达到预想的效果，事实上，大部分引用类型比如Array、Date、RegExp等都重写了toString方法。 我们可以直接调用Object原型上未被覆盖的toString()方法，使用call来改变this指向来达到我们想要的效果。 jquery中判断类型的方式123456789101112131415161718192021222324252627282930313233343536373839var types = [ &apos;Boolean&apos;, &apos;Number&apos;, &apos;String&apos;, &apos;Function&apos;, &apos;Array&apos;, &apos;Date&apos;, &apos;RegExp&apos;, &apos;Object&apos;, &apos;Error&apos;, &apos;Symbol&apos;]var class2type = &#123;&#125;types.forEach(name =&gt; &#123; class2type[`[object $&#123;name&#125;]`] = name.toLocaleLowerCase()&#125;)function type(obj) &#123; if (obj == null) &#123; return obj+&apos;&apos; &#125; return typeof obj === &apos;object&apos; ? class2type[Object.prototype.toString.call(obj)] || &apos;object&apos; : typeof obj&#125;测试：console.log(type(12)) // numberconsole.log(type(&apos;12&apos;)) // string console.log(type(false)) // booleanconsole.log(type(&#123;&#125;)) // objectconsole.log(type([])) // objectconsole.log(type(Symbol())) //symbolconsole.log(type(function()&#123;&#125;)) //functionconsole.log(type(undefined)) //undefinedconsole.log(type(null)) // nullconsole.log(type(Boolean(1)))","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"},{"name":"类型","slug":"类型","permalink":"http://yongchao.tech:8080/tags/类型/"}]},{"title":"类型转换","slug":"类型转换","date":"2019-09-12T11:04:11.000Z","updated":"2019-09-12T03:10:02.238Z","comments":true,"path":"2019/09/12/类型转换/","link":"","permalink":"http://yongchao.tech:8080/2019/09/12/类型转换/","excerpt":"1. 类型转换规则","text":"1. 类型转换规则 2. If语句和逻辑语句在if语句和逻辑语句中，如果只有单个变量，会先将变量转换为Boolean值，只有下面几种情况会转换成false，其余被转换成true： null undefined ‘’ NaN 0 false 3.各种运数学算符我们在对各种非Number类型运用数学运算符(- * /)时，会先将非Number类型转换为Number类型; 1 - true // 0 1 - null // 1 1 * undefined // NaN 2 * [‘5’] //10 注意+是个例外，执行+操作符时：1.当一侧为String类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。2.当一侧为Number类型，另一侧为原始类型，则将原始类型转换为Number类型。3.当一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后拼接。1234123 + &apos;123&apos; // 123123 （规则1）123 + null // 123 （规则2）123 + true // 124 （规则2）123 + &#123;&#125; // 123[object Object] （规则3） 4. ==使用==时，若两侧类型相同，则比较结果和===相同，否则会发生隐式转换，使用==时发生的转换可以分为几种不同的情况（只考虑两侧类型不同） 4-1. NaNNaN和其他任何类型比较永远返回false(包括和他自己)。1NaN == NaN // false 4-2. BooleanBoolean和其他任何类型比较，Boolean首先被转换为Number类型。1234true == 1 // true true == &apos;2&apos; // falsetrue == [&apos;1&apos;] // truetrue == [&apos;2&apos;] // false 这里注意一个可能会弄混的点：undefined、null和Boolean比较，虽然undefined、null和false都很容易被想象成假值，但是他们比较结果是false，原因是false首先被转换成0 4-3.String和NumberString和Number比较，先将String转换为Number类型。12123 == &apos;123&apos; // true&apos;&apos; == 0 // true 4-4 null和undefinednull == undefined比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false。1234567null == undefined // truenull == &apos;&apos; // falsenull == 0 // falsenull == false // falseundefined == &apos;&apos; // falseundefined == 0 // falseundefined == false // false 4-5 原始类型和引用类型当原始类型和引用类型做比较时，对象类型会依照ToPrimitive规则转换为原始类型:12&apos;[object Object]&apos; == &#123;&#125; // true&apos;1,2,3&apos; == [1, 2, 3] // true 来看看下面这个比较：1[] == ![] // true !的优先级高于==，![]首先会被转换为false，然后根据上面第三点，false转换成Number类型0，左侧[]转换为0，两侧比较相等。12[null] == false // true[undefined] == false // true 根据数组的ToPrimitive规则，数组元素为null或undefined时，该元素被当做空字符串处理，所以[null]、[undefined]都会被转换为0。 所以，说了这么多，推荐使用===来判断两个值是否相等…😭 有意思的面试题一道经典的面试题，如何让：a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3。根据上面的拆箱转换，以及==的隐式转换，我们可以轻松写出答案：1234567891011var a = &#123; value:[3,2,1], valueOf: function () &#123;return this.value.pop(); &#125;,&#125;或者var a = &#123; value:[1,2,3], valueOf: function () &#123;return this.value.shift(); &#125;,&#125; 对象和数字比较==，对象会隐式转换为number, 调用valueOf函数","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"},{"name":"类型","slug":"类型","permalink":"http://yongchao.tech:8080/tags/类型/"}]},{"title":"dataTable中自定义列排序问题","slug":"dataTable中自定义列排序问题","date":"2019-09-10T22:49:54.000Z","updated":"2019-09-17T14:53:12.097Z","comments":true,"path":"2019/09/11/dataTable中自定义列排序问题/","link":"","permalink":"http://yongchao.tech:8080/2019/09/11/dataTable中自定义列排序问题/","excerpt":"在使用dataTables的时候，有些列中会是一些包含内容的按钮或链接，不是单纯的文字内容。那么dataTables会将这些内容视为字符串，进行排序，有时候这不符合我们的期望。那么就需要自己能够灵活的指定某些列按照我们的意愿进行排序，幸运的是dataTable支持这样的插件拓展。 首先创建一个文件叫dataTables.sort.plungin.js，加入以下代码。 12345678910111213141516jQuery.extend(jQuery.fn.dataTableExt.oSort, &#123; &quot;html-percent-pre&quot;: function (a) &#123; var x = String(a).replace(/&lt;[\\s\\S]*?&gt;/g, &quot;&quot;); //去除html标记 x = x.replace(/&amp;amp;nbsp;/ig, &quot;&quot;); //去除空格 x = x.replace(/%/, &quot;&quot;); //去除百分号 return parseFloat(x); &#125;, &quot;html-percent-asc&quot;: function (a, b) &#123; //正序排序引用方法 return ((a &lt; b) ? -1 : ((a &gt; b) ? 1 : 0)); &#125;, &quot;html-percent-desc&quot;: function (a, b) &#123; //倒序排序引用方法 return ((a &lt; b) ? 1 : ((a &gt; b) ? -1 : 0)); &#125;&#125;);","text":"在使用dataTables的时候，有些列中会是一些包含内容的按钮或链接，不是单纯的文字内容。那么dataTables会将这些内容视为字符串，进行排序，有时候这不符合我们的期望。那么就需要自己能够灵活的指定某些列按照我们的意愿进行排序，幸运的是dataTable支持这样的插件拓展。 首先创建一个文件叫dataTables.sort.plungin.js，加入以下代码。 12345678910111213141516jQuery.extend(jQuery.fn.dataTableExt.oSort, &#123; &quot;html-percent-pre&quot;: function (a) &#123; var x = String(a).replace(/&lt;[\\s\\S]*?&gt;/g, &quot;&quot;); //去除html标记 x = x.replace(/&amp;amp;nbsp;/ig, &quot;&quot;); //去除空格 x = x.replace(/%/, &quot;&quot;); //去除百分号 return parseFloat(x); &#125;, &quot;html-percent-asc&quot;: function (a, b) &#123; //正序排序引用方法 return ((a &lt; b) ? -1 : ((a &gt; b) ? 1 : 0)); &#125;, &quot;html-percent-desc&quot;: function (a, b) &#123; //倒序排序引用方法 return ((a &lt; b) ? 1 : ((a &gt; b) ? -1 : 0)); &#125;&#125;); 2.在前台页面中加入以下的 js 引用。 12345678910111213141516&lt;script type=&quot;text/javascript&quot; src=&quot;jquery.dataTables.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;dataTables.numericComma.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var oTable1 = $(&apos;#table_report&apos;).dataTable(&#123; &quot;aoColumnDefs&quot;: [ &#123; &quot;sType&quot;: &quot;html-percent&quot;, &quot;aTargets&quot;: [8] &#125;, //指定列号使用自定义排序 ], &quot;bLengthChange&quot;: true, //开关，是否显示每页大小的下拉框 &quot;aLengthMenu&quot;: [[5, 10, 25, -1], [5, 10, 25, &quot;所有&quot;]], &apos;iDisplayLength&apos;: 25, //每页显示10条记录 &apos;bFilter&apos;: true, //是否使用内置的过滤功能 &quot;bInfo&quot;: true, //开关，是否显示表格的一些信息 &quot;bPaginate&quot;: true //开关，是否显示分页器 &#125;); &#125;);&lt;/script&gt;","categories":[{"name":"插件","slug":"插件","permalink":"http://yongchao.tech:8080/categories/插件/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"},{"name":"dataTable","slug":"datatable","permalink":"http://yongchao.tech:8080/tags/datatable/"}]},{"title":"codemirror基本配置","slug":"codemirror基本配置","date":"2019-09-09T22:51:12.000Z","updated":"2019-09-17T14:58:46.645Z","comments":true,"path":"2019/09/10/codemirror基本配置/","link":"","permalink":"http://yongchao.tech:8080/2019/09/10/codemirror基本配置/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031export const editorOption = &#123; tabSize: 2, styleActiveLine: true, line: true, mode: &apos;text/x-nginx-conf&apos;, lineNumbers: true, // 显示行号 theme: &apos;solarized&apos;, // 设置主题 keyMap: &apos;sublime&apos;, // 绑定sublime fullScreen: false, // 全屏模式 matchBrackets: true, // 括号匹配 indentWithTabs: true, readOnly: false&#125;import &#123; codemirror &#125; from &apos;vue-codemirror&apos;import &#123; editorOption &#125; from &apos;@/api/convention&apos;require(&apos;codemirror/keymap/sublime.js&apos;)&lt;div style=&quot;width: 80%;&quot;&gt; &lt;codemirror v-model=&quot;templateForm.content&quot; :options=&quot;editorOption&quot;&gt;&lt;/codemirror&gt;&lt;/div&gt;&lt;style&gt;.CodeMirror &#123; height: 360px;&#125;.CodeMirror-fullscreen &#123; z-index: 9999;&#125;&lt;/style&gt;","categories":[{"name":"插件","slug":"插件","permalink":"http://yongchao.tech:8080/categories/插件/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"},{"name":"codemirror","slug":"codemirror","permalink":"http://yongchao.tech:8080/tags/codemirror/"}]},{"title":"比较两个值相等","slug":"比较两个值相等","date":"2019-09-07T22:54:00.000Z","updated":"2019-09-17T14:57:14.096Z","comments":true,"path":"2019/09/08/比较两个值相等/","link":"","permalink":"http://yongchao.tech:8080/2019/09/08/比较两个值相等/","excerpt":"首先回顾javascript的数据类型： string number boolean undefined null object(array 、function、普通object ) symbol(es6新加) 其中 string、number、boolean 、undefined、null 是直接比较值的，可以通过===判断object 、symbol是比较地址的，地址相同则视为相等 so,","text":"首先回顾javascript的数据类型： string number boolean undefined null object(array 、function、普通object ) symbol(es6新加) 其中 string、number、boolean 、undefined、null 是直接比较值的，可以通过===判断object 、symbol是比较地址的，地址相同则视为相等 so, 123456789101112function valueEqual (a, b) &#123; //处理number string boolean undefined null function symbol if (a === b) return true //处理数组前的预判断 if (!(a instanceof Array) || !(b instanceof Array)) return false if (a.length !== b.length) return false //正式判断数组和对象 for (let i = 0; i &lt; a.length; i++) &#123; if (a[i] !== b[i]) return false &#125; return true&#125;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"}]},{"title":"监听快捷键","slug":"监听快捷键","date":"2019-09-07T22:52:48.000Z","updated":"2019-09-17T15:21:07.295Z","comments":true,"path":"2019/09/08/监听快捷键/","link":"","permalink":"http://yongchao.tech:8080/2019/09/08/监听快捷键/","excerpt":"","text":"123456789101112131415161718192021222324252627&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;script type=&quot;text/javascript&quot; language=JavaScript&gt; document.onkeydown=function(event)&#123; var e = event || window.event || arguments.callee.caller.arguments[0]; if(e &amp;&amp; e.keyCode==27)&#123; // 按 Esc //要做的事情 alert(&quot;按 esc&quot;); &#125; if(e &amp;&amp; e.keyCode==113)&#123; // 按 F2 //要做的事情 alert(&quot;按 f2&quot;); &#125; if(e &amp;&amp; e.keyCode==13)&#123; // enter 键 //要做的事情 alert(&quot;按 Enter&quot;); &#125; if (e.keyCode == 86 &amp;&amp; e.ctrlKey) &#123; alert(&quot;你按下了ctrl+V&quot;); &#125; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"}]},{"title":"repaint重绘和reflow回流","slug":"repaint重绘和reflow回流","date":"2019-09-07T12:16:40.000Z","updated":"2019-09-15T10:25:27.710Z","comments":true,"path":"2019/09/07/repaint重绘和reflow回流/","link":"","permalink":"http://yongchao.tech:8080/2019/09/07/repaint重绘和reflow回流/","excerpt":"前言： 为什么不能用CSS通配符 *，CSS选择器层叠为什么不能超过三层，CSS为什么尽量使用类选择器，书写HTML为什么少使用table，为什么结构要尽量简单-DOM树要小…. 浏览器解析大概的工作流程大致可归纳为四个步骤： 解析HTML以构建DOM树：渲染引擎开始解析HTML文档，转换树中的html标签或js生成的标签到DOM节点，它被称为 – 内容树。 构建渲染树：解析CSS（包括外部CSS文件和样式元素以及js生成的样式）成样式结构体，根据CSS选择器计算出节点的样式，创建另一个树 —- 渲染树（render tree）。 注：在解析的过程中会去掉浏览器不能识别的样式，比如IE会去掉-moz开头的样式，而firefox会去掉_开头的样式。 布局渲染树: 从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标。 绘制渲染树: 遍历渲染树，每个节点将使用UI后端层来绘制。","text":"前言： 为什么不能用CSS通配符 *，CSS选择器层叠为什么不能超过三层，CSS为什么尽量使用类选择器，书写HTML为什么少使用table，为什么结构要尽量简单-DOM树要小…. 浏览器解析大概的工作流程大致可归纳为四个步骤： 解析HTML以构建DOM树：渲染引擎开始解析HTML文档，转换树中的html标签或js生成的标签到DOM节点，它被称为 – 内容树。 构建渲染树：解析CSS（包括外部CSS文件和样式元素以及js生成的样式）成样式结构体，根据CSS选择器计算出节点的样式，创建另一个树 —- 渲染树（render tree）。 注：在解析的过程中会去掉浏览器不能识别的样式，比如IE会去掉-moz开头的样式，而firefox会去掉_开头的样式。 布局渲染树: 从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标。 绘制渲染树: 遍历渲染树，每个节点将使用UI后端层来绘制。 比较： render tree能识别样式，render tree中每个node都有自己的style，而且render tree不包含隐藏的节点(比如display:none的节点，还有head节点)，因为这些节点不会用于呈现，而且不会影响呈现的，所以就不会包含到 render tree中。注意 visibility:hidden隐藏的元素还是会包含到render tree中的，因为visibility:hidden 会影响布局(layout)，会占有空间。定义 我们可以看到 Reflow 和Repaint 分别出现在了第三和第四步。因此我们给出下面的定义： 对于DOM结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式（浏览器的、开发人员定义的等）来计算并根据计算结果将元素放到它该出现的位置，这个过程称之为reflow； 当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称之为repaint。回流与重绘总结： 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。 每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为repaint重绘。 注意：回流必将引起重绘，而重绘不一定会引起回流。 引起Repain和Reflow的一些操作 Reflow 的成本比 Repaint 的成本高得多的多。DOM Tree 里的每个结点都会有 reflow 方法，一个结点的 reflow 很有可能导致子结点，甚至父点以及同级结点的 reflow。 当你增加、删除、修改 DOM 结点时，会导致 Reflow 或 Repaint。 当你移动 DOM 的位置，或是搞个动画的时候。 当你修改 /删除CSS 样式的时候。 当你 Resize 窗口的时候（移动端没有这个问题），或是滚动的时候。 当你修改网页的默认字体时。 当你设置 style 属性的值 （Setting a property of the style attribute）。 注：display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。 如何减少Repain和Reflow? Reflow是不可避免的，只能将Reflow对性能的影响减到最小,给出下面几条建议： 不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className，即将多次改变样式属性的操作合并成一次操作：// 不好的写法 var left = 10, top = 10; el.style.left = left + “px”; el.style.top = top + “px”; el.style.background = ‘#eee’; // 比较好的写法 el.className += “ theclassname”; 让要操作的元素进行”离线处理”，处理完后一起更新使用DocumentFragment进行缓存操作,引发一次回流和重绘；使用display:none技术，只引发两次回流和重绘;原理：由于isplay属性为none的元素不在渲染树中，对隐藏的元素操 作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘； 不要把 DOM 节点的属性值放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性。 尽可能的修改层级比较低的 DOM节点。当然，改变层级比较底的 DOM节点有可能会造成大面积的 reflow，但是也可能影响范围很小。 因为改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点。这导致大量时间耗费在执行 reflow 上面 将需要多次重排的元素，position属性设为absolute或fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素为动画的 HTML 元素，例如动画，那么修改他们的 CSS 是会大大减小 reflow 。因为, 它们不影响其他元素的布局，所它他们只会导致重新绘制，而不是一个完整回流。这样消耗会更低。 不要用tables布局的一个原因就是tables中某个元素一旦触发reflow就会导致table里所有的其它元素reflow。在适合用table的场合，可以设置table-layout为auto或fixed，这样可以让table一行一行的 渲染，这种做法也是为了限制reflow的影响范围。 避免使用CSS的JavaScript表达式，如果css里有expression，每次都会重新计算一遍。 来源： https://blog.csdn.net/ClaireKe/article/details/51375622","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yongchao.tech:8080/tags/css/"},{"name":"渲染过程","slug":"渲染过程","permalink":"http://yongchao.tech:8080/tags/渲染过程/"}]},{"title":"从url到页面渲染的流程","slug":"从url到页面渲染的流程","date":"2019-09-07T11:45:28.000Z","updated":"2019-09-15T10:25:44.397Z","comments":true,"path":"2019/09/07/从url到页面渲染的流程/","link":"","permalink":"http://yongchao.tech:8080/2019/09/07/从url到页面渲染的流程/","excerpt":"从用户在浏览器中输入一个URL，到整个页面渲染，这个过程中究竟发生了什么呢？今天先简单写下整个过程，后面再一点点完善。 DNS解析获取IP地址 首先会在浏览器的缓存中查找，是否缓存了URL，如果有，就直接向该URL对应的服务器发送请求；如果没有则进行下一步; 在本地的hosts文件中是否保存了该URL和其对应的IP地址，如果保存了，就直接向该URL对应的服务器发送请求；如果没有则进行下一步； 向本地DNS服务器（一般由本地网络接入服务器提供商ISP提供，比如移动、联通）发送DNS请求，本地DNS服务器会首先查询它的缓存记录，如果有就将该域名对应的IP地址返回给用户，如果没有则进行下一步； 首先向根域名服务器发送DNS查询请求，根域名服务器返回给可能保存了该域名的一级域名服务器地址；本地主机再根据返回的地址，向一级域名服务器发送DNS查询请求；…一直迭代，直到找到对应的域名存放的服务器，向其发送DNS查询请求，该域名服务器返回该域名对应的IP地址；","text":"从用户在浏览器中输入一个URL，到整个页面渲染，这个过程中究竟发生了什么呢？今天先简单写下整个过程，后面再一点点完善。 DNS解析获取IP地址 首先会在浏览器的缓存中查找，是否缓存了URL，如果有，就直接向该URL对应的服务器发送请求；如果没有则进行下一步; 在本地的hosts文件中是否保存了该URL和其对应的IP地址，如果保存了，就直接向该URL对应的服务器发送请求；如果没有则进行下一步； 向本地DNS服务器（一般由本地网络接入服务器提供商ISP提供，比如移动、联通）发送DNS请求，本地DNS服务器会首先查询它的缓存记录，如果有就将该域名对应的IP地址返回给用户，如果没有则进行下一步； 首先向根域名服务器发送DNS查询请求，根域名服务器返回给可能保存了该域名的一级域名服务器地址；本地主机再根据返回的地址，向一级域名服务器发送DNS查询请求；…一直迭代，直到找到对应的域名存放的服务器，向其发送DNS查询请求，该域名服务器返回该域名对应的IP地址； TCP/IP连接三次握手：为什么要进行三次握手？如果是两次握手，如下面的对话只有前两句，有可能出现的问题是：客户端之前发送了一个连接请求报文，由于网络原因滞留在网络中，后来到达服务器端，服务器接收到该请求，就会建立连接，等待客户端传送数据。而此时客户端压根就不知道发生了什么，白白造成了服务器资源浪费。 客户端：我要请求数据可以吗？ 服务器：可以的 客户端：好的 浏览器向web服务器发送http请求 客户机与服务器建立连接后就可以通信了，这里就暂时先不详细展开说http请求了。讲下客户端请求静态资源和动态资源。 静态资源：如果客户端请求的是静态资源，则web服务器根据URL地址到服务器的对应路径下查找文件，然后给客户端返回一个HTTP响应，包括状态行、响应头和响应正文。 动态资源：如果客户端请求的是动态资源，则web服务器会调用CGI/VM执行程序完成相应的操作，如查询数据库，然后返回查询结果数据集，并将运行的结果–HTML文件返回给web服务器。Web服务器再将HTML文件返回给用户。 浏览器渲染 详情请看http://yongchao.tech:8080/2019/09/07/repaint重绘和reflow回流/ 浏览器拿到HTML文件后，根据渲染规则进行渲染： 解析HTML，构建DOM树 解析CSS，生成CSS规则树 合并DOM树和CSS规则树，生成render树 布局render树 绘制render数、树，即绘制页面像素信息 GPU将各层合成，结果呈现在浏览器窗口中。 四次挥手客户端没有数据发送时就需要断开连接，以释放服务器资源。 客户端：我没有数据要发送了，打算断开连接 服务器：你的请求我收到了，我这还有数据没有发送完成，你等下 服务器：我的数据发送完毕，可以断开连接了 客户端：ok，你断开连接吧（客户端独白：我将在2倍的最大报文段生存时间后关闭连接。如果我再次收到服务器的消息，我就知道服务器没有收到我的这句话，我就再发送一遍）。最终服务器收到该客户端发送的消息断开连接，客户端也关闭连接。 注：本文摘自 https://segmentfault.com/a/1190000014311983","categories":[],"tags":[{"name":"渲染过程","slug":"渲染过程","permalink":"http://yongchao.tech:8080/tags/渲染过程/"}]},{"title":"reduce函数的应用","slug":"reduce函数的应用","date":"2019-08-25T22:38:13.000Z","updated":"2019-08-25T14:41:26.454Z","comments":true,"path":"2019/08/26/reduce函数的应用/","link":"","permalink":"http://yongchao.tech:8080/2019/08/26/reduce函数的应用/","excerpt":"1var arr = [11,3,4,556,7,8,-4] 获得最大值/最小值123var a= arr.reduce((a, b) =&gt; &#123; return a &gt; b ? a: b&#125;)","text":"1var arr = [11,3,4,556,7,8,-4] 获得最大值/最小值123var a= arr.reduce((a, b) =&gt; &#123; return a &gt; b ? a: b&#125;) 数组去重1234567var arr1 = [1, 2, 3, 1, 1, 2, 3, 3, 4, 3, 4, 5]let ret1 = arr1.reduce((a, b) =&gt; &#123; if(!a.includes(b)) &#123; a.push(b) &#125; return a&#125;, []) 实现map函数1234567891011Array.prototype._map = function(cb) &#123; if(typeof cb === &apos;function&apos;) &#123; let arr = this return arr.reduce((prev, next, index, array) =&gt; &#123; prev.push(cb(next, index, array)) return prev &#125;, []) &#125;else&#123; throw new Error(&apos;cb&apos; + &apos; is not function&apos; ) &#125;&#125; 实现一个filter函数1234567891011Array.prototype._filter = function(cb) &#123; if(typeof cb === &apos;function&apos;) &#123; let arr = this return arr.reduce((prev, next, index, array) =&gt; &#123; cb(next, index, array) &amp;&amp; prev.push(next) return prev &#125;, []) &#125;else&#123; throw new Error(&apos;cb&apos; + &apos; is not function&apos; ) &#125;&#125; 数组扁平化1234567891011let arr2 = [1, 2, &apos;3js&apos;, [4, 5, [6], [7, 8, [9, 10, 11], null, &apos;abc&apos;], &#123;age: 12&#125;, [13, 14]], &apos;[]&apos;];function flatten(arr) &#123; if(Array.isArray(arr)) &#123; return arr.reduce((prev, cur) =&gt; &#123; // 如果遍历的当前项是数组，再迭代展平 return Array.isArray(cur) ? prev.concat(flatten(cur)) : prev.concat(cur) &#125;, []) &#125; else &#123; throw new Error(arr + &apos; is not array&apos;) &#125;&#125; 统计字符串中每个字符出现的次数123456const str = &apos;9kFZTQLbUWOjurz9IKRdeg28rYxULHWDUrIHxCY6tnHleoJ&apos;var ret3 = Array.from(str).reduce((accumulator, current) =&gt; &#123; current in accumulator ? accumulator[current]++ : accumulator[current] = 1 return accumulator&#125;, &#123;&#125;) 过滤满足多个条件的数组 将过滤函数作为数组进行调用， 初始值为原数据数组 123const filter1 = (arr) =&gt; arr.filter(item =&gt; item.name.length === 3)const filter2 = (arr) =&gt; arr.filter(item =&gt; item.age &gt; 26)var ret5 = [filter1, filter2].reduce((accumulator, fn) =&gt; fn(accumulator), arr4)","categories":[],"tags":[]},{"title":"css中的各种尺寸","slug":"css中的各种尺寸","date":"2019-08-20T22:11:46.000Z","updated":"2019-09-05T02:10:22.349Z","comments":true,"path":"2019/08/21/css中的各种尺寸/","link":"","permalink":"http://yongchao.tech:8080/2019/08/21/css中的各种尺寸/","excerpt":"","text":"","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yongchao.tech:8080/tags/css/"}]},{"title":"repalce函数的应用","slug":"repalce函数的应用","date":"2019-08-20T21:51:37.000Z","updated":"2019-08-25T14:39:08.318Z","comments":true,"path":"2019/08/21/repalce函数的应用/","link":"","permalink":"http://yongchao.tech:8080/2019/08/21/repalce函数的应用/","excerpt":"介绍 字符 替换文本 $1、$2…$99 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。 $&amp; 与 regexp 相匹配的子串。 $` 位于匹配子串左侧的文本。 $’ 位于匹配子串右侧的文本。 $$ 直接量符号。","text":"介绍 字符 替换文本 $1、$2…$99 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。 $&amp; 与 regexp 相匹配的子串。 $` 位于匹配子串左侧的文本。 $’ 位于匹配子串右侧的文本。 $$ 直接量符号。 格式化日期1234567891011var date = new Date().toLocaleString()//method1var formatDate= date.replace(/(\\d+)\\/(\\d+)\\/(\\d+)\\s+[\\u4e00-\\u9fa5]+(\\d+):(\\d+):(\\d+)/g, &apos;$1/$2/$3 $3:$4:$5&apos;)console.log(formatDate ) // 2019/8/20 20:11:43//method2date.replace(/[\\u4e00-\\u9fa5]+(\\d+):(\\d+):(\\d+)/g, function(all, p1,p2,p3)&#123; return [p1, p2, p3].join(&apos;:&apos;)&#125;) 转换为驼峰命名1var s1 = &quot;get-element-by-id&quot; // 转化为 getElementById 12345var f = function(s) &#123; return s.replace(/-\\w/g, function(x) &#123; return x.slice(1).toUpperCase(); &#125;)&#125; 查找字符串中出现最多的字符和个数 例: abbcccddddd -&gt; 字符最多的是d，出现了5次 1234567891011121314151617let str = &quot;abcabcabcbbccccc&quot;;let num = 0;let char = &apos;&apos;; // 使其按照一定的次序排列str = str.split(&apos;&apos;).sort().join(&apos;&apos;);// &quot;aaabbbbbcccccccc&quot;// 定义正则表达式let re = /(\\w)\\1+/g;str.replace(re,($0,$1) =&gt; &#123; if(num &lt; $0.length)&#123; num = $0.length; char = $1; &#125;&#125;);console.log(`字符最多的是$&#123;char&#125;，出现了$&#123;num&#125;次`); 实现千位分隔符 // 保留三位小数parseToMoney(1234.56); // return ‘1,234.56’parseToMoney(123456789); // return ‘123,456,789’parseToMoney(1087654.321); // return ‘1,087,654.321’ 1234567891011function parseToMoney(num) &#123; num = parseFloat(num.toFixed(3)); let [integer, decimal] = String.prototype.split.call(num, &apos;.&apos;); integer = integer.replace(/\\d(?=(\\d&#123;3&#125;)+$)/g, &apos;$&amp;,&apos;); return integer + &apos;.&apos; + (decimal ? decimal : &apos;&apos;);&#125;作者：寻找海蓝96链接：https://juejin.im/post/5d51e16d6fb9a06ae17d6bbc来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ?=正向肯定预查 详细信息看这里正则的基本知识","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"}]},{"title":"visibilty:hidden、display:none、opacity:0的区别","slug":"visibilty、display-none的区别","date":"2019-08-19T13:22:30.000Z","updated":"2019-08-25T14:40:19.749Z","comments":true,"path":"2019/08/19/visibilty、display-none的区别/","link":"","permalink":"http://yongchao.tech:8080/2019/08/19/visibilty、display-none的区别/","excerpt":"","text":"分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景display: none;1.DOM 结构：浏览器不会渲染 display 属性为 none 的元素，不占据空间；2.事件监听：无法进行 DOM 事件监听；3.性能：动态改变此属性时会引起重排，性能较差；4.继承：不会被子元素继承，毕竟子类也不会被渲染；5.transition：transition 不支持 display。 visibility: hidden;1.DOM 结构：元素被隐藏，但是会被渲染不会消失，占据空间；2.事件监听：无法进行 DOM 事件监听；3.性 能：动态改变此属性时会引起重绘，性能较高；4.继 承：会被子元素继承，子元素可以通过设置 visibility: visible; 来取消隐藏；5.transition：transition 不支持 display。 ###opacity: 0;1.DOM 结构：透明度为 100%，元素隐藏，占据空间；2.事件监听：可以进行 DOM 事件监听；3.性 能：提升为合成层，不会触发重绘，性能较高；4.继 承：会被子元素继承,且，子元素并不能通过 opacity: 1 来取消隐藏；5.transition：transition 不支持 opacity。 联系：它们都能让元素不可见摘自 https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/100","categories":[],"tags":[]},{"title":"深度优先遍历和广度优先遍历","slug":"深度优先遍历和广度优先遍历","date":"2019-08-15T23:28:18.000Z","updated":"2019-09-15T15:28:42.968Z","comments":true,"path":"2019/08/16/深度优先遍历和广度优先遍历/","link":"","permalink":"http://yongchao.tech:8080/2019/08/16/深度优先遍历和广度优先遍历/","excerpt":"","text":"广度优先遍历12345678910111213141516function traverse(node) &#123; let stack = [] let nodes = [] if(node) &#123; stack.push(node) while(stack.length) &#123; let item = stack.shift() let children = item.children nodes.push(item) for(let i=0;i&lt;children.length;i++) &#123; stack.push(children[i]) &#125; &#125; &#125; return nodes&#125; 深度优先遍历12345678910function deepTraverse(node, ret) &#123; if(node !== null) &#123; ret.push(node) let children = node.children for(let i=0;i&lt;children.length;i++) &#123; deepTraverse(children[i], ret) &#125; &#125; return ret&#125;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"},{"name":"算法","slug":"算法","permalink":"http://yongchao.tech:8080/tags/算法/"}]},{"title":"list转成tree型数据结构","slug":"list转成tree型数据结构","date":"2019-08-09T14:53:18.000Z","updated":"2019-09-16T00:56:29.499Z","comments":true,"path":"2019/08/09/list转成tree型数据结构/","link":"","permalink":"http://yongchao.tech:8080/2019/08/09/list转成tree型数据结构/","excerpt":"12345678910111213141516function convert(list) &#123; const res = [] const map = list.reduce((res, v) =&gt; (res[v.id] = v, res), &#123;&#125;) for (const item of list) &#123; if (item.parentId === 0) &#123; res.push(item) continue &#125; if (item.parentId in map) &#123; const parent = map[item.parentId] parent.children = parent.children || [] parent.children.push(item) &#125; &#125; return res&#125; 原始 list 数据 如下123456789101112let list =[ &#123;id:1,name:&apos;部门A&apos;,parentId:0&#125;, &#123;id:2,name:&apos;部门B&apos;,parentId:0&#125;, &#123;id:3,name:&apos;部门C&apos;,parentId:1&#125;, &#123;id:4,name:&apos;部门D&apos;,parentId:1&#125;, &#123;id:5,name:&apos;部门E&apos;,parentId:2&#125;, &#123;id:6,name:&apos;部门F&apos;,parentId:3&#125;, &#123;id:7,name:&apos;部门G&apos;,parentId:2&#125;, &#123;id:8,name:&apos;部门H&apos;,parentId:4&#125;, &#123;id:9,name:&apos;部门H&apos;,parentId:8&#125;];const result = convert(list);","text":"12345678910111213141516function convert(list) &#123; const res = [] const map = list.reduce((res, v) =&gt; (res[v.id] = v, res), &#123;&#125;) for (const item of list) &#123; if (item.parentId === 0) &#123; res.push(item) continue &#125; if (item.parentId in map) &#123; const parent = map[item.parentId] parent.children = parent.children || [] parent.children.push(item) &#125; &#125; return res&#125; 原始 list 数据 如下123456789101112let list =[ &#123;id:1,name:&apos;部门A&apos;,parentId:0&#125;, &#123;id:2,name:&apos;部门B&apos;,parentId:0&#125;, &#123;id:3,name:&apos;部门C&apos;,parentId:1&#125;, &#123;id:4,name:&apos;部门D&apos;,parentId:1&#125;, &#123;id:5,name:&apos;部门E&apos;,parentId:2&#125;, &#123;id:6,name:&apos;部门F&apos;,parentId:3&#125;, &#123;id:7,name:&apos;部门G&apos;,parentId:2&#125;, &#123;id:8,name:&apos;部门H&apos;,parentId:4&#125;, &#123;id:9,name:&apos;部门H&apos;,parentId:8&#125;];const result = convert(list); 结果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758[ &#123; &quot;id&quot;:1, &quot;name&quot;:&quot;部门A&quot;, &quot;parentId&quot;:0, &quot;children&quot;:[ &#123; &quot;id&quot;:3, &quot;name&quot;:&quot;部门C&quot;, &quot;parentId&quot;:1, &quot;children&quot;:[ &#123; &quot;id&quot;:6, &quot;name&quot;:&quot;部门F&quot;, &quot;parentId&quot;:3 &#125; ] &#125;, &#123; &quot;id&quot;:4, &quot;name&quot;:&quot;部门D&quot;, &quot;parentId&quot;:1, &quot;children&quot;:[ &#123; &quot;id&quot;:8, &quot;name&quot;:&quot;部门H&quot;, &quot;parentId&quot;:4, &quot;children&quot;:[ &#123; &quot;id&quot;:9, &quot;name&quot;:&quot;部门H&quot;, &quot;parentId&quot;:8 &#125; ] &#125; ] &#125; ] &#125;, &#123; &quot;id&quot;:2, &quot;name&quot;:&quot;部门B&quot;, &quot;parentId&quot;:0, &quot;children&quot;:[ &#123; &quot;id&quot;:5, &quot;name&quot;:&quot;部门E&quot;, &quot;parentId&quot;:2 &#125;, &#123; &quot;id&quot;:7, &quot;name&quot;:&quot;部门G&quot;, &quot;parentId&quot;:2 &#125; ] &#125;]","categories":[{"name":"graph","slug":"graph","permalink":"http://yongchao.tech:8080/categories/graph/"}],"tags":[]},{"title":"绘制网络拓扑图","slug":"绘制网络拓扑图","date":"2019-08-08T23:58:17.000Z","updated":"2019-08-08T16:20:37.448Z","comments":true,"path":"2019/08/09/绘制网络拓扑图/","link":"","permalink":"http://yongchao.tech:8080/2019/08/09/绘制网络拓扑图/","excerpt":"效果图如下： 实现原理以及优缺点实现原理实际上是graph类型和lines类型结合画出来的，graph可以绘制的拓扑图,目前三种layout, 包括力导图(force)、环形布局(circular)、二维坐标系(none)。前两种基本上排版位置不怎么受自己控制，第三种的画，节点位置完全的受数据中的x/y位置控制，但是估计计算位置是个麻烦事儿，如果节点的数量很少或者说比较固定的话，采用这个非常不错。lines类型主要负责线条上添加动态的效果 live demohttps://gallery.echartsjs.com/editor.html?c=xbETBRwXrm或者http://39.105.159.58:3000/#/graph","text":"效果图如下： 实现原理以及优缺点实现原理实际上是graph类型和lines类型结合画出来的，graph可以绘制的拓扑图,目前三种layout, 包括力导图(force)、环形布局(circular)、二维坐标系(none)。前两种基本上排版位置不怎么受自己控制，第三种的画，节点位置完全的受数据中的x/y位置控制，但是估计计算位置是个麻烦事儿，如果节点的数量很少或者说比较固定的话，采用这个非常不错。lines类型主要负责线条上添加动态的效果 live demohttps://gallery.echartsjs.com/editor.html?c=xbETBRwXrm或者http://39.105.159.58:3000/#/graph 注意点1.nodes数据的x/y值一定要指定，否则画不出来2.graph类型必须设置coordinateSystem: ‘cartesian2d’,指定定位系统采用二维坐标轴 附上vue实现的代码graph.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185&lt;template&gt; &lt;div&gt; &lt;div ref=&quot;chart&quot; style=&quot;height:800px;border:solid 1px red&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import echarts from &apos;echarts&apos;import graph from &apos;./data2&apos;let vm = nullexport default &#123; components: &#123; &#125;, data () &#123; return &#123; charts: &#123; nodes: graph.data.elements.nodes, edges: graph.data.elements.edges, linesData: [] &#125;, nodePositionMap: new Map(), chartInstance: null &#125; &#125;, computed: &#123; &#125;, methods: &#123; initData () &#123; this.charts.nodes = this.charts.nodes.map(node =&gt; &#123; this.nodePositionMap.set(node.data.name, [node.position.x, node.position.y]) return &#123; name: node.data.name, data: node.data, value: [node.position.x, node.position.y], // x: node.position.x, // y: node.position.y, symbolSize: 20 * node.data.size, // alarm: node.alarm, // symbol: &apos;image:///asset/get/s/&apos; + node.img, itemStyle: &#123; normal: &#123; color: &apos;#12b5d0&apos; &#125; &#125; &#125; &#125;) this.charts.linesData = [] this.charts.edges = this.charts.edges.map(edge =&gt; &#123; this.charts.linesData.push([ &#123; coord: this.nodePositionMap.get(edge.data.source) &#125;, &#123; coord: this.nodePositionMap.get(edge.data.target) &#125; ]) return &#123; source: edge.data.source, target: edge.data.target, label: &#123; normal: &#123; show: true // formatter: edge.nam &#125; &#125;, lineStyle: &#123; normal: &#123; color: edge.data.colour &#125; &#125; &#125; &#125;) &#125;, init () &#123; this.initData() let option = &#123; title: &#123; text: &apos;网络拓扑图&apos; &#125;, tooltip: &#123; trigger: &apos;item&apos;, formatter: &apos;&#123;b&#125;&apos;, alwaysShowContent: true &#125;, backgroundColor: &apos;#F5F5F5&apos;, xAxis: &#123; min: 0, max: 800, show: false, type: &apos;value&apos; &#125;, yAxis: &#123; min: 0, max: 300, type: &apos;value&apos;, show: false &#125;, series: [ &#123; type: &apos;graph&apos;, layout: &apos;none&apos;, id: &apos;a&apos;, coordinateSystem: &apos;cartesian2d&apos;, edgeSymbol: [&apos;&apos;, &apos;arrow&apos;], // symbolSize: 50, label: &#123; normal: &#123; show: true, position: &apos;bottom&apos; // color: &apos;#12b5d0&apos; &#125; &#125;, lineStyle: &#123; normal: &#123; width: 2, shadowColor: &apos;none&apos; &#125; &#125;, xAxis: &#123; min: 0, max: 12, show: false, type: &apos;value&apos; &#125;, yAxis: &#123; min: 0, max: 12, show: false, type: &apos;value&apos; &#125;, // edgeSymbolSize: 8, draggable: true, nodes: this.charts.nodes, edges: this.charts.edges, z: 4, itemStyle: &#123; normal: &#123; label: &#123; show: true, formatter: function (item) &#123; return item.data.name &#125; &#125; &#125; &#125; &#125;, &#123; name: &apos;A&apos;, type: &apos;lines&apos;, coordinateSystem: &apos;cartesian2d&apos;, z: 4, effect: &#123; show: true, trailLength: 0, symbol: &apos;arrow&apos;, color: &apos;#12b5d0&apos;, symbolSize: 8 &#125;, lineStyle: &#123; normal: &#123; curveness: 0 &#125; &#125;, data: this.charts.linesData &#125; ] &#125; this.chartInstance = echarts.init(this.$refs.chart) this.chartInstance.setOption(option) &#125; &#125;, mounted () &#123; vm = this this.$nextTick(() =&gt; &#123; this.init() &#125;) window.addEventListener(&apos;resize&apos;, () =&gt; &#123; vm.chartInstance &amp;&amp; this.chartInstance.resize() &#125;) &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 想要看更详细的代码以及其他的栗子源码看这里https://github.com/xuyongchaos/vue-charts.git","categories":[{"name":"graph","slug":"graph","permalink":"http://yongchao.tech:8080/categories/graph/"}],"tags":[{"name":"graph","slug":"graph","permalink":"http://yongchao.tech:8080/tags/graph/"}]},{"title":"vue中使用highcharts和echarts的实践","slug":"vue中使用highcharts和echarts的实践","date":"2019-08-08T06:46:59.937Z","updated":"2019-09-16T00:58:07.106Z","comments":true,"path":"2019/08/08/vue中使用highcharts和echarts的实践/","link":"","permalink":"http://yongchao.tech:8080/2019/08/08/vue中使用highcharts和echarts的实践/","excerpt":"","text":"我从事云平台前端的开发，由于项目的需要，写了一个云监控Monitor项目。起初，我选择了 Echarts， 原因很简单，中文文档，定制化能力也比较好。事实上，使用了一年多来，用的也是蛮顺手的。但是，这是一个监控项目,里面存在大量的图，每个图有着巨量的数据，而且每条line的名字也超长。带来的问题就是，页面及其卡顿，即使是我限制了每个图中的数据量，仍然无法降低，页面无操作的情况下，CPU仍然占据20%以上（八个图，每个图平均10条line）。网上找了一通，都指向z_render()函数，echarts会不停的执行这个函数。实在是不堪忍受这样的卡顿，在进行了充分调研的情况下,果断换了highcharts。 经过实际项目测试：同等数量的情况下，highcharts和echarts 所占的内存相近，但CPU占比很低。举一个栗子，一个页面上有八个图，每个图平均大概10条线，当页面渲染完成，无任何鼠标点击的时候，echarts的CPU占比稳定在20%左右，highcharts始终在1%以下。","categories":[{"name":"graph","slug":"graph","permalink":"http://yongchao.tech:8080/categories/graph/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yongchao.tech:8080/tags/vue/"},{"name":"highcharts","slug":"highcharts","permalink":"http://yongchao.tech:8080/tags/highcharts/"},{"name":"echarts","slug":"echarts","permalink":"http://yongchao.tech:8080/tags/echarts/"}]},{"title":"vue-cli3 入门","slug":" vue-cli3入门","date":"2019-08-08T06:46:59.931Z","updated":"2019-08-08T06:46:59.931Z","comments":true,"path":"2019/08/08/ vue-cli3入门/","link":"","permalink":"http://yongchao.tech:8080/2019/08/08/ vue-cli3入门/","excerpt":"官方文档 1. vue-cli3实现分环境打包步骤通过改变 process.env.NODE_ENV 值区分打包环境，但是webpack打包时针对process.env.NODE_ENV===&#39;production&#39; 和其他情况打出来的包结构和大小都不一样； 为了消除这种差异，可以使用其他变量比如 process.env.VUE_APP_TITLE 来区分环境。XXXXx","text":"官方文档 1. vue-cli3实现分环境打包步骤通过改变 process.env.NODE_ENV 值区分打包环境，但是webpack打包时针对process.env.NODE_ENV===&#39;production&#39; 和其他情况打出来的包结构和大小都不一样； 为了消除这种差异，可以使用其他变量比如 process.env.VUE_APP_TITLE 来区分环境。XXXXx 需求： 打包一个测试环境alpha，该环境的打包和production一样，只是开发中用到的一些变量需要区分环境 说明： 打包时判断环境还是用process.env.NODE_ENV，我们不用处理 项目中用到的区分环境的变量我们自己定义 实施： package.json中打包命令： 123456789&#123;··· &quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;alpha&quot;: &quot;vue-cli-service build --mode alpha&quot; &#125;,···&#125; 在项目根目录添加文件.env.alpha”，其内容为： 12NODE_ENV=productionVUE_APP_TITLE=alpha 区分环境: 123通过env判断环境var env = process.env.VUE_APP_TITLE === &apos;alpha&apos; ? &apos;alpha&apos; : process.env.NODE_ENV === &apos;production&apos; ? &apos;production&apos; : &apos;development&apos; 2. 配置2.1 基本配置默认 baseUrl: &#39;/&#39; , 再部署环境会报错，需要改成 ./ vue.config.js1234module.exports = &#123; baseUrl: process.env.NODE_ENV === &apos;production&apos; ? &apos;./&apos; : &apos;/&apos;, productionSourceMap: false&#125; 2.2. 配置alias12345678910111213const path = require(&apos;path&apos;)function resolve (dir) &#123; return path.join(__dirname, dir)&#125;module.exports = &#123; baseUrl: process.env.NODE_ENV === &apos;production&apos; ? &apos;./&apos; : &apos;/&apos;, chainWebpack: (config) =&gt; &#123; config.resolve.alias .set(&apos;styles&apos;, resolve(&apos;src/assets/styles&apos;)) .set(&apos;components&apos;, resolve(&apos;src/components&apos;)) &#125;&#125; 2.3. 设置启动端口默认是8080，被占用时依次累加。注意：mac上普通用户可设置的最小端口是1024，要配置小于1024的端口需要管理员权限123devServer: &#123; port: 80&#125;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yongchao.tech:8080/tags/vue/"}]},{"title":"MySQL常见错误码","slug":"MySQL常见错误码","date":"2019-08-08T06:46:59.931Z","updated":"2019-08-08T06:46:59.931Z","comments":true,"path":"2019/08/08/MySQL常见错误码/","link":"","permalink":"http://yongchao.tech:8080/2019/08/08/MySQL常见错误码/","excerpt":"0101 属于其他进程的专用标志。0102 标志已经设置，无法关闭。0103 无法再次设置该标志。0104 中断时无法请求专用标志。","text":"0101 属于其他进程的专用标志。0102 标志已经设置，无法关闭。0103 无法再次设置该标志。0104 中断时无法请求专用标志。 0105 此标志先前的所有权已终止。0106 请将软盘插入驱动器 %1。0107 后续软盘尚未插入，程序停止。0108 磁盘正在使用或已由其他进程锁定。0109 管道已经结束。 0110 系统无法打开指定的设备或文件。0111 文件名太长。 0112 磁盘空间不足。0113 没有其他可用的内部文件标识符。0114 目标内部文件标识符不正确。0117 该应用程序所运行的 IOCTL 调用不正确。0118 校验写入的开关参数值不正确。0119 系统不支持所请求的命令。0120 该系统上不支持此功能。0121 标记已超时。0123 文件名、目录名或卷标语法错误。0124 系统调用层不正确。0125 磁盘没有卷标。0126 找不到指定的模块。0127 找不到指定的过程。0128 没有要等候的子进程。0129 模式下运行。0130 试图使用操作(而非原始磁盘I/O)的已打开磁盘分区的文件句柄。0131 试图将文件指针移至文件开头之前。0132 无法在指定的设备或文件中设置文件指针。0133 对于包含已连接驱动器的驱动器，不能使用 JOIN 或 SUBST 命令。0134 试图在已经连接的驱动器上使用 JOIN 或 SUBST 命令。0135 试图在已经替换的驱动器上使用 JOIN 或 SUBST 命令。0136 系统试图删除尚未连接的驱动器的 JOIN。0137 系统试图删除尚未替换的驱动器的替换项。0138 系统试图将驱动器连接到已连接的驱动器下的目录。0139 系统试图将驱动器替换成已替换的驱动器下的目录。0140 系统试图将驱动器连接到已替换的驱动器的一个目录中。0141 系统试图将驱动器替换成到已连接的驱动器下的目录。0142 此时系统无法运行 JOIN 或 SUBST。0143 系统无法将驱动器连接到或替换成同一驱动器下的目录。0144 此目录不是该根目录的子目录。0145 该目录未清空。0146 指定的路径已经在替换中使用。0147 资源不足，无法执行该命令。0148 此时无法使用指定的路径。0149 试图连接或替换某个驱动器目录，该驱动器上的某个目录是上一次替换的目标目录。0150 CONFIG.SYS 文件未指定系统跟踪信息，或禁止跟踪。0151 DosMuxSemWait 的指定信号事件的数目不正确。0152 DosMuxSemWait 没有运行；已经设置太多的标志。0153 DosMuxSemWait 列表不正确。0154 输入的卷标超过目标文件系统的标号字符长度极限。0155 无法创建其他线程。0156 接收进程拒绝该信号。0157 已经放弃该区域，因此无法锁定。0158 该区域已经解除锁定。0159 线程标识符的地址错误。0160 传到 DosExecPgm 的参数字符串错误。0161 指定的路径无效。0162 信号已挂起。0164 系统无法创建其他线程。0167 无法锁定文件的范围。0170 所要求的资源正在使用中。0173 锁定请求对于提供的取消区域不重要。0174 文件系统不支持到锁定类型的自动更改。0180 系统检测到错误的区域号码。 0182 操作系统无法运行 %1。0183 不能创建已经存在的文件。0186 传送的标志不正确。0187 找不到指定的系统信号名称。0188 操作系统无法运行 %1。0189 操作系统无法运行 %1。0190 操作系统无法运行 %1。0191 无法在 Win32 模式下运行 %1。0192 操作系统无法运行 %1。0193 %1 不是有效的 Win32 应用程序。0194 操作系统无法运行 %1。0195 操作系统无法运行 %1。0196 操作系统无法运行此应用程序。0197 当前无法配置操作系统运行此应用程序。0198 操作系统无法运行 %1。0199 操作系统无法运行此应用程序。0200 代码段应小于 64K。0201 操作系统无法运行 %1。0202 操作系统无法运行 %1。0203 系统找不到输入的环境选项。0205 在命令子树中的进程没有信号句柄。0206 文件名或扩展名太长。0207 环 2 堆栈正在使用中。0208 输入的全局文件名字符 * 或 ? 不正确，或指定的全局文件名字符太多。 0209 所发送的信号不正确。0210 无法设置信号处理程序。0212 区域已锁定，无法重新分配。0214 附加到此程序或动态链接模块的动态链接模块太多。0215 无法嵌套调用 LoadModule。0216 图像文件 %1 有效，但不适用于本机类型。 0230 管道状态无效。0231 所有的管道实例都处于忙状态。0232 管道正在关闭。0233 在管道的另一端没有进程。0234 有更多可用的数据。0240 已取消会话。0254 指定的扩展属性名无效。0255 扩展属性不一致。0258 等待操作过时。0259 没有其他可用数据。0266 无法使用复制功能。0267 目录名无效。0275 扩展属性不匹配缓冲区。0276 所装载的文件系统上的扩展属性文件已被损坏。0277 扩展属性表格文件已满。0278 指定的扩展属性句柄无效。0282 安装的文件系统不支持扩展属性。0288 试图释放不属于调用者的多路同步信号。0298 信号投递的次数太多。0299 仅完成部分 ReadProcessMemory 或 WriteProcessMemory 请求。 0300 操作锁定请求被拒绝。0301 系统接收了一个无效的操作锁定确认。0317 在 %2 的消息文件中，系统无法找到消息号为 0x%1 的消息文本。0487 试图访问无效地址。0534 运算结果超过 32 位。0535 该管道的另一方有一进程。 0536 等候进程打开管道的另一端。0994 拒绝对扩展属性的访问。0995 由于线程退出或应用程序的要求，I/O 操作异常终止。0996 重叠的 I/O 事件不处于已标记状态。0997 正在处理重叠的 I/O 操作。0998 对内存位置的无效访问。0999 执行页内操作出错。1001 递归太深；堆栈溢出。1002 窗口无法用来发送消息。1003 无法完成此项功能。1004 标志无效。1005 卷不包含已识别的文件系统。请确认所有需要的文件系统驱动程序都已经加载，而且卷没有任何损坏。1006 某文件的卷已在外部改变，因而打开的文件不再有效。1007 要求的操作无法以全屏幕模式执行。1008 试图引用并不存在的符号。1009 配置注册表数据库已损坏。1010 配置注册表主键无效。1011 无法打开配置注册表主键。1012 无法读取配置注册表主键。1013 无法写入配置注册表主键。1014 必须使用日志文件或其他副本来恢复注册表数据库中的某个文件。恢复成功。 1015 注册表已损坏。可能是一个包含注册表数据文件的结构已损坏，也可能内存中该文件的系统映像已损坏，或者因为备份副本（或日志）不存在（或损坏）导致无法恢复该文件。1016 由注册表引起的 I/O 操作发生了不可恢复的错误。注册表将不能读取、写出或刷新包含注册表系统映像的其中一个文件。1017 系统试图将文件加载或还原到注册表中，但是，指定的文件不是注册表文件格式。1018 试图在注册表键（已经标记为删除）中完成的操作非法。1019 系统无法在注册表日志文件中分配所需的空间。1020 无法在已经有子键或键值的注册表项中创建符号链接。1021 在易失的父键下不能创建固定的子键。1022 通知的更改请求已经完成，并且返回信息还没有被送到调用者的缓冲区中。调用者需要列举所有文件以找到改动的内容。1051 已将停止控制发送给与其他运行服务相关的服务。1052 所要求的控制对此服务无效。1053 服务没有及时地响应启动或控制请求。1054 无法为该服务创建线程。1055 服务数据库已锁定。1056 该服务的实例已在运行。1057 帐户名无效或者不存在，或者指定帐户名的密码无效。1058 服务无法启动，可能因为被禁用，也可能因为没有关联的可用设备。1059 已经指定了循环服务的从属关系。1060 指定的服务不是所安装的服务。1061 该服务此时无法接收控制消息。1062 服务尚未启动。1063 服务进程无法连接到服务控制程序。1064 处理控制请求时，服务出现意外情况。1065 指定的数据库不存在。1066 服务返回服务特定的错误码。1067 进程意外地终止。 1068 无法启动从属服务或组。1069 由于登录失败，没有启动服务。1070 启动后，服务保持在启动挂起状态。1071 指定的服务数据库锁定无效。1072 指定的服务已经标记为删除。1073 指定的服务已经存在。1074 系统当前正以上一次运行成功的配置运行。1075 从属服务不存在，或已经标记为删除。1076 已接受使用当前引导作为最后的有效控制设置。1077 自从上一次启动以后，没有再次启动过该服务。1078 该名称已经用作服务名或服务显示名。1079 此服务的帐户不同于运行于同一进程上的其它服务的帐户。1080 只能为 Win32 服务设置失败操作，不能为驱动程序设置。1081 这个服务所运行的进程和服务控制管理器相同。所以，如果服务进程意外中止的话，服务控制管理器无法进行任何操作。1082 这个服务没有设置恢复程序。1083 配置成在该可执行程序中运行的这个服务不能执行该服务。1100 已经到达磁带的物理尽头。1101 磁带访问到文件标记。1102 到达磁带或分区首部。1103 磁带访问到文件组的末尾。1104 磁带上没有其他数据。1105 磁带无法分区。1106 访问多重卷分区的新磁带时，当前的区块大小不正确。1107 加载磁带时，找不到磁带分区信息。1108 无法锁定媒体退出功能。1109 无法卸载媒体。1110 驱动器中的媒体已经更改。1111 已经复位 I/O 总线。1112 驱动器中没有媒体。1113 在目标多字节代码页中不存在对单码字符的映射。1114 动态链接库 (DLL) 初始化例程失败。1115 正在关闭系统。1116 无法终止系统关机，因为没有进行中的关机操作。1117 由于 I/O 设备出现错误，无法运行该请求。1118 串行设备初始化失败。将卸载串行驱动程序。1119 无法打开正与其他设备共享中断请求 (IRQ) 的设备。至少有一个使用该 IRQ 的设备已经打开。1120 由于再次写入串行口，串行 I/O 操作已结束。（IOCTL_SERIAL_XOFF_COUNTER 为零。）1121 由于超时，串行 I/O 操作已结束。 (IOCTL_SERIAL_XOFF_COUNTER未达到零。)1122 在软盘上找不到标识符地址标记。1123 软盘扇区标识符字段与软盘控制器磁道地址不匹配。1124 软盘控制器报告软盘驱动程序不能识别的错误。1125 软盘控制器返回的结果和注册的不一致。 1126 访问硬盘时，再校准操作失败，再试一次后也无法操作。1127 访问硬盘时，磁盘操作失败，再试一次后仍没有作用。1128 访问硬盘时，需要重启动磁盘控制器，但仍未成功。1129 磁带已卷到尽头。1130 可用的服务器存储区不足，无法执行该命令。1131 检测到潜在的死锁情况。1132 指定的基址或文件偏移量没有正确对齐。1140 试图更改系统电源状态的操作被另一应用程序或驱动程序禁止。1141 系统 BIOS 无法更改系统电源状态。1142 试图在一文件上创建超过系统允许数额的链接。1150 指定的程序需要新的 Windows 版本。1151 指定的程序不是 Windows 或 MS-DOS 程序。1152 无法启动指定程序的多个实例。1153 指定的程序是为 Windows 的早期版本编写的。1154 运行此应用程序所需的某个库文件已损。1155 没有应用程序与该操作中所指定的文件关联。1156 将命令发送到应用程序时出现错误。1157 找不到运行此应用程序所需的某个库文件。1158 当前进程已使用了 Window 管理器对象的系统允许的所有句柄。1159 消息只能与同步操作一起使用。1160 指出的源元素没有媒体。1161 指出的目标元素已包含媒体。1162 指出的元素不存在。1163 指出的元素是未显示的存储资源的一部分。1164 指出的设备需要重新初始化，因为硬件有错误。1165 设备显示在尝试进一步操作之前需要清除。1166 设备显示它的门仍是打开状态。1167 设备没有连接。1168 找不到元素。1169 索引中没有同指定项相匹配的项。cool 1170 在对象上不存在指定的属性集。1171 传递到 GetMouseMovePoints 的点不在缓冲区中。1172 跟踪(工作站)服务没运行。1173 找不到卷 ID。1175 无法删除要被替换的文件。1176 无法将替换文件移到要被替换的文件。要被替换的文件保持原来的名称。 1177 无法将替换文件移到要被替换的文件。要被替换的文件已被重新命名为备份名称。1178 卷更改记录被删除。1179 卷更改记录服务不处于活动中。1180 找到一份文件，但是可能不是正确的文件。1181 日志项已从日志中删除。1200 指定的设备名无效。 1201 设备当前虽然未连接，但它是记忆连接。1202 试图记起已经记住的设备。1203 网络供应商不接受给定的网络路径。1204 指定的网络供应商名无效。1205 无法打开网络连接配置文件。1206 网络连接配置文件已损坏。1207 无法列举非包容类。1208 出现扩展错误。1209 指定组名的格式无效。1210 指定计算机名的格式无效。1211 指定事件名的格式无效。1212 指定域名的格式无效。1213 指定服务名的格式无效。1214 指定网络名的格式无效。1215 指定共享名的格式无效。1216 指定密码的格式无效。1217 指定的邮件名无效。1218 指定邮件目的地的格式无效。1219 所提供的凭据与现有凭据设置冲突。1220 试图与网络服务器建立会话，但目前与该服务器建立的会话太多。1221 网络上的其他计算机已经使用该工作组或域名。1222 网络不存在或者没有启动。1223 用户已经取消该操作。1224 所要求的操作无法在已经打开用户映射区域的文件中运行。1225 远程系统拒绝网络连接。1226 已经关闭网络连接。1227 网络传输的终点已经有一个地址与其关联。1228 网络终点尚未与地址关联。1229 试图在不存在的网络连接中操作。1230 试图在活动的网络连接上进行无效操作。1231 不能访问网络位置。有关网络疑难解答的信息，请参阅 Windows帮助。1232 不能访问网络位置。有关网络疑难解答的信息，请参阅Windows 帮助。1233 不能访问网络位置。有关网络疑难解答的信息，请参阅 Windows 帮助。1234 远程系统的目标网络端点没有运行任何服务。1235 该请求已经终止。1236 本地系统已经终止网络连接。1237 无法完成操作。请再试一次。1238 无法创建到该服务器的连接，因为已经到达了该帐户同时连接的最大数目。1239 试图在该帐户未授权的时间内登录。1240 尚未授权此帐户从该站登录网络。1241 网络地址无法用于要求的操作。1242 服务已经注册。1243 指定的服务不存在。 1244 由于尚未验证用户身份，无法执行要求的操作。1245 由于用户尚未登录网络，无法运行要求的操作。指定的服务不存在。1246 继续工作。1247 完成初始化操作后，试图再次运行初始化操作。1248 没有其他本地设备。1249 指定的站点不存在。1250 具有指定名称的域控制器已经存在。1251 只有连接到服务器上时，才支持该操作。1252 即使没有改动，组策略框架也应该调用扩展。1253 指定的用户没有一个有效的配置文件。1254 Microsoft Small Business Server 不支持此操作。1300 不是对所有的调用方分配引用特权。1301 帐户名与安全标识符之间的映射未完成。1302 没有为该帐户明确地设置系统配额限制。1303 没有可用的密钥。返回已知的密钥。1304 密码太复杂，无法转换成 LAN Manager 密码。返回的 LANManager 密码是空字符串。1305 修订级别未知。1306 表示两个修订级别不兼容。1307 无法将此安全标识符指定为该对象的拥有者。1308 无法将此安全标识符指定为主要的对象组。1309 当前并未模拟客户的线程试图操作模拟令牌。1310 不可以禁用该组。1311 目前没有可用的登录服务器处理登录请求。1312 指定的登录会话不存在。该会话可能已终止。1313 指定的权限不存在。1314 客户不保留请求的权限。1315 提供的名称不是正确的帐户名称格式。1316 指定的用户已经存在。1317 指定的用户不存在。1318 指定的组已经存在。1319 指定的组不存在。1320 或者指定的用户帐户已经是某个特定组的成员，或者也可能指定的组非空而不能被删除。1321 指定的用户帐户不是所指定组帐户的成员。1322 上次保留的管理帐户无法关闭或删除。1323 无法更新密码。所输入的密码不正确。1324 无法更新密码。所提供的新密码包含不可用于密码的值。1325 无法更新密码。为新密码提供的值不符合字符域的长度、复杂性或历史要求。 1326 登录失败: 用户名未知或密码错误。1327 登录失败: 用户帐户限制。1328 登录失败: 违反帐户登录时间限制。1329 登录失败: 禁止用户登录到该计算机上。1330 登录失败: 指定的帐户密码已过期。1331 登录失败: 当前禁用帐户。1332 未完成帐户名与安全性标识符之间的映射。1333 一次请求的本地用户标识符(LUID)太多。1334 没有其他可用的本地用户标识符(LUID)。1335 对这个特定使用来说，安全标识符的子部分是无效的。1336 访问控制清单(ACL)结构无效。1337 安全标识符结构无效。1338 安全描述符结构无效。1340 无法创建继承的访问控制列表(ACL)或访问控制项目(ACE)。1341 当前已禁用服务器。1342 当前已启用服务器。1343 所提供的值是无效的标识符授权值。1344 没有更多的内存用于更新安全信息。1345 指定的属性无效，或指定的属性与整个组的属性不兼容。1346 或者没有提供所申请的模仿级别，或者提供的模仿级别无效。1347 无法打开匿名级安全性符号。1348 所请求的验证信息类别无效。1349 该类符号不能以所尝试的方式使用。1350 无法在没有相关安全性的对象上运行安全操作。1351 未能从域控制器读取配置信息，或者是因为机器不可使用，或者是访问被拒绝。1352 安全帐户管理程序(SAM)或本地安全颁发机构(LSA)服务器状态不正确，所以无法运行安全操作。1353 域处于执行安全操作的错误状态。1354 该操作只能在域的主域控制器中执行。1355 指定的域不存在或联系不上。1356 指定的域已经存在。1357 试图超过每个服务器域数目的极限。1358 由于严重的媒体错误或磁盘的数据结构损坏，无法完成所请求的操作。1359 发生内部错误。1360 通用的访问类型包含在访问掩码中，该掩码已经映射为非通用类型。1361 安全性描述符的格式错误（绝对或自相关）。1362 请求的操作只准登录进程使用。该调用过程并未被记录为登录进程。1363 无法用已经使用的标识符来启动新的登录会话。1364 指定的确认数据包未知。1365 登录会话的状态与请求的操作不一致。1366 登录会话标识符正在使用中。1367 登录请求包含无效的登录类型值。 1368 在使用命名管道读取数据之前，无法经由该管道模拟。1369 注册表子树的事务状态与所请求的操作不兼容。1370 突发的内部安全性数据库故障。1371 无法在内部帐户下运行该操作。1372 无法在该内部特定组中运行该操作。1373 无法在该内部特定用户中运行该操作。1374 因为该组当前是用户的主要组，所以不能从此组中删除用户。1375 该符号已作为主要符号使用。1376 指定的本地组不存在。1377 指定的帐户名不是本地组的成员。1378 指定的帐户名已经是本地组的成员。1379 指定的本地组已经存在。1380 登录失败: 用户在本计算机上没有被授与所需注册类型。1381 超过了可以存储在单个系统中的最大机密限制。1382 机密的长度超过了最大允许值。1383 本地安全授权数据库包含内部不一致的错误。1384 登录时，用户的安全性上下文累积太多的安全标识符。1385 登录失败: 用户在本计算机上没有被授与所需注册类型。1386 经交叉加密的密码必须更改用户密码。1387 成员不存在，因此无法将其添加到本地组或从中删除。1388 新成员的帐户类型有误，因此无法将其添加到本地组。1389 指定的安全标识符太多。1390 经交叉加密的密码必须更改该用户密码。1391 表示 ACL 没有可继承的组件。1392 文件或目录已损坏，无法读取数据。1393 磁盘结构已损坏，无法读取数据。1394 指定的登录会话没有用户会话密钥。1395 正在访问的服务允许特定数目的连接。因为连接的数目已达到服务可接受的数目，所以此时无法创建新的服务连接。1396 登录失败: 该目标帐户名称不正确。 1397 相互身份验证失败。该服务器在域控制器的密码过期。1398 在客户机和服务器之间有一个时间差。1400 窗口句柄无效。1401 菜单句柄无效。1402 光标句柄无效。1403 加速键表的句柄无效。1404 挂接句柄无效。1405 多重窗口位置结构句柄无效。1406 无法创建最上层的子窗口。1407 找不到窗口类。1408 窗口无效；属于其他线程。1409 已经注册热键。1410 类已经存在。1411 类不存在。1412 类窗口仍打开着。1413 索引无效。1414 图标句柄无效。1415 使用私人对话框窗口字。1416 找不到列表框标识符。1417 找不到任何通配符。1418 线程没有打开剪贴板。1419 尚未注册热键。1420 该窗口不是有效的对话框窗口。1421 找不到控制标识符。 1422 由于没有编辑控制，因此该组合框的消息无效。1423 窗口不是组合框。1424 高度必须小于 256。1425 设备上下文(DC)句柄无效。1426 挂接过程类型无效。1427 挂接过程无效。1428 不能在无模块句柄的情况下设置非本地的挂接。1429 只能全局设置该挂接过程。1430 已安装日记挂接过程。1431 未安装挂接过程。1432 单选列表框的消息无效。1433 LB_SETCOUNT 发送到活动的列表框。1434 该列表框不支持制表符。1435 无法破坏由其他线程所创建的对象。1436 子窗口不能有菜单。 1437 窗口没有系统菜单。1438 消息框样式无效。1439 系统范围内的(SPI_)的参数无效。1440 屏幕已经锁定。1441 多重窗口位置结构中所有窗口句柄必须具有相同的父窗口。1442 窗口不是子窗口。1443 GW_ 命令无效。1444 线程标识符无效。1445 无法处理非多文档接口(MDI)窗口的消息。1446 弹出式菜单已激活。1447 窗口没有滚动条。1448 滚动条范围不能大于 MAXLONG。1449 无法以指定的方式显示或关闭窗口。1450 系统资源不足，无法完成所请求的服务。1451 系统资源不足，无法完成所请求的服务。1452 系统资源不足，无法完成所请求的服务。1453 配额不足，无法完成请求的服务。1454 配额不足，无法完成请求的服务。1455 页面交换文件太小，无法完成此项操作。1456 找不到菜单项。1457 键盘布局句柄无效。1458 不允许使用挂钩类型。1459 该操作需要交互式窗口工作站。1460 由于超时时间已过，该操作返回。1461 无效监视器句柄。1500 事件日志文件已损坏。1501 无法打开事件日志文件，因此无法启动事件记录服务。1502 事件日志文件已满。 1503 事件日志文件在两次读取操作间已发生变化。1601 无法访问 Windows 安装服务。请与技术支持人员联系，确认Windows 安装服务是否注册正确。1602 用户取消了安装。1603 安装时发生严重错误。1604 安装已挂起，未完成。1605 这个操作只对当前安装的产品有效。1606 功能 ID 未注册。1607 组件 ID 未注册。1608 未知属性。1609 句柄处于不正确的状态。1610 这个产品的配置数据已损坏。请与技术支持人员联系。1611 组件限制语不存在。1612 这个产品的安装来源无法使用。请验证来源是否存在，是否可以访问。1613 Windows 安装服务无法安装这个安装程序包。您必须安装含有Windows 安装服务新版本的 Windows Service Park。1614 产品已卸载。1615 SQL 查询语法不正确或不被支持。1616 记录字符域不存在。1617 设备已被删除。1618 正在进行另一个安装操作。请在继续这个安装操作之前完成那个操作。1619 未能打开这个安装程序包。请验证程序包是否存在，是否可以访问；或者与应用程序供应商联系，验证这是否是有效的 Windows 安装程序包。1620 未能打开这个安装程序包。请与应用程序供应商联系，验证这是否是有效的 Windows 安装程序包。1621 启动 Windows 安装服务用户界面时有错误。请与技术支持人员联系。 1622 打开安装日志文件时出错。请验证指定的日志文件位置是否存在，是否可以写入。1623 安装程序包的语言不受系统支持。1624 应用变换时出错。请验证指定的变换路径是否有效。1625 系统策略禁止这个安装。请与系统管理员联系。1626 无法执行函数。1627 执行期间，函数出了问题。1628 指定了无效的或未知的表格。1629 提供的数据类型不对。1630 这个类型的数据不受支持。1631 Windows 安装服务未能启动。请与技术支持人员联系。1632 临时文件夹已满或无法使用。请验证临时文件夹是否存在，是否可以写入。1633 这个处理器类型不支持该安装程序包。请与产品供应商联系。1634 组件没有在这台计算机上使用。1635 无法打开修补程序包。请验证修补程序包是否存在，是否可以访问；或者与应用程序供应商联系，验证这是否是有效的 Windows 安装修补程序包。1636 无法打开修补程序包。请与应用程序供应商联系，验证这是否是有效的 Windows 安装修补程序包。1637 Windows 安装服务无法处理这个修补程序包。您必须安装含有Windows 安装服务新版本的 Windows Service Pack。1638 已安装这个产品的另一个版本。这个版本的安装无法继续。要配置或删除这个产品的现有版本，请用“控制面板”上的“添加/删除程序”。1639 无效的命令行参数。有关详细的命令行帮助，请查阅 Windows 安装服务的 SDK。1640 在终端服务远程会话期间，只有管理员有添加、删除或配置服务器软件的权限。如果您要在服务器上安装或配置软件，请与网络管理员联系。1641 要求的操作已成功结束。要使改动生效，必须重新启动系统。1642 Windows 安装服务无法安装升级修补程序，因为被升级的程序丢失，或者升级修补程序将更新此程序的其他版本。请确认要被升级的程序在您的计算机上且您的升级修补程序是正确的。1700 串绑定无效。cool 1701 绑定句柄的类型错误。1702 绑定句柄无效。1703 不支持 RPC 协议顺序。1704 RPC 协议序列无效。1705 字符串的全球唯一标识符(UUID)无效。1706 终点的格式无效。1707 网络地址无效。1708 未找到终点。1709 超时设置值无效。1710 找不到该对象的全球唯一标识符(UUID)。1711 该对象的全球唯一标识符(UUID)已经注册。1712 这一类型的全球唯一标识符(UUID)已经注册。1713 RPC 服务器正在监听。1714 尚未注册协议顺序。1715 RPC 服务器不处于监听状态。1716 管理程序的类型未知。1717 接口未知。1718 没有绑定。1719 没有协议序列。1720 无法创建终点。1721 资源不足，无法完成该操作。1722 RPC 服务器无法使用。1723 RPC 服务器太忙，无法完成此项操作。1724 网络选项无效。1725 该线程中不存在活动的远程过程调用。1726 远程过程调用失败。1727 远程过程调用失败并且无法执行。1728 远程过程调用(RPC)协议出现错误。1730 RPC 服务器不支持传输语法。1732 不支持这种类型的全球唯一标识符。1733 标识无效。1734 数组边界无效。1735 绑定类型中不包含项目名。1736 名称语法无效。 1737 不支持这种命名语法。1739 没有可用的网络地址，无法创建全球唯一标识符(UUID)。1740 终结点重复。1741 身份验证类型未知。1742 调用次数的上限太小。1743 字符串太长。1744 找不到 RPC 协议序列。1745 过程号超出范围。1746 此次绑定不包含任何身份验证信息。1747 身份验证服务未知。1748 身份验证级别未知。1749 安全描述符无效。1750 身份验证服务未知。1751 项目无效。1752 服务器的终结点无法执行此项操作。1753 终点的映射器没有更多的终点可用。1754 没有导出任何接口。1755 项目名不完整。1756 版本选项无效。1757 没有其他成员。1758 可以导出全部内容。1759 未找到接口。1760 项目已经存在。1761 项目找不到。1762 名称服务不可用。1763 网络地址集无效。1764 不支持请求的操作。1765 没有可供冒仿的安全性描述符。1766 远程过程调用(RPC)出现内部错误。1767 RPC 服务器企图进行整除零运算。1768 RPC 服务器出现寻址错误。1769 RPC 服务器中的浮点运算造成被零除。1770 RPC 服务器产生了浮点下溢错误。1771 RPC 服务器产生了浮点上溢错误。1772 可用于自动句柄绑定的 RPC 服务器列表已经用完。1773 无法打开字符转换表文件。1774 包含字符转换表的文件小于 512 个字节。1775 在远程过程调用中，客户机向主机传送了一个空的描述体句柄。1777 远程过程调用中的描述体句柄发生变化。1778 发送到远程过程调用的绑定句柄不匹配。1779 占位程序无法获得远程过程调用的句柄。1780 将空的参考指针发送给占位程序。1781 列举值超出范围。1782 字节数目太小。1783 占位程序接收到错误数据。1784 所提供的用户缓冲区对所申请的操作无效。1785 无法识别磁盘媒体。它可能还未格式化。1786 工作站没有信任密码。 1787 服务器上的安全数据库中没有该工作站信任关系的计算机帐户。1788 建立主域和受托域间的信任关系失败。1789 建立工作站和主域间的信任关系失败。1790 网络登录失败。1791 该线程执行过程中已经进行了远程过程调用。1792 试图登录网络，但网络登录服务尚未启动。1793 用户帐户已到期。1794 重定向程序正在使用，无法卸载。1795 已经安装所指定的打印机驱动程序。1796 指定的端口未知。1797 打印机驱动程序未知。1798 打印处理程序未知。1799 指定的分隔符文件无效。1800 指定的优先级无效。1801 打印机名无效。1802 打印机已经存在。1803 打印机命令无效。1804 指定的数据类型无效。1805 指定的环境无效。1806 没有其他绑定。1807 使用的帐户是跨网络的信任帐户。请使用全局用户帐户或本地用户帐户来访问此服务器。1808 所使用的帐户是计算机帐户。请使用全局用户帐户或本地用户帐户来访问该服务器。1809 使用的帐户是服务器信任帐户。请使用全局用户帐户或本地用户帐户来访问该服务器。1810 指定的域名或安全标识符与域的信任信息不一致。1811 服务器正在使用中，无法卸载。1812 指定的映像文件不包含资源部分。1813 在映像文件中找不到指定的资源类型。1814 在映像文件中找不到指定的资源名称。1815 在映像文件中找不到指定的资源语言 ID 。1816 可用的配额不足，无法执行该命令。1817 没有已注册的接口。1818 远程过程调用被取消。1819 绑定句柄不包含所有需要的信息。1820 远程调用过程中发生通讯失败。1821 所需的身份验证级别不被支持。1822 主要的名称没有注册。1823 指定的错误不是有效的 Windows RPC 错误代码。1824 已分配仅在本机上有效的 UUID。1825 产生了特定的安全包错误。1826 没有取消线程。 1827 在编码/解码处理时的操作无效。1828 序列化软件包的版本不兼容。1829 RPC 占位程序的版本不兼容。1830 RPC 管道对象无效或已损坏。1831 试图在 RPC 管道对象上进行无效操作。1832 不被支持的 RPC 管道版本。1898 找不到组成员。1899 无法创建终结点映射数据库条目。1900 对象的全球标识符(UUID)为空。1901 指定的时间无效。1902 指定的表单名无效。1903 指定的表单大小无效。1904 指定的打印机句柄正在等候处理1905 指定的打印机已经删除。1906 打印机的状态无效。1907 用户首次登录前，必须先更改其密码。1908 找不到该域的域控制器。1909 引用的帐户目前被锁定，可能无法登录。1910 没有发现指定的此对象导出者。1911 没有发现指定的对象。1912 没有发现指定的对象解析器。1913 一些待发数据仍停留在请求缓冲区内。1914 无效的异步远程过程调用句柄。1915 这个操作的异步 RPC 调用句柄不正确。1916 RPC 管道对象已经关闭。1917 RPC 调用在全部的管道都被处理之前完成。1918 没有其他可用的数据来自 RPC 管道。1919 这个机器没有可用的站点名。1920 系统无法访问此文件。1921 系统无法解析文件名。1922 项目不是所要的类型。1923 无法将所有对象的 UUID 导出到指定的项。1924 无法将接口导出到指定的项。1925 无法添加指定的配置文件项。1926 无法添加指定的配置文件元素。1927 无法删除指定的配置文件元素。1928 无法添加组元素。1929 无法删除组元素。 mysql的出错代码表，根据mysql的头文件 1005：创建表失败1006：创建数据库失败1007：数据库已存在，创建数据库失败1008：数据库不存在，删除数据库失败1009：不能删除数据库文件导致删除数据库失败1010：不能删除数据目录导致删除数据库失败1011：删除数据库文件失败1012：不能读取系统表中的记录1020：记录已被其他用户修改1021：硬盘剩余空间不足，请加大硬盘可用空间1022：关键字重复，更改记录失败1023：关闭时发生错误1024：读文件错误 1025：更改名字时发生错误1026：写文件错误1032：记录不存在1036：数据表是只读的，不能对它进行修改1037：系统内存不足，请重启数据库或重启服务器","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yongchao.tech:8080/tags/mysql/"}]},{"title":"cytoscape绘制一个拓扑图","slug":"cytoscape绘制一个拓扑图","date":"2019-07-18T14:52:39.000Z","updated":"2019-09-16T00:55:42.894Z","comments":true,"path":"2019/07/18/cytoscape绘制一个拓扑图/","link":"","permalink":"http://yongchao.tech:8080/2019/07/18/cytoscape绘制一个拓扑图/","excerpt":"","text":"只记录核心代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import cytoscape from &apos;cytoscape&apos;import edgehandles from &apos;cytoscape-edgehandles&apos;cytoscape.use(edgehandles) let makeSvg = function (node) &#123; let data = node.data() return &#123; image: data.image || &apos;none&apos;, width: 50, height: 50 &#125; &#125; const cy = cytoscape(&#123; container: this.$refs.topology, layout: &#123; name: &apos;breadthfirst&apos;, directed: true &#125;, userZoomingEnabled: false, style: [ &#123; selector: &apos;node&apos;, style: &#123; shape: &apos;ellipse&apos;, // rectangle vee pentagon content: function (ele) &#123; const data = ele.data() if (data.title) &#123; return `$&#123;data.title&#125;-$&#123;data.name&#125;` &#125; else &#123; return `$&#123;data.id&#125;` &#125; &#125;, &apos;text-valign&apos;: &apos;center&apos;, &apos;text-halign&apos;: &apos;right&apos;, &apos;color&apos;: &apos;data(color)&apos;, &apos;background-color&apos;: &apos;data(color)&apos;, &apos;background-image&apos;: function (node) &#123; return makeSvg(node).image &#125;, &apos;background-width&apos;: &apos;60%&apos;, &apos;background-height&apos;: &apos;60%&apos;, &apos;width&apos;: function (node) &#123; return makeSvg(node).width &#125;, &apos;height&apos;: function (node) &#123; return makeSvg(node).height &#125;, &apos;text-rotation&apos;: function (node) &#123; //根据条件旋转文字，避免节点太多文字相互覆盖 let data = node.data() if (data.level === 3 &amp;&amp; level3Len &gt; 10) &#123; return 45 &#125; else &#123; return 0 &#125; &#125; &#125; &#125;, &#123; &apos;selector&apos;: &apos;node:selected&apos;, &apos;style&apos;: &#123; &apos;min-zoomed-font-size&apos;: 0, &apos;z-index&apos;: 9999, &apos;border-color&apos;: &apos;black&apos;, &apos;border-width&apos;: 2, &apos;color&apos;: &apos;black&apos; &#125; &#125;, &#123; selector: &apos;edge&apos;, style: &#123; &apos;curve-style&apos;: &apos;straight&apos;, &apos;target-arrow-shape&apos;: &apos;triangle&apos;, &apos;line-color&apos;: &apos;gray&apos;, &apos;width&apos;: 0.8, &apos;line-style&apos;: &apos;data(lineStyle)&apos; &#125; &#125; ], elements: &#123; nodes: nodes, edges: edges &#125; &#125;) cy.on(&apos;tap&apos;, &apos;node&apos;, function (evt) &#123; let data = evt.target.data() if (data.click) &#123; vm.getIpStat(data.ip) &#125; &#125;)","categories":[{"name":"graph","slug":"graph","permalink":"http://yongchao.tech:8080/categories/graph/"}],"tags":[{"name":"graph","slug":"graph","permalink":"http://yongchao.tech:8080/tags/graph/"},{"name":"cytoscape","slug":"cytoscape","permalink":"http://yongchao.tech:8080/tags/cytoscape/"}]},{"title":"http访问控制","slug":"http访问控制","date":"2019-07-18T14:33:20.000Z","updated":"2019-08-08T06:46:59.933Z","comments":true,"path":"2019/07/18/http访问控制/","link":"","permalink":"http://yongchao.tech:8080/2019/07/18/http访问控制/","excerpt":"http访问控制(cors)概念跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。 出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 ⚠️不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了 简单请求: (满足下面所有条件) 方法：GET、HEAD、POST Content-Typ为下面三个值之一：text/plain 、mutipart/form-data 、application/x-www-data-urlencoded","text":"http访问控制(cors)概念跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。 出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 ⚠️不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了 简单请求: (满足下面所有条件) 方法：GET、HEAD、POST Content-Typ为下面三个值之一：text/plain 、mutipart/form-data 、application/x-www-data-urlencoded 复杂请求【预检请求】（满足下面任一条件） 与前述简单请求不同，“需预检的请求”要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。当请求满足下述任一条件时，即应首先发送预检请求： 使用了下面任一 HTTP 方法： PUT DELETE CONNECT OPTIONS TRACE PATCH 人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为： Accept Accept-Language Content-Language Content-Type (需要注意额外的限制) Content-Type 的值不属于下列之一: application/x-www-form-urlencoded multipart/form-data text/plain 请求中的XMLHttpRequestUpload 对象注册了任意多个事件监听器。 请求中使用了ReadableStream对象。 HTTP响应首部字段：Access-Control-Allow-OriginAccess-Control-Expose-Headers 让服务器把允许浏览器访问的头放入白名单。在跨域访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。 Access-Control-Max-Age 指定了preflight请求的结果能够被缓存多久 Access-Control-Allow-Credentials 指定了当浏览器的credentials设置为true时是否允许浏览器读取response的内容。当用在对preflight预检测请求的响应中时，它指定了实际的请求是否可以使用credentials。请注意：简单 GET 请求不会被预检；如果对此类请求的响应中不包含该字段，这个响应将被忽略掉，并且浏览器也不会将相应内容返回给网页 Access-Control-Allow-Methods 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法 Access-Control-Allow-Headers 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段。 HTTP请求首部字段：Origin 首部字段表明预检请求或实际请求的源站。 它不包含任何路径信息，只是服务器名称。Note: 有时候将该字段的值设置为空字符串是有用的，例如，当源站是一个 data URL 时。 Access-Control-Request-Method 首部字段用于预检请求。其作用是，将实际请求所使用的 HTTP 方法告诉服务器。 Access-Control-Request-Headers 首部字段用于预检请求。其作用是，将实际请求所携带的首部字段告诉服务器。 摘录自https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS 最后来一个小demo吧index1.html12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; port: 9000 index page &lt;!-- &lt;script src=&quot;http://127.0.0.1:9001/&quot;&gt;&lt;/script&gt; --&gt; &lt;script&gt; var xhr = new XMLHttpRequest() xhr.open(&apos;put&apos;, &apos;http://127.0.0.1:9001/&apos;) // xhr.setRequestHeader(&apos;X-Custom-Field&apos;, &apos;custom-field&apos;) xhr.send() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; server1.js123456789101112const http = require(&apos;http&apos;);const fs = require(&apos;fs&apos;)http.createServer(function(req, res) &#123; if(req.url === &apos;/&apos;) &#123; file = fs.readFileSync(&apos;./index1.html&apos;, &apos;utf-8&apos;) res.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/html&apos; &#125;) res.end(file) &#125;&#125;).listen(9000, &apos;127.0.0.1&apos;) server2.js12345678910111213141516171819202122232425262728293031323334353637383940414243const http = require(&apos;http&apos;);// http.createServer(function(req, res) &#123;// if(req.url === &apos;/&apos;) &#123;// console.log(&apos;come in 127.0.0.1:9001 server&apos;)// res.writeHead(200,&#123;// &apos;Content-Type&apos;: &apos;text/plain&apos;// &#125;)// res.end(&apos;9001 index page&apos;)// &#125;// &#125;).listen(9001, &apos;127.0.0.1&apos;)// http.createServer(function(req, res) &#123;// if(req.url === &apos;/&apos;) &#123;// console.log(&apos;come in 127.0.0.1:9001 server&apos;)// res.writeHead(200,&#123;// &apos;Access-Control-Allow-Origin&apos;: &apos;*&apos;, // 告诉浏览器允许访问的origin// &apos;Content-Type&apos;: &apos;text/plain&apos; // &#125;)// res.end(&apos;9001 index page&apos;)// &#125;// &#125;).listen(9001, &apos;127.0.0.1&apos;)http.createServer(function(req, res) &#123; if(req.url === &apos;/&apos;) &#123; console.log(&apos;come in 127.0.0.1:9001 server&apos;) res.writeHead(200,&#123; &apos;Access-Control-Allow-Origin&apos;: &apos;*&apos;, // 告诉浏览器允许访问的origin &apos;Access-Control-Allow-Methods&apos;: &apos;PUT&apos;, &apos;Allow-Control-Request-Method&apos;: &apos;PUT&apos;, // &apos;Access-Control-Allow-Headers&apos;: &apos;X-Custom-Field&apos;, // 用来指定允许的自定义header // &apos;Access-Control-Max-Age&apos;: 0, //指定预请求(prefight)的有效期， 单位为秒 // &apos;Cache-Control&apos;: &apos;no-store&apos;, &apos;Content-Type&apos;: &apos;text/plain&apos; &#125;) res.end(JSON.stringify(&#123; name: &apos;Tom&apos; &#125;)) &#125;&#125;).listen(9001, &apos;127.0.0.1&apos;)","categories":[{"name":"nginx","slug":"nginx","permalink":"http://yongchao.tech:8080/categories/nginx/"}],"tags":[{"name":"cors","slug":"cors","permalink":"http://yongchao.tech:8080/tags/cors/"},{"name":"http","slug":"http","permalink":"http://yongchao.tech:8080/tags/http/"}]},{"title":"code自定义iview语法提示","slug":"code自定义iview语法提示","date":"2019-07-15T23:34:30.000Z","updated":"2019-09-15T15:37:44.067Z","comments":true,"path":"2019/07/16/code自定义iview语法提示/","link":"","permalink":"http://yongchao.tech:8080/2019/07/16/code自定义iview语法提示/","excerpt":"vscode 中支持自定义语法提示，于是我就将一些常见的代码模块记录一下，开发时只要输入少量代码就可以获得整个代码块，提高了开发效率。","text":"vscode 中支持自定义语法提示，于是我就将一些常见的代码模块记录一下，开发时只要输入少量代码就可以获得整个代码块，提高了开发效率。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644&apos;.text.html.vue&apos;: &apos;button&apos;: &apos;prefix&apos;: &apos;btn&apos; &apos;body&apos;:&quot;&quot;&quot; &lt;Button type=&quot;$1&quot;&gt;&lt;/Button&gt; &quot;&quot;&quot; &apos;icon&apos;: &apos;prefix&apos;: &apos;icon&apos; &apos;body&apos;:&quot;&quot;&quot; &lt;Icon type=&quot;$1&quot;/&gt; &quot;&quot;&quot; &apos;row&apos;: &apos;prefix&apos;: &apos;row&apos; &apos;body&apos;:&quot;&quot;&quot; &lt;Row&gt; &lt;Col&gt;&lt;/Col&gt; &lt;/Row&gt; &quot;&quot;&quot; &apos;col&apos;: &apos;prefix&apos;: &apos;col&apos; &apos;body&apos;:&quot;&quot;&quot; &lt;Col&gt;&lt;/Col&gt; &quot;&quot;&quot; &apos;card&apos;: &apos;prefix&apos;: &apos;card&apos; &apos;body&apos;:&quot;&quot;&quot; &lt;Card dis-hover&gt; $1 &lt;/Card&gt; &quot;&quot;&quot; &apos;collapse&apos;: &apos;prefix&apos;: &apos;collapse&apos; &apos;body&apos;:&quot;&quot;&quot; &lt;Collapse&gt; &lt;Panel name=&quot;&quot;&gt; &lt;/Panel&gt; &lt;/Collapse&gt; &quot;&quot;&quot; &apos;Split&apos;: &apos;prefix&apos;: &apos;split&apos; &apos;body&apos;:&quot;&quot;&quot; &lt;Split v-model=&quot;split1&quot;&gt; &lt;div slot=&quot;left&quot;&gt; Left Pane &lt;/div&gt; &lt;div slot=&quot;right&quot;&gt; Right Pane &lt;/div&gt; &lt;/Split&gt; &quot;&quot;&quot; &apos;divider&apos;: &apos;prefix&apos;: &apos;divider&apos; &apos;body&apos;:&quot;&quot;&quot; &lt;Divider /&gt; &quot;&quot;&quot; &apos;cell&apos;: &apos;prefix&apos;: &apos;cell&apos; &apos;body&apos;:&quot;&quot;&quot; &lt;Cell title=&quot;$1&quot;&gt;&lt;/Cell&gt; &quot;&quot;&quot; &apos;CellGroup&apos;: &apos;prefix&apos;: &apos;cellgroup&apos; &apos;body&apos;:&quot;&quot;&quot; &lt;CellGroup&gt; &lt;Cell&gt;&lt;/Cell&gt; &lt;/CellGroup&gt; &quot;&quot;&quot; &apos;Tabs&apos;: &apos;prefix&apos;: &apos;tabs&apos; &apos;body&apos;:&quot;&quot;&quot; &lt;Tabs&gt; &lt;Tabpane label=&quot;&quot;&gt;&lt;/Tabpane&gt; &lt;/Tabs&gt; &quot;&quot;&quot; &apos;Dropdown&apos;: &apos;prefix&apos;: &apos;dropdown&apos; &apos;body&apos;:&quot;&quot;&quot; &lt;Dropdown&gt; &lt;Button type=&quot;primary&quot;&gt; 下拉菜单 &lt;/Button&gt; &lt;DropdownMenu slot=&quot;list&quot;&gt; &lt;DropdownItem&gt;&lt;/DropdownItem&gt; &lt;/DropdownMenu&gt; &lt;/Dropdown&gt; &quot;&quot;&quot; &apos;Steps&apos;: &apos;prefix&apos;: &apos;steps&apos; &apos;body&apos;:&quot;&quot;&quot; &lt;Steps :current=&quot;1&quot;&gt; &lt;Step title=&quot;$1&quot; content=&quot;$2&quot;&gt;&lt;/Step&gt; &lt;/Steps&gt; &quot;&quot;&quot; &apos;Input --&gt;vue&apos;: &apos;prefix&apos;: &apos;input&apos; &apos;body&apos;:&quot;&quot;&quot; &lt;Input v-model.trim=&quot;$1&quot;/&gt; &quot;&quot;&quot; &quot;form --&gt;vue&quot;: &quot;prefix&quot;: &quot;form&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;Form ref=&quot;Form&quot; :model=&quot;Form&quot; :rules=&quot;FormRules&quot; label-position=&quot;right&quot;&gt; &lt;Form-item label=&quot;&quot; prop=&quot;&quot;&gt; &lt;/Form-item&gt; &lt;Form-item&gt; &lt;div style=&quot;text-align:center&quot;&gt; &lt;Button type=&quot;primary&quot; @click=&quot;&quot;&gt;提交&lt;/Button&gt; &lt;Button type=&quot;warning&quot; @click=&quot;&quot;&gt;重置&lt;/Button&gt; &lt;/div&gt; &lt;/Form-item&gt; &lt;/Form&gt; &quot;&quot;&quot; &quot;form validate--&gt;vue&quot;: &quot;prefix&quot;: &quot;validate&quot; &quot;body&quot;: &quot;&quot;&quot; this.$refs[&apos;$1&apos;].validate((valid) =&gt; &#123; if (valid) &#123; this.$Message.error(&apos;表单验证成功!&apos;) &#125; else &#123; this.$Message.error(&apos;表单验证失败!&apos;) &#125; &#125;) &quot;&quot;&quot; &quot;form reset--&gt;vue&quot;: &quot;prefix&quot;: &quot;reset&quot; &quot;body&quot;: &quot;&quot;&quot; this.$refs[&apos;$1&apos;].resetFields() &quot;&quot;&quot; &quot;formitem --&gt;vue&quot;: &quot;prefix&quot;: &quot;formitem&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;Form-item label=&quot;$1&quot; prop=&quot;$2&quot;&gt; &lt;/Form-item&gt; &quot;&quot;&quot; &quot;formitem-input --&gt;vue&quot;: &quot;prefix&quot;: &quot;formitem.input&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;Form-item label=&quot;$1&quot; prop=&quot;$2&quot;&gt; &lt;Input v-model=&quot;$3&quot;&gt;&lt;/Input&gt; &lt;/Form-item&gt; &quot;&quot;&quot; &quot;formitem-select --&gt;vue&quot;: &quot;prefix&quot;: &quot;formitem.select&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;Form-item label=&quot;$1&quot; prop=&quot;$2&quot;&gt; select &lt;/Form-item&gt; &quot;&quot;&quot; &quot;formitem-switch --&gt;vue&quot;: &quot;prefix&quot;: &quot;formitem.switch&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;Form-item label=&quot;$1&quot; prop=&quot;$2&quot;&gt; switch &lt;/Form-item&gt; &quot;&quot;&quot; &quot;formitem-radiogroup --&gt;vue&quot;: &quot;prefix&quot;: &quot;formitem.radiogroup&quot; &quot;body&quot;: &quot;&quot;&quot; radiogroup &quot;&quot;&quot; &quot;formitem-checkgroup --&gt;vue&quot;: &quot;prefix&quot;: &quot;formitem.checkgroup&quot; &quot;body&quot;: &quot;&quot;&quot; checkgroup &quot;&quot;&quot; &quot;radio --&gt;vue&quot;: &quot;prefix&quot;: &quot;radio&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;Radio label=&quot;$1&quot;&gt;否&lt;/Radio&gt; &quot;&quot;&quot; &quot;radiogroup --&gt;vue&quot;: &quot;prefix&quot;: &quot;radiogroup&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;RadioGroup v-model=&quot;a&quot;&gt; &lt;Radio label=&quot;&quot;&gt;是&lt;/Radio&gt; &lt;Radio label=&quot;&quot;&gt;否&lt;/Radio&gt; &lt;/RadioGroup&gt; &quot;&quot;&quot; &quot;checkbox --&gt;vue&quot;: &quot;prefix&quot;: &quot;checkbox&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;Checkbox label=&quot;$1&quot;&gt;&lt;/Checkbox&gt; &quot;&quot;&quot; &quot;checkboxgroup --&gt;vue&quot;: &quot;prefix&quot;: &quot;checkboxgroup&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;CheckboxGroup v-model=&quot;$1&quot;&gt; &lt;Checkbox label=&quot;$2&quot;&gt; &lt;/Checkbox&gt; &lt;/CheckboxGroup&gt; &quot;&quot;&quot; &quot;switch --&gt;vue&quot;: &quot;prefix&quot;: &quot;switch&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;i-switch v-model=&quot;&quot; :true-value=&quot;&quot; :false-value=&quot;&quot;&gt; &lt;span slot=&quot;open&quot;&gt;开&lt;/span&gt; &lt;span slot=&quot;close&quot;&gt;关&lt;/span&gt; &lt;/i-switch&gt; &quot;&quot;&quot; &quot;select --&gt;vue&quot;: &quot;prefix&quot;: &quot;select&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;Select v-model=&quot;$1&quot;&gt; &lt;Option v-for=&quot;(item, index) in List&quot; :value=&quot;$2&quot; :key=&quot;index&quot;&gt;&#123;&#123;$3&#125;&#125;&lt;/Option&gt; &lt;/Select&gt; &quot;&quot;&quot; &quot;datepicker --&gt;vue&quot;: &quot;prefix&quot;: &quot;datepicker&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;DatePicker type=&quot;date&quot;&gt;&lt;/DatePicker&gt; &quot;&quot;&quot; &quot;inputnumber --&gt;vue&quot;: &quot;prefix&quot;: &quot;inputnumber&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;InputNumber v-model=&quot;$1&quot;&gt;&lt;/InputNumber&gt; &quot;&quot;&quot; &quot;rate --&gt;vue&quot;: &quot;prefix&quot;: &quot;rate&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;Rate v-model=&quot;$1&quot;&gt;&lt;/Rate&gt; &quot;&quot;&quot; &quot;alert --&gt;vue&quot;: &quot;prefix&quot;: &quot;alert&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;Alert type=&quot;&quot;&gt;&lt;/Alert&gt; &quot;&quot;&quot; &quot;alert.success --&gt;vue&quot;: &quot;prefix&quot;: &quot;alert&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;Alert type=&quot;success&quot;&gt;&lt;/Alert&gt; &quot;&quot;&quot; &quot;alert.warning --&gt;vue&quot;: &quot;prefix&quot;: &quot;alert.warning&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;Alert type=&quot;warning&quot;&gt;&lt;/Alert&gt; &quot;&quot;&quot; &quot;alert.error --&gt;vue&quot;: &quot;prefix&quot;: &quot;alert.error&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;Alert type=&quot;error&quot;&gt;&lt;/Alert&gt; &quot;&quot;&quot; &quot;message --&gt;vue&quot;: &quot;prefix&quot;: &quot;icon&quot; &quot;body&quot;: &quot;&quot;&quot; this.$Message.info(&apos;表单验证失败&apos;) &quot;&quot;&quot; &quot;message.success --&gt;vue&quot;: &quot;prefix&quot;: &quot;message.success&quot; &quot;body&quot;: &quot;&quot;&quot; this.$Message.success(&apos;表单验证成功！&apos;) &quot;&quot;&quot; &quot;message.warning --&gt;vue&quot;: &quot;prefix&quot;: &quot;message.warning&quot; &quot;body&quot;: &quot;&quot;&quot; this.$Message.warning(content: &apos;表单验证失败！&apos;) &quot;&quot;&quot; &quot;message.error --&gt;vue&quot;: &quot;prefix&quot;: &quot;message.error&quot; &quot;body&quot;: &quot;&quot;&quot; this.$Message.error(&apos;表单验证失败！&apos;) &quot;&quot;&quot; &quot;message.loading --&gt;vue&quot;: &quot;prefix&quot;: &quot;message.loading&quot; &quot;body&quot;: &quot;&quot;&quot; this.$Message.loading(&apos;表单验证失败！&apos;) &quot;&quot;&quot; &quot;notice --&gt;vue&quot;: &quot;prefix&quot;: &quot;notice&quot; &quot;body&quot;: &quot;&quot;&quot; this.$Notice.open(&#123; title: &apos;&apos;, desc: &apos;&apos; &#125;) &quot;&quot;&quot; &quot;notice.info --&gt;vue&quot;: &quot;prefix&quot;: &quot;notice.info&quot; &quot;body&quot;: &quot;&quot;&quot; this.$Notice.info(&#123; title: &apos;&apos;, desc: &apos;&apos; &#125;) &quot;&quot;&quot; &quot;notice.success --&gt;vue&quot;: &quot;prefix&quot;: &quot;notice.succes&quot; &quot;body&quot;: &quot;&quot;&quot; this.$Notice.succes(&#123; title: &apos;&apos;, desc: &apos;&apos; &#125;) &quot;&quot;&quot; &quot;notice.warning --&gt;vue&quot;: &quot;prefix&quot;: &quot;notice.warning&quot; &quot;body&quot;: &quot;&quot;&quot; this.$Notice.warning(&#123; title: &apos;&apos;, desc: &apos;&apos; &#125;) &quot;&quot;&quot; &quot;notice.error --&gt;vue&quot;: &quot;prefix&quot;: &quot;notice.error&quot; &quot;body&quot;: &quot;&quot;&quot; this.$Notice.error(&#123; title: &apos;&apos;, desc: &apos;&apos; &#125;) &quot;&quot;&quot; &quot;Modal --&gt;vue&quot;: &quot;prefix&quot;: &quot;modal&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;Modal v-model=&quot;$1ModalVis&quot; title=&quot;&quot; :mask-closable=&quot;false&quot; @on-cancel=&quot;&quot;&gt; &lt;/Modal&gt; &quot;&quot;&quot; &quot;Modal.info --&gt;vue&quot;: &quot;prefix&quot;: &quot;modal.info&quot; &quot;body&quot;: &quot;&quot;&quot; this.$Modal.info(&#123; title: &apos;&apos;, content: &apos;&apos;, onOk () &#123; &#125; &#125;) &quot;&quot;&quot; &quot;Modal.success --&gt;vue&quot;: &quot;prefix&quot;: &quot;modal.success&quot; &quot;body&quot;: &quot;&quot;&quot; this.$Modal.success(&#123; title: &apos;&apos;, content: &apos;&apos;, onOk () &#123; &#125; &#125;) &quot;&quot;&quot; &quot;Modal.warning --&gt;vue&quot;: &quot;prefix&quot;: &quot;modal.warning&quot; &quot;body&quot;: &quot;&quot;&quot; this.$Modal.warning(&#123; title: &apos;&apos;, content: &apos;&apos;, onOk () &#123; &#125; &#125;) &quot;&quot;&quot; &quot;Modal.error --&gt;vue&quot;: &quot;prefix&quot;: &quot;modal.error&quot; &quot;body&quot;: &quot;&quot;&quot; this.$Modal.error(&#123; title: &apos;&apos;, content: &apos;&apos;, onOk () &#123; &#125; &#125;) &quot;&quot;&quot; &quot;Modal.confirm --&gt;vue&quot;: &quot;prefix&quot;: &quot;modal.confirm&quot; &quot;body&quot;: &quot;&quot;&quot; this.$Modal.confirm(&#123; title: &apos;&apos;, content: &apos;&apos;, onOk () &#123; &#125; &#125;) &quot;&quot;&quot; &quot;timeline --&gt;vue&quot;: &quot;prefix&quot;: &quot;timeline&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;Timeline&gt; &lt;TimelineItem color=&quot;&quot;&gt;&lt;/TimelineItem&gt; &lt;/Timeline&gt; &quot;&quot;&quot; &quot;timelineitem --&gt;vue&quot;: &quot;prefix&quot;: &quot;timelineitem&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;TimelineItem color=&quot;&quot;&gt;&lt;/TimelineItem&gt; &quot;&quot;&quot; &quot;tag --&gt;vue&quot;: &quot;prefix&quot;: &quot;tag&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;Tag&gt;$1&lt;/Tag&gt; &quot;&quot;&quot; &quot;tag.for type=&apos;border,dot&apos; --&gt;vue&quot;: &quot;prefix&quot;: &quot;tag.for&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;Tag v-for=&quot;(item, index) in $1&quot; :key=&quot;index&quot;&gt;&#123;&#123;item.$2&#125;&#125;&lt;/Tag&gt; &quot;&quot;&quot; &quot;tooptip --&gt;vue&quot;: &quot;prefix&quot;: &quot;tooptip&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;Tooltip content=&quot;&quot;&gt; &lt;/Tooltip&gt; &quot;&quot;&quot; &quot;poptip --&gt;vue&quot;: &quot;prefix&quot;: &quot;poptip&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;Poptip trigger=&quot;hover&quot; title=&quot;$1&quot; content=&quot;$2&quot;&gt; $3 &lt;/Poptip&gt; &quot;&quot;&quot; &quot;carousel --&gt;vue&quot;: &quot;prefix&quot;: &quot;carousel&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;Carousel v-model=&quot;$1&quot; loop&gt; &lt;CarouselItem&gt;&lt;/CarouselItem&gt; &lt;/Carousel&gt; &quot;&quot;&quot; &quot;carouselitem --&gt;vue&quot;: &quot;prefix&quot;: &quot;carouselitem&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;CarouselItem&gt;&lt;/CarouselItem&gt; &quot;&quot;&quot; &quot;menu --&gt;vue&quot;: &quot;prefix&quot;: &quot;menu&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;Menu theme=&quot;dark&quot;&gt; &lt;Submenu name=&quot;&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;/template&gt; &lt;MenuItem name=&quot;&quot;&gt;&lt;/MenuItem&gt; &lt;/Submenu&gt; &lt;/Menu&gt; &quot;&quot;&quot; &quot;menuitem --&gt;vue&quot;: &quot;prefix&quot;: &quot;menuitem&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;MenuItem name=&quot;&quot;&gt;&lt;/MenuItem&gt;s &quot;&quot;&quot; &quot;drop --&gt;vue&quot;: &quot;prefix&quot;: &quot;drop&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;Dropdown @on-click=&quot;&quot;&gt; &lt;DropdownMenu slot=&quot;list&quot;&gt; &lt;DropdownItem&gt;&lt;/DropdownItem&gt; &lt;/DropdownMenu&gt; &lt;/Dropdown&gt; &quot;&quot;&quot; &quot;breadcrumb --&gt;vue&quot;: &quot;prefix&quot;: &quot;breadcrumb&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;Breadcrumb&gt; &lt;BreadcrumbItem v-for=&quot;(item, index) in $1&quot; :key=&quot;index&quot; to=&quot;$2&quot;&gt;$3&lt;/BreadcrumbItem&gt; &lt;/Breadcrumb&gt; &quot;&quot;&quot; &quot;circle --&gt;vue&quot;: &quot;prefix&quot;: &quot;circle&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;Circle :percent=&quot;&quot;&gt; &lt;/Circle&gt; &quot;&quot;&quot; &quot;backtop --&gt;vue&quot;: &quot;prefix&quot;: &quot;backtop&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;BackTop&gt;&lt;/BackTop&gt; &quot;&quot;&quot; &quot;spin --&gt;vue&quot;: &quot;prefix&quot;: &quot;spin&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;Spin&gt;&lt;/Spin&gt; &quot;&quot;&quot; &quot;vue --&gt;vue&quot;: &quot;prefix&quot;: &quot;vue&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;template&gt; &lt;div name=&quot;$1&quot;&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; let vm = null export default &#123; components: &#123; &#125;, data () &#123; return &#123; &#125; &#125;, computed: &#123; &#125;, methods: &#123; &#125;, created () &#123; vm = this console.log(vm) &#125; &#125; &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; &quot;&quot;&quot; &quot;api --&gt;vue&quot;: &quot;prefix&quot;: &quot;api&quot; &quot;body&quot;: &quot;&quot;&quot; api.$1($2).then(res =&gt; &#123; console.log(res) &#125;).catch(err =&gt; &#123; console.log(&apos;err&apos;, err) &#125;) &quot;&quot;&quot; &quot;columns --&gt;vue&quot;: &quot;prefix&quot;: &quot;columns&quot; &quot;body&quot;: &quot;&quot;&quot; let $1Col = [ &#123; title: &apos;&apos;, key: &apos;&apos; &#125;, &#123; title: &apos;&apos;, key: &apos;&apos; &#125;, &#123; title: &apos;&apos;, key: &apos;&apos; &#125; ] &quot;&quot;&quot; &quot;column --&gt;vue&quot;: &quot;prefix&quot;: &quot;column&quot; &quot;body&quot;: &quot;&quot;&quot; &#123; title: &apos;&apos;, key: &apos;&apos; &#125; &quot;&quot;&quot; &quot;column.selection --&gt;vue&quot;: &quot;prefix&quot;: &quot;column.selection&quot; &quot;body&quot;: &quot;&quot;&quot; &#123; type: &apos;selection&apos;, width: 60, align: &apos;center&apos; &#125; &quot;&quot;&quot; &quot;column.index --&gt;vue&quot;: &quot;prefix&quot;: &quot;column.index&quot; &quot;body&quot;: &quot;&quot;&quot; &#123; type: &apos;index&apos;, width: 60, align: &apos;center&apos; &#125; &quot;&quot;&quot; &quot;render --&gt;vue&quot;: &quot;prefix&quot;: &quot;render&quot; &quot;body&quot;: &quot;&quot;&quot; render: (h, params) =&gt; &#123; return h() &#125; &quot;&quot;&quot; &quot;render.button --&gt;vue&quot;: &quot;prefix&quot;: &quot;render&quot; &quot;body&quot;: &quot;&quot;&quot; render: (h, params) =&gt; &#123; return h(&apos;Button&apos;, &#123; props: &#123; type: &apos;primary&apos;, size: &apos;small&apos; &#125;, on: &#123; click () &#123; &#125; &#125; &#125;, &apos;查看&apos;) &#125; &quot;&quot;&quot; &quot;rules --&gt;vue&quot;: &quot;prefix&quot;: &quot;rules&quot; &quot;body&quot;: &quot;&quot;&quot; let $1FormRules = &#123; $2: &#123; required: true, message: &apos;$3不能为空&apos;, trigger: &apos;blur&apos; &#125;, $4: &#123; required: true, message: &apos;$5不能为空&apos;, trigger: &apos;blur&apos; &#125;, $6: &#123; required: true, message: &apos;$7不能为空&apos;, trigger: &apos;blur&apos; &#125; &#125; &quot;&quot;&quot; &quot;rule --&gt;vue&quot;: &quot;prefix&quot;: &quot;rule&quot; &quot;body&quot;: &quot;&quot;&quot; $1: [ &#123;required: true, message: &apos;$2不能为空&apos;, trigger: &apos;blur&apos;&#125; ] &quot;&quot;&quot; &quot;import --&gt;vue&quot;: &quot;prefix&quot;: &quot;import&quot; &quot;body&quot;: &quot;&quot;&quot; import $1 from &apos;@/&apos; &quot;&quot;&quot; &quot;func --&gt;vue&quot;: &quot;prefix&quot;: &quot;func&quot; &quot;body&quot;: &quot;&quot;&quot; function (item) &#123; $1 &#125; &quot;&quot;&quot; &quot;dispatch --&gt;vue&quot;: &quot;prefix&quot;: &quot;dispatch&quot; &quot;body&quot;: &quot;&quot;&quot; this.$store.dispatch(&apos;$1&apos;) &quot;&quot;&quot; &quot;router --&gt;vue&quot;: &quot;prefix&quot;: &quot;router&quot; &quot;body&quot;: &quot;&quot;&quot; this.$router.push(&#123; name: &apos;$1&apos; &#125;) &quot;&quot;&quot; &quot;routerview --&gt;vue&quot;: &quot;prefix&quot;: &quot;routerview&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;router-view&gt;&lt;/router-view&gt; &quot;&quot;&quot; &quot;colorpicker --&gt;vue&quot;: &quot;prefix&quot;: &quot;colorpicker&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;ColorPicker v-model=&quot;$1&quot; /&gt; &quot;&quot;&quot; &quot;ntable (slot=&apos;batch,ouput&apos;)--&gt;vue&quot;: &quot;prefix&quot;: &quot;ntable&quot; &quot;body&quot;: &quot;&quot;&quot; &lt;NTable :nColumns=&quot;$1&quot; :nData=&quot;$2&quot;&gt;&lt;/NTable&gt; &quot;&quot;&quot; &quot;buttonGroup&quot;: &quot;prefix&quot;: &quot;buttongroup&quot;, &quot;body&quot;: &quot;&quot;&quot; &lt;ButtonGroup&gt; &lt;Button type=&quot;primary&quot;&gt;L&lt;/Button&gt; &lt;Button type=&quot;dashed&quot;&gt;R&lt;/Button&gt; &lt;/ButtonGroup&gt; &quot;&quot;&quot; &quot;nextTick&quot;: &quot;prefix&quot;: &quot;nextTick&quot;, &quot;body&quot;: &quot;&quot;&quot; this.$nextTick(() =&gt; &#123; &#125;) &quot;&quot;&quot;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"},{"name":"vscode","slug":"vscode","permalink":"http://yongchao.tech:8080/tags/vscode/"}]},{"title":"amd/cmd/commonjs和es6的简单对比","slug":"amd-cmd-commonjs和es6的简单对比","date":"2019-07-08T23:11:12.000Z","updated":"2019-08-08T06:46:59.931Z","comments":true,"path":"2019/07/09/amd-cmd-commonjs和es6的简单对比/","link":"","permalink":"http://yongchao.tech:8080/2019/07/09/amd-cmd-commonjs和es6的简单对比/","excerpt":"","text":"AMDAMD是RequireJS在推广过程中的对模块定义的规范化产出。异步加载模块，依赖前置12345678define(&quot;package/lib&quot;, function(lib)&#123; function () foo&#123; lib.log(&quot;hello world) &#125; return &#123; foo: foo &#125;&#125;) CMDCMD是SeaJS在推广过程中对模块定义的规范化产出。 异步加载， 依赖就近12345define(function(require, exports, module)&#123;&#125;)//通过require引入依赖var $ = require(&quot;jquery&quot;);var Spinning = require(&quot;./Spinning&quot;) CommonJSCommonJS规范 - module.exports 适用于服务端123exports.area = function() &#123; return Math.PI * r * r&#125; ES6 - import/export12345678910import $ from &apos;jquery&apos;export default&#123; data () &#123; return &#123; &#125; &#125;, methods:&#123; &#125;&#125;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"}]},{"title":"js中函数的参数传递误区","slug":"js中函数的参数传递误区","date":"2019-06-18T10:52:41.000Z","updated":"2019-08-08T06:46:59.934Z","comments":true,"path":"2019/06/18/js中函数的参数传递误区/","link":"","permalink":"http://yongchao.tech:8080/2019/06/18/js中函数的参数传递误区/","excerpt":"","text":"误区一直以来都以为在函数参数传递的过程中遵循： 普通类型使用值传递，对象使用引用传递。很多文章也这么说，现在发现大错特错了。下面举个例子来说吧 demo12345678910111213&lt;!-- 在函数中对参数进行了重新赋值 --&gt;function setName(obj) &#123; obj.name = &quot;Nicholas&quot;; obj = new Object(); obj.name = &quot;Greg&quot;;&#125;// 定义一个全局变量var person = new Object();setName(person);// 如果对象是引用传递的话，name应该是&quot;Greg&quot;的，事实上结果是Nicholasconsole.log(person.name); 解析在js的参数传递中，有且只有值传递一种。但是变量的访问却有按值访问和按引用访问。在传递对象参数的过程中，实际上是将对象地址的一个拷贝传过去了，就是一个string类型的值。如果是修改对象的属性的话，使用按引用访问的方式，找到堆中的对象进行修改。但是当对参数重新赋值的时候，只不过是改变了obj的存储的string类型的地址值，不存在访问的操作，也就对原始的对象无影响了,obj指向了一个全新的对象，和原来的对象断了联系。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"}]},{"title":"js中对象的delete","slug":"js中对象的delete","date":"2019-06-18T10:23:34.000Z","updated":"2019-08-08T06:46:59.934Z","comments":true,"path":"2019/06/18/js中对象的delete/","link":"","permalink":"http://yongchao.tech:8080/2019/06/18/js中对象的delete/","excerpt":"","text":"delete操作有以下几个特点: 删除自有属性，不影响原型上的，如果自己没有这个属性，仍然返回true 属性描述符configable: false的属性是不能被删除的， 返回false 删除是将key-value都删除了 demo123456789101112131415161718function Person()&#123;&#125;Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function()&#123; console.log(this.name)&#125;var person1 = new Person();console.log(person1)console.log(&apos;person1是否自己存在属性name: &apos;, person1.hasOwnProperty(&quot;name&quot;)); //falseperson1.name = &quot;Greg&quot;;console.log(&apos;person1的name进行重新赋值以后的person1（对象的属性赋值）&apos;, person1)delete person1.name;console.log(&apos;删除person1的name属性&apos;,person1)console.log(&apos;获取person1的name属性（prototype上的）&apos;, person1.name) result12345Person &#123;&#125;person1是否自己存在属性name: falseperson1的name进行重新赋值以后的person1（对象的属性赋值） Person &#123; name: &apos;Greg&apos; &#125;删除person1的name属性 Person &#123;&#125;获取person1的name属性（prototype上的） Nicholas","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"}]},{"title":"macrotask和microtask以及eventloop的介绍","slug":"macrotask和microtask以及eventloop的介绍","date":"2019-06-17T14:44:56.000Z","updated":"2019-08-08T06:46:59.935Z","comments":true,"path":"2019/06/17/macrotask和microtask以及eventloop的介绍/","link":"","permalink":"http://yongchao.tech:8080/2019/06/17/macrotask和microtask以及eventloop的介绍/","excerpt":"","text":"前言提起js,有这么几个概念非了解不可。单线程 、回调函数、非阻塞、执行上下文、调用栈、上下文、事件循环、任务队列。 单线程one thread = one call stack == one thing at a time解释来讲就是单线程意味着只有一个调用栈，在同一时刻只能做一件事儿 执行上下文执行上下文就是当前JavaScript代码被解析和执行是所在环境的抽象概念，JavaScript中运行任何的代码都是在执行上下文中运行。 执行上下文的类型，总共有三类 1.全局执行上下文：这是默认的，最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。共有两个过程： - .创建有全局对象，在浏览器中这个全局对象就是window对象。 - .将this指针指向这个全局对象。一个程序中只能存在一个执行上下文。 2.函数执行上下文：每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在多个函数执行上下文，这些函数执行上下文按照特定的顺序执行一系列步骤，后文具体讨论。 3.Eval函数执行上下文：运行在eval函数中的代码也获得了自己的执行上下文，但由于Eval较为少用到，也不建议使用，就不去详细讨论了。。。（eval方法是在运行时对脚本进行解释执行，而普通的javascript会有一个预处理的过程。所以会有一些性能上的损失；eval也存在一个安全问题，因为它可以执行传给它的任何字符串，所以永远不要传入字符串或者来历不明和不受信任源的参数。 （执行栈）调用栈执行栈，也叫调用栈，具有LIFO（Last in, First out 后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。当JavaScript引擎首次读取脚本时，会创建一个全局执行上下文并将其Push到当前执行栈中。每当发生函数调用时，引擎都会为该函数创建一个新的执行上下文并Push到当前执行栈的栈顶。引擎会运行执行上下文在执行栈栈顶的函数，根据LIFO规则，当此函数运行完成后，其对应的执行上下文将会从执行栈中Pop出，上下文控制权将转到当前执行栈的下一个执行上下文。 任务队列、macrotask、mircotask同步任务和异步任务因 js是单线程语言 ， 存在大量的IO等耗时操作，所以有“同步任务”和“异步任务”的区分同步任务 在主线程上排队执行的任务，前一个任务执行完毕，才能执行后一个任务；异步任务不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。总之只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制,这个过程是循环往复的，所以也叫做Event Loop事件循环 macrotask、mircotask队列microtasks: process.nextTick promise Object.observe MutationObserver macrotasks: setTimeout setInterval setImmediate I/O UI渲染 一个事件循环有一个或多个任务队列，一个任务队列是任务的集合whatwg规范：https://html.spec.whatwg.org/multipage/webappapis.html#task-queue task queue 就是 macrotask queue 每一个 event loop 都有一个 microtask queue task queue == macrotask queue != microtask queue 一个任务 task 可以放入 macrotask queue 也可以放入 microtask queue 中 理解了这些定义之后，再看执行原理： 事件循环的顺序，决定了JavaScript代码的执行顺序。它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的micro-task。当所有可执行的micro-task执行完毕之后。循环再次从macro-task开始，找到其中一个任务队列执行完毕，然后再执行所有的micro-task，这样一直循环下去。更为形象的显示代码的执行过程，请看https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/ 还要注意一点： 包裹在一个 script 标签中的js代码也是一个 task 确切说是 macrotask。 事件循环执行栈中执行完之后会从任务队列中读取一个task进行执行，这个过程是循环的，称之为 “事件循环” 非阻塞遇到异步操作，主线程会继续处理后面的代码，当异步操作完成以后在任务队列（task）中添加事件 作者：BenjaminShih来源：CSDN原文：https://blog.csdn.net/sjn0503/article/details/76087631版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"}]},{"title":"缓存memorize","slug":"缓存memorize","date":"2019-06-11T16:41:04.000Z","updated":"2019-08-08T06:46:59.941Z","comments":true,"path":"2019/06/12/缓存memorize/","link":"","permalink":"http://yongchao.tech:8080/2019/06/12/缓存memorize/","excerpt":"","text":"code123456789101112function memoize(func, hashFunc) &#123; var memoize = function(key) &#123; var cache = memoize.cache var address = &apos;&apos; + (hashFunc ? hashFunc.apply(this, arguments) : key) if(Object.getOwnPropertyNames(cache).indexOf(address) === -1) &#123; cache[address] = func.apply(this, arguments) &#125; return cache[address] &#125; memoize.cache = &#123;&#125; return memoize&#125; test123456789let fibonacci = memoize(function(n)&#123; return n &lt; 2 ? n: fibonacci(n - 1) + fibonacci(n - 2);&#125;)console.log(fibonacci(1))console.log(fibonacci(2))console.log(fibonacci(3))console.log(fibonacci(4))console.log(fibonacci(10))console.log(fibonacci(100))","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"}]},{"title":"节流和防抖","slug":"节流和防抖","date":"2019-06-11T15:10:55.000Z","updated":"2019-08-08T06:46:59.942Z","comments":true,"path":"2019/06/11/节流和防抖/","link":"","permalink":"http://yongchao.tech:8080/2019/06/11/节流和防抖/","excerpt":"前言很多常见中由于事件频繁的被触发，造成频繁的执行Dom操作，资源加载等行为，导致UI卡顿甚至崩溃。 window 的resize和scroll事件 mousedown keydown mousemove keydup事件实际上对于window的resize事件，实际需求大多为停止改变大小n毫秒后执行后续处理；而其他事件大多的需求是以一定的频率执行后续处理。针对这两种需求就出现了debounce和throttle两种解决办法。 throttle介绍每间隔一定的时间执行一次函数，在此期间内得多次函数调用忽略不处理 demo1234567891011function throttle(fn, wait)&#123; let pervious = 0 return function (...args) &#123; let now = Date.now() if(now - pervious &gt; wait) &#123; pervious = now fn.apply(this, args) &#125; &#125;&#125;","text":"前言很多常见中由于事件频繁的被触发，造成频繁的执行Dom操作，资源加载等行为，导致UI卡顿甚至崩溃。 window 的resize和scroll事件 mousedown keydown mousemove keydup事件实际上对于window的resize事件，实际需求大多为停止改变大小n毫秒后执行后续处理；而其他事件大多的需求是以一定的频率执行后续处理。针对这两种需求就出现了debounce和throttle两种解决办法。 throttle介绍每间隔一定的时间执行一次函数，在此期间内得多次函数调用忽略不处理 demo1234567891011function throttle(fn, wait)&#123; let pervious = 0 return function (...args) &#123; let now = Date.now() if(now - pervious &gt; wait) &#123; pervious = now fn.apply(this, args) &#125; &#125;&#125; underscore源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 /* options的默认值 * 表示首次调用返回值方法时，会马上调用func；否则仅会记录当前时刻，当第二次调用的时间间隔超过wait时，才调用func。 * options.leading = true; * 表示当调用方法时，未到达wait指定的时间间隔，则启动计时器延迟调用func函数，若后续在既未达到wait指定的时间间隔和func函数又未被调用的情况下调用返回值方法，则被调用请求将被丢弃。 * options.trailing = true; * 注意：当options.trailing = false时，效果与上面的简单实现效果相同 */_.throttle = function(func, wait, options) &#123; var timeout, context, args, result; var previous = 0; if (!options) options = &#123;&#125;; var later = function() &#123; previous = options.leading === false ? 0 : _.now(); timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; &#125;; var throttled = function() &#123; var now = _.now(); if (!previous &amp;&amp; options.leading === false) previous = now; // 默认为时开头就调用一次的， Date.now() - previous (0) &gt; wait var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) &#123; // 当间隔大于wait 或者 当前时间小于上一个时间(！！！客户端人为的更改系统时间后，马上执行了func函数) if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; result = func.apply(context, args); if (!timeout) context = args = null; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; // 无timeout和 允许结尾时调用一次函数 timeout = setTimeout(later, remaining); &#125; return result; &#125;; throttled.cancel = function() &#123; clearTimeout(timeout); previous = 0; timeout = context = args = null; &#125;; return throttled; &#125;; 防抖介绍如果用手指一直按住一个弹簧，它将不会弹起直到你松手为止。也就是说当调用动作n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。 简单demo123456789101112131415161718function debouce (fn, wait, immediate) &#123; let timer = null return function(...args)&#123; &lt;!-- 清除原来的延时器 --&gt; if(tiemr) clearTimeout(timer) &lt;!-- 第一次调用 --&gt; if (immediate &amp;&amp; !tiemr)&#123; fn.apply(this, args) &#125; timer = setTimeout(function() &#123; fn.apply(this, args) &#125;, wait) &#125;&#125; 加强版的throttle现在考虑一种情况，如果用户的操作非常频繁，不等设置的延迟时间结束就进行下次操作，会频繁的清除计时器并重新生成，所以函数 fn 一直都没办法执行，导致用户操作迟迟得不到响应。有一种思想是将「节流」和「防抖」合二为一，变成加强版的节流函数，关键点在于「 wait 时间内，可以重新生成定时器，但只要 wait 的时间到了，必须给用户一个响应。这种合体思路恰好可以解决上面提出的问题。1234567891011121314151617181920212223function throttle(fn, wait , immediate) &#123; let pervious = 0 let timer = null return function(...args) &#123; let now = Date.now() if(now - pervious &lt; wait) &#123; if (timer) clearTimeout(timer) if (immediate &amp;&amp; !timer) &#123; fn.apply(this, args) &#125; timer = setTimeout(function() &#123; pervious = now fn.apply(this, args) &#125;) &#125;else&#123; pervious = now fn.apply(this, args) &#125; &#125;&#125; underscore源码分析实现原理和demo可以说是一摸一样1234567891011121314151617181920212223242526272829303132333435363738394041424344// 此处的三个参数上文都有解释_.debounce = function(func, wait, immediate) &#123; var timer, result; // 定时器计时结束后 // 1、清空计时器，使之不影响下次连续事件的触发 // 2、触发执行 func var later = function(context, args) &#123; timer = null; if (args) result = func.apply(context, args); &#125;; // 将 debounce 处理结果当作函数返回 var debounced = restArguments(function(args) &#123; if (timer) clearTimeout(timer); if (immediate) &#123; // 第一次触发后会设置 timer， // 根据 timer 是否为空可以判断是否是首次触发 var callNow = !timer; timer = setTimeout(later, wait); if (callNow) result = func.apply(this, args); &#125; else &#123; // 设置定时器 timer = _.delay(later, wait, this, args); &#125; return result; &#125;); // 新增 手动取消 debounced.cancel = function() &#123; clearTimeout(timer); timer = null; &#125;; return debounced;&#125;;// 根据给定的毫秒 wait 延迟执行函数 func_.delay = restArguments(function(func, wait, args) &#123; return setTimeout(function() &#123; return func.apply(null, args); &#125;, wait);&#125;);","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"}]},{"title":"highcharts中一些插件的使用方式demo","slug":"highcharts中一些插件的使用方式demo","date":"2019-06-03T19:54:27.000Z","updated":"2019-09-16T00:56:14.082Z","comments":true,"path":"2019/06/04/highcharts中一些插件的使用方式demo/","link":"","permalink":"http://yongchao.tech:8080/2019/06/04/highcharts中一些插件的使用方式demo/","excerpt":"","text":"效果图demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251&lt;template&gt; &lt;Card dis-hover class=&quot;chart-item&quot; style=&quot;margin-bottom:20px&quot;&gt; &lt;template v-if=&quot;!simple&quot;&gt; &lt;div slot=&quot;title&quot; class=&quot;chart-item-title&quot;&gt; &#123;&#123; title &#125;&#125; &lt;span style=&quot;float:right&quot;&gt; &lt;slot name=&quot;extra&quot;&gt; &lt;template v-if=&quot;unit&quot;&gt; &lt;span class=&quot;desc-title&quot;&gt;单位&lt;/span&gt; &#123;&#123;unit&#125;&#125; &lt;span class=&apos;vertital-divider&apos;&gt;|&lt;/span&gt; &lt;/template&gt; &lt;/slot&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;chart-item-header&quot;&gt; &lt;slot name=&quot;operation&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; &lt;div ref=&quot;chart&quot; :class=&quot;[&apos;chart-item-content&apos;, &#123;&apos;simple&apos; : simple&#125;]&quot;&gt;&lt;/div&gt; &lt;/Card&gt;&lt;/template&gt;&lt;script&gt;import Highcharts from &apos;highcharts&apos;import HighchartsNoData from &apos;highcharts/modules/no-data-to-display&apos;import HighchartsExporting from &apos;highcharts/modules/exporting&apos;import mockData from &apos;./mock.js&apos;HighchartsNoData(Highcharts)HighchartsExporting(Highcharts)export default &#123; name: &apos;ChartItem&apos;, props: &#123; simple: &#123; type: Boolean, default: false &#125;, type: &#123; type: String, default: &apos;line&apos;, validator (val) &#123; if ([&apos;area&apos;, &apos;spline&apos;, &apos;line&apos;].indexOf(val) &gt; -1) &#123; return true &#125; else &#123; throw new Error(&apos;chart type must be oneof [line, spline, area]&apos;) &#125; &#125; &#125;, title: &#123; type: String, default: &apos;&apos; &#125;, // 图表名字 extra: Object, // 关于图表的一些其他信息 data: &#123; type: Array, required: true &#125;, unit: &#123; type: String, default: &apos;&apos; &#125;, plotLine: &#123; type: Object, default: null &#125;, notTimeStamp: &#123; type: Boolean, default: false &#125; &#125;, data () &#123; return &#123; chartInstance: null, mockData: mockData &#125; &#125;, computed: &#123; // resize () &#123; // return this.$store.state.common.resize // &#125;, option () &#123; return &#123; chart: &#123; type: this.type &#125;, title: &#123; text: this.simple ? this.title : &apos;&apos;, style: &#123; fontWeight: &apos;bold&apos; &#125; &#125;, credits: &#123; text: &apos;http://nevis.sina.com.cn&apos;, href: &apos;http://nevis.sina.com.cn&apos; &#125;, legend: &#123; enabled: true, lineHeight: 20, maxHeight: 40 &#125;, tooltip: &#123; xDateFormat: &apos;%Y-%m-%d %H:%M&apos;, valueDecimals: 2, shared: true &#125;, xAxis: &#123; startOnTick: true, tickmarkPlacement: &apos;on&apos;, type: &apos;datetime&apos;, dateTimeLabelFormats: &#123; day: &apos;%Y/%b/%e&apos; &#125;, followPointer: true, crosshair: true &#125;, yAxis: &#123; startOnTick: true, lineWidth: 1, tickWidth: 1, title: &#123; align: &apos;middle&apos;, text: `值($&#123;this.unit&#125;)` &#125;, plotBands: [], min: this.min || null &#125;, plotOptions: &#123; series: &#123; lineWidth: 1, marker: &#123; enabled: false &#125; &#125; &#125;, exporting: &#123; enabled: true, buttons: &#123; contextButton: &#123; menuItems: [ &apos;viewFullscreen&apos;, &apos;downloadPNG&apos;, &apos;downloadJPEG&apos;, &apos;downloadPDF&apos;, &apos;downloadSVG&apos; ] &#125; &#125;, filename: this.title &#125;, series: this.innerData &#125; &#125;, innerData () &#123; if (this.notTimeStamp) &#123; return this.data.map(item =&gt; &#123; return [Date.parse(item[0]), item[1]] &#125;) &#125; else &#123; return this.data &#125; &#125; &#125;, watch: &#123; // resize () &#123; // this.chartInstance &amp;&amp; this.chartInstance.reflow() // &#125; &#125;, methods: &#123; init () &#123; Highcharts.setOptions(&#123; global: &#123; useUTC: false &#125;, lang: &#123; loading: &apos;加载中...&apos;, shortMonths: [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;10&apos;, &apos;11&apos;, &apos;12&apos;], printChart: &apos;打印图表&apos;, downloadJPEG: &apos;导出jpeg&apos;, downloadPNG: &apos;导出png&apos;, downloadSVG: &apos;导出svg&apos;, downloadPDF: &apos;导出pdf&apos;, noData: &apos;暂无数据&apos;, contextButtonTitle: &apos;导出&apos;, viewFullscreen: &apos;全屏显示&apos;, viewData: &apos;表格显示数据&apos; &#125; &#125;) let option = this.option if (this.plotLine) &#123; option = Object.assign(this.option, &#123; yAxis: &#123; plotLines: [ &#123; value: this.plotLine.value, color: &apos;red&apos;, width: 2, dashStyle: &apos;solid&apos;, label: &#123; text: this.plotLine.text || &apos;&apos;, align: this.plotLine.align || &apos;left&apos;, style: &#123; color: &apos;red&apos;, fontSize: &apos;18px&apos; &#125; &#125; &#125; ] &#125; &#125;) &#125; Highcharts.chart(this.$refs.chart, option) &#125; &#125;, mounted () &#123; this.init() &#125;, beforeDestroy () &#123; this.chartInstance &amp;&amp; this.chartInstance.destroy() this.chartInstance = null &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.chart-item &#123; margin-bottom: 20px; &amp;-title &#123; font-weight: bold; height: 18px; line-height: 18px; .vertital-divider&#123; margin: 0 5px; display: inline-block; width: 1px; vertical-align: middle; color: #e8eaec; box-sizing: border-box; background: #e8eaec; &#125; .desc-title&#123; color: #888; &#125; &#125; &amp;-header &#123; text-align: right; &#125; &amp;-content &#123; height: 300px; &#125; .simple&#123; height: 346px; &#125;&#125;&lt;/style&gt;","categories":[{"name":"graph","slug":"graph","permalink":"http://yongchao.tech:8080/categories/graph/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yongchao.tech:8080/tags/vue/"},{"name":"highcharts","slug":"highcharts","permalink":"http://yongchao.tech:8080/tags/highcharts/"}]},{"title":"iphone中的一些兼容问题","slug":"iphone中的一些兼容问题","date":"2019-06-03T19:46:19.000Z","updated":"2019-08-08T06:46:59.933Z","comments":true,"path":"2019/06/04/iphone中的一些兼容问题/","link":"","permalink":"http://yongchao.tech:8080/2019/06/04/iphone中的一些兼容问题/","excerpt":"","text":"滚动不流畅解决办法：123 overflow-y: scroll;touch-action: pan-y;-webkit-overflow-scrolling: touch; input再次获得焦点时，需要多次点击12345678910111213&lt;!-- 解决300ms延迟 --&gt;import fastClick from &apos;fastclick&apos;// 解决ios输入框bug：第一次点击输入框，正常反应；// 点击键盘完成后，再次点击输入框，很难再获得焦点的问题fastClick.prototype.onTouchEnd = function (event) &#123; if (event.target.hasAttribute(&apos;type&apos;) &amp;&amp; event.target.getAttribute(&apos;type&apos;) === &apos;text&apos;) &#123; event.preventDefault() return false &#125;&#125;fastClick.attach(document.body)","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yongchao.tech:8080/tags/vue/"},{"name":"css","slug":"css","permalink":"http://yongchao.tech:8080/tags/css/"}]},{"title":"vue中组件间的六种通信方式","slug":"vue中组件通信的六种方式","date":"2019-06-03T19:00:42.000Z","updated":"2019-08-08T06:46:59.938Z","comments":true,"path":"2019/06/04/vue中组件通信的六种方式/","link":"","permalink":"http://yongchao.tech:8080/2019/06/04/vue中组件通信的六种方式/","excerpt":"","text":"方法一 props、$emit父组件A通过props的方式向子组件B传递，B to A 通过在 B 组件中 $emit, A 组件中 v-on 的方式实现。 1.父组件向子组件传值接下来我们通过一个例子，说明父组件如何向子组件传递值：在子组件Users.vue中如何获取父组件App.vue中的数据 users:[“Henry”,”Bucky”,”Emily”12345678910111213141516171819//App.vue父组件&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;users v-bind:users=&quot;users&quot;&gt;&lt;/users&gt;//前者自定义名称便于子组件调用，后者要传递数据名 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Users from &quot;./components/Users&quot;export default &#123; name: &apos;App&apos;, data()&#123; return&#123; users:[&quot;Henry&quot;,&quot;Bucky&quot;,&quot;Emily&quot;] &#125; &#125;, components:&#123; &quot;users&quot;:Users &#125;&#125; 12345678910111213141516171819//users子组件&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;user in users&quot;&gt;&#123;&#123;user&#125;&#125;&lt;/li&gt;//遍历传递过来的值，然后呈现到页面 &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;HelloWorld&apos;, props:&#123; users:&#123; //这个就是父组件中子标签自定义名字\\ type:Array, required:true &#125; &#125;&#125;&lt;/script&gt; 总结：父组件通过props向下传递数据给子组件。注：组件中的数据共有三种形式：data、props、computed 2.子组件向父组件传值（通过事件形式）接下来我们通过一个例子，说明子组件如何向父组件传递值：当我们点击“Vue.js Demo”后，子组件向父组件传递值，文字由原来的“传递的是一个值”变成“子向父组件传值”，实现子组件向父组件值的传递。123456789101112131415161718192021// 子组件&lt;template&gt; &lt;header&gt; &lt;h1 @click=&quot;changeTitle&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;//绑定一个点击事件 &lt;/header&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;app-header&apos;, data() &#123; return &#123; title:&quot;Vue.js Demo&quot; &#125; &#125;, methods:&#123; changeTitle() &#123; this.$emit(&quot;titleChanged&quot;,&quot;子向父组件传值&quot;);//自定义事件 传递值“子向父组件传值” &#125; &#125;&#125;&lt;/script&gt; 123456789101112131415161718192021222324252627// 父组件&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;app-header v-on:titleChanged=&quot;updateTitle&quot; &gt;&lt;/app-header&gt;//与子组件titleChanged自定义事件保持一致 // updateTitle($event)接受传递过来的文字 &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Header from &quot;./components/Header&quot;export default &#123; name: &apos;App&apos;, data()&#123; return&#123; title:&quot;传递的是一个值&quot; &#125; &#125;, methods:&#123; updateTitle(e)&#123; //声明这个函数 this.title = e; &#125; &#125;, components:&#123; &quot;app-header&quot;:Header, &#125;&#125;&lt;/script&gt; 总结：子组件通过events给父组件发送消息，实际上就是子组件把自己的数据发送到父组件。 方法二、 $emit / $on这种方法通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级。当我们的项目比较大时，可以选择更好的状态管理解决方案vuex。 1.具体实现方式：123var Event=new Vue();Event.$emit(事件名,数据);Event.$on(事件名,data =&gt; &#123;&#125;); 2.举个例子假设兄弟组件有三个，分别是A、B、C组件，C组件如何获取A或者B组件的数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;div id=&quot;itany&quot;&gt; &lt;my-a&gt;&lt;/my-a&gt; &lt;my-b&gt;&lt;/my-b&gt; &lt;my-c&gt;&lt;/my-c&gt;&lt;/div&gt;&lt;template id=&quot;a&quot;&gt; &lt;div&gt; &lt;h3&gt;A组件：&#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;button @click=&quot;send&quot;&gt;将数据发送给C组件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id=&quot;b&quot;&gt; &lt;div&gt; &lt;h3&gt;B组件：&#123;&#123;age&#125;&#125;&lt;/h3&gt; &lt;button @click=&quot;send&quot;&gt;将数组发送给C组件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id=&quot;c&quot;&gt; &lt;div&gt; &lt;h3&gt;C组件：&#123;&#123;name&#125;&#125;，&#123;&#123;age&#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;var Event = new Vue();//定义一个空的Vue实例var A = &#123; template: &apos;#a&apos;, data() &#123; return &#123; name: &apos;tom&apos; &#125; &#125;, methods: &#123; send() &#123; Event.$emit(&apos;data-a&apos;, this.name); &#125; &#125;&#125;var B = &#123; template: &apos;#b&apos;, data() &#123; return &#123; age: 20 &#125; &#125;, methods: &#123; send() &#123; Event.$emit(&apos;data-b&apos;, this.age); &#125; &#125;&#125;var C = &#123; template: &apos;#c&apos;, data() &#123; return &#123; name: &apos;&apos;, age: &quot;&quot; &#125; &#125;, mounted() &#123;//在模板编译完成后执行 Event.$on(&apos;data-a&apos;,name =&gt; &#123; this.name = name;//箭头函数内部不会产生新的this，这边如果不用=&gt;,this指代Event &#125;) Event.$on(&apos;data-b&apos;,age =&gt; &#123; this.age = age; &#125;) &#125;&#125;var vm = new Vue(&#123; el: &apos;#itany&apos;, components: &#123; &apos;my-a&apos;: A, &apos;my-b&apos;: B, &apos;my-c&apos;: C &#125;&#125;); &lt;/script&gt; 监听了自定义事件 data-a和data-b，因为有时不确定何时会触发事件，一般会在 mounted 或 created 钩子中来监听。 方法三、vuex 1.简要介绍Vuex原理Vuex实现了一个单向数据流，在全局拥有一个State存放数据，当组件要更改State中的数据时，必须通过Mutation进行，Mutation同时提供了订阅者模式供外部插件调用获取State数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走Action，但Action也是无法直接修改State的，还是需要通过Mutation来修改State的数据。最后，根据State的变化，渲染到视图上。 2.简要介绍各模块在流程中的功能： Vue Components：Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。 dispatch：操作行为触发方法，是唯一能执行action的方法。 actions：操作行为处理模块,由组件中的 $store.dispatch(‘action 名称’,data1)来触发。然后由commit()来触发mutation的调用 , 间接更新 state。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。 commit：状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。 mutations：状态改变操作方法，由actions中的 commit(‘mutation 名称’)来触发。是Vuex修改state的唯一推荐方法。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。 state：页面状态管理容器对象。集中存储Vue components中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。 getters：state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。3.Vuex与localStoragevuex 是 vue 的状态管理器，存储的数据是响应式的。但是并不会保存起来，刷新之后就回到了初始状态，具体做法应该在vuex里数据改变的时候把数据拷贝一份保存到localStorage里面，刷新之后，如果localStorage里有保存的数据，取出来再替换store里的state。1234567891011121314151617181920let defaultCity = &quot;上海&quot;try &#123; // 用户关闭了本地存储功能，此时在外层加个try...catch if (!defaultCity)&#123; defaultCity = JSON.parse(window.localStorage.getItem(&apos;defaultCity&apos;)) &#125;&#125;catch(e)&#123;&#125;export default new Vuex.Store(&#123; state: &#123; city: defaultCity &#125;, mutations: &#123; changeCity(state, city) &#123; state.city = city try &#123; window.localStorage.setItem(&apos;defaultCity&apos;, JSON.stringify(state.city)); // 数据改变的时候把数据拷贝一份保存到localStorage里面 &#125; catch (e) &#123;&#125; &#125; &#125;&#125;) 这里需要注意的是：由于vuex里，我们保存的状态，都是数组，而localStorage只支持字符串，所以需要用JSON转换：12JSON.stringify(state.subscribeList); // array -&gt; stringJSON.parse(window.localStorage.getItem(&quot;subscribeList&quot;)); // string -&gt; array 方法四、 $attrs / $listeners1.简介多级组件嵌套需要传递数据时，通常使用的方法是通过vuex。但如果仅仅是传递数据，而不做中间处理，使用 vuex 处理，未免有点大材小用。为此Vue2.4 版本提供了另一种方法—- $attrs/ $listeners $attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件。通常配合 interitAttrs 选项一起使用。 $listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件接下来我们看个跨级通信的例子：123456789101112131415161718192021222324252627// index.vue&lt;template&gt; &lt;div&gt; &lt;h2&gt;浪里行舟&lt;/h2&gt; &lt;child-com1 :foo=&quot;foo&quot; :boo=&quot;boo&quot; :coo=&quot;coo&quot; :doo=&quot;doo&quot; title=&quot;前端工匠&quot; &gt;&lt;/child-com1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const childCom1 = () =&gt; import(&quot;./childCom1.vue&quot;);export default &#123; components: &#123; childCom1 &#125;, data() &#123; return &#123; foo: &quot;Javascript&quot;, boo: &quot;Html&quot;, coo: &quot;CSS&quot;, doo: &quot;Vue&quot; &#125;; &#125;&#125;;&lt;/script&gt; 1234567891011121314151617181920212223// childCom1.vue&lt;template class=&quot;border&quot;&gt; &lt;div&gt; &lt;p&gt;foo: &#123;&#123; foo &#125;&#125;&lt;/p&gt; &lt;p&gt;childCom1的$attrs: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt; &lt;child-com2 v-bind=&quot;$attrs&quot;&gt;&lt;/child-com2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const childCom2 = () =&gt; import(&quot;./childCom2.vue&quot;);export default &#123; components: &#123; childCom2 &#125;, inheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性 props: &#123; foo: String // foo作为props属性绑定 &#125;, created() &#123; console.log(this.$attrs); // &#123; &quot;boo&quot;: &quot;Html&quot;, &quot;coo&quot;: &quot;CSS&quot;, &quot;doo&quot;: &quot;Vue&quot;, &quot;title&quot;: &quot;前端工匠&quot; &#125; &#125;&#125;;&lt;/script&gt; 1234567891011121314151617181920212223// childCom2.vue&lt;template&gt; &lt;div class=&quot;border&quot;&gt; &lt;p&gt;boo: &#123;&#123; boo &#125;&#125;&lt;/p&gt; &lt;p&gt;childCom2: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt; &lt;child-com3 v-bind=&quot;$attrs&quot;&gt;&lt;/child-com3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const childCom3 = () =&gt; import(&quot;./childCom3.vue&quot;);export default &#123; components: &#123; childCom3 &#125;, inheritAttrs: false, props: &#123; boo: String &#125;, created() &#123; console.log(this.$attrs); // &#123; &quot;boo&quot;: &quot;Html&quot;, &quot;coo&quot;: &quot;CSS&quot;, &quot;doo&quot;: &quot;Vue&quot;, &quot;title&quot;: &quot;前端工匠&quot; &#125; &#125;&#125;;&lt;/script&gt; 1234567891011121314// childCom3.vue&lt;template&gt; &lt;div class=&quot;border&quot;&gt; &lt;p&gt;childCom3: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; coo: String, title: String &#125;&#125;;&lt;/script&gt; $attrs表示没有继承数据的对象，格式为{属性名：属性值}。Vue2.4提供了 $attrs , $listeners 来传递数据与事件，跨级组件之间的通讯变得更简单。简单来说： $attrs与 $listeners 是两个对象， $attrs 里存放的是父组件中绑定的非 Props 属性， $listeners里存放的是父组件中绑定的非原生事件。 方法五、provide/inject1.简介Vue2.2.0新增API,这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。一言而蔽之：祖先组件中通过provider来提供变量，然后在子孙组件中通过inject来注入变量。provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。 2.举个例子假设有两个组件： A.vue 和 B.vue，B 是 A 的子组件12345678910111213// A.vueexport default &#123; provide: &#123; name: &apos;浪里行舟&apos; &#125;&#125;// B.vueexport default &#123; inject: [&apos;name&apos;], mounted () &#123; console.log(this.name); // 浪里行舟 &#125;&#125; 可以看到，在 A.vue 里，我们设置了一个 provide: name，值为 浪里行舟，它的作用就是将 name 这个变量提供给它的所有子组件。而在 B.vue 中，通过 inject 注入了从 A 组件中提供的 name 变量，那么在组件 B 中，就可以直接通过 this.name 访问这个变量了，它的值也是 浪里行舟。这就是 provide / inject API 最核心的用法。需要注意的是：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的—-vue官方文档所以，上面 A.vue 的 name 如果改变了，B.vue 的 this.name 是不会改变的 3.provide与inject 怎么实现数据响应式一般来说，有两种办法： provide祖先组件的实例，然后在子孙组件中注入依赖，这样就可以在子孙组件中直接修改祖先组件的实例的属性，不过这种方法有个缺点就是这个实例上挂载很多没有必要的东西比如props，methods 使用2.6最新API Vue.observable 优化响应式 provide(推荐)我们来看个例子：孙组件D、E和F获取A组件传递过来的color值，并能实现数据响应式变化，即A组件的color变化后，组件D、E、F不会跟着变（核心代码如下：）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// A 组件 &lt;div&gt; &lt;h1&gt;A 组件&lt;/h1&gt; &lt;button @click=&quot;() =&gt; changeColor()&quot;&gt;改变color&lt;/button&gt; &lt;ChildrenB /&gt; &lt;ChildrenC /&gt;&lt;/div&gt;...... data() &#123; return &#123; color: &quot;blue&quot; &#125;; &#125;, // provide() &#123; // return &#123; // theme: &#123; // color: this.color //这种方式绑定的数据并不是可响应的 // &#125; // 即A组件的color变化后，组件D、E、F不会跟着变 // &#125;; // &#125;, provide() &#123; return &#123; theme: this//方法一：提供祖先组件的实例 &#125;; &#125;, methods: &#123; changeColor(color) &#123; if (color) &#123; this.color = color; &#125; else &#123; this.color = this.color === &quot;blue&quot; ? &quot;red&quot; : &quot;blue&quot;; &#125; &#125; &#125; // 方法二:使用vue2.6最新API Vue.observable 优化响应式 provide // provide() &#123; // this.theme = Vue.observable(&#123; // color: &quot;blue&quot; // &#125;); // return &#123; // theme: this.theme // &#125;; // &#125;, // methods: &#123; // changeColor(color) &#123; // if (color) &#123; // this.theme.color = color; // &#125; else &#123; // this.theme.color = this.theme.color === &quot;blue&quot; ? &quot;red&quot; : &quot;blue&quot;; // &#125; // &#125; // &#125;// F 组件 &lt;template functional&gt; &lt;div class=&quot;border2&quot;&gt; &lt;h3 :style=&quot;&#123; color: injections.theme.color &#125;&quot;&gt;F 组件&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; inject: &#123; theme: &#123; //函数式组件取值不一样 default: () =&gt; (&#123;&#125;) &#125; &#125;&#125;;&lt;/script&gt; 虽说provide 和 inject 主要为高阶插件/组件库提供用例，但如果你能在业务中熟练运用，可以达到事半功倍的效果！ 方法六、 $parent / $children ＆ ref ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例 $parent / $children：访问父 / 子实例需要注意的是：这两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据。我们先来看个用 ref来访问组件的例子：1234567891011121314151617181920212223242526// component-a 子组件export default &#123; data () &#123; return &#123; title: &apos;Vue.js&apos; &#125; &#125;, methods: &#123; sayHello () &#123; window.alert(&apos;Hello&apos;); &#125; &#125;&#125;// 父组件&lt;template&gt; &lt;component-a ref=&quot;comA&quot;&gt;&lt;/component-a&gt;&lt;/template&gt;&lt;script&gt; export default &#123; mounted () &#123; const comA = this.$refs.comA; console.log(comA.title); // Vue.js comA.sayHello(); // 弹窗 &#125; &#125;&lt;/script&gt; 不过，这两种方法的弊端是，无法在跨级或兄弟间通信。1234// parent.vue&lt;component-a&gt;&lt;/component-a&gt;&lt;component-b&gt;&lt;/component-b&gt;&lt;component-b&gt;&lt;/component-b&gt; 我们想在 component-a 中，访问到引用它的页面中（这里就是 parent.vue）的两个 component-b 组件，那这种情况下，就得配置额外的插件或工具了，比如 Vuex 和 Bus 的解决方案 总结常见使用场景可以分为三类： 父子通信： 父向子传递数据是通过 props，子向父是通过 events（ $emit）；通过父链 / 子链也可以通信（ $parent / $children）；ref 也可以访问组件实例；provide / inject API； $attrs/$listeners 兄弟通信： Bus；Vuex 跨级通信： Bus；Vuex；provide / inject API、 $attrs/$listeners","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yongchao.tech:8080/tags/vue/"}]},{"title":"深拷贝","slug":"深拷贝","date":"2019-05-04T15:29:06.000Z","updated":"2019-09-08T04:06:22.436Z","comments":true,"path":"2019/05/04/深拷贝/","link":"","permalink":"http://yongchao.tech:8080/2019/05/04/深拷贝/","excerpt":"概念浅拷贝创建一个新的对象，这个对象有着对原始对象的属性值的一份拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果是引用对象，拷贝的是地址。所以如果其中一个对象改变了这个地址，就是影响另一个对象 深拷贝将一个对象从内存中完整的拷贝一份出来，从堆中开辟出一个新的区域来存放新对象，且修改新的对象不会影响到原对象","text":"概念浅拷贝创建一个新的对象，这个对象有着对原始对象的属性值的一份拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果是引用对象，拷贝的是地址。所以如果其中一个对象改变了这个地址，就是影响另一个对象 深拷贝将一个对象从内存中完整的拷贝一份出来，从堆中开辟出一个新的区域来存放新对象，且修改新的对象不会影响到原对象 简易版(实际上也是项目中最常用的)1JSON.parse(JSON.stringify(原对象)) 基础版1234567891011function deep_clone1 (source) &#123; if (typeof source === &apos;object&apos;) &#123; let target = &#123;&#125; for(let key in source) &#123; target[key] = clone(source[key]) &#125; return target &#125;else&#123; return source &#125;&#125; 但是很显然，还存在很多问题，比如并没有考虑数组、循环引用 考虑数组1234567891011function deep_clone2 (source) &#123; if (typeof source === &apos;object&apos;) &#123; let target = Array.isArray(source) ? [] : &#123;&#125; for(let key in source) &#123; target[key] = clone(source[key]) &#125; return target &#125;else&#123; return source &#125;&#125; 数组和对象的遍历方式可以一致，就是存储的时候不同，[]和{} 处理循环引用1234567891011121314151617function deep_clone3 (source, map = new Map()) &#123; if (typeof source === &apos;object&apos;) &#123; let target = Array.isArray(source) ? [] : &#123;&#125; // 专门处理循环引用问题（object类型) if(map.get(source)) &#123; return map.get(source) &#125; map.set(source, target) for(let key in source) &#123; target[key] = deep_clone3(source[key], map) &#125; return target &#125;else&#123; return source &#125;&#125; 使用WeakMap画龙点睛WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。 什么是弱引用呢？ 在计算机程序设计中，弱引用与强引用相对，是指不能确保其引用的对象不会被垃圾回收器回收的引用。 一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收。 举个例子：如果我们使用Map的话，那么对象间是存在强引用关系的：1234let obj = &#123; name : &apos;ConardLi&apos;&#125;const target = new Map();target.set(obj,&apos;code秘密花园&apos;);obj = null; 复制代码虽然我们手动将obj，进行释放，然是target依然对obj存在强引用关系，所以这部分内存依然无法被释放。再来看WeakMap：1234let obj = &#123; name : &apos;ConardLi&apos;&#125;const target = new WeakMap();target.set(obj,&apos;code秘密花园&apos;);obj = null; 复制代码如果是WeakMap的话，target和obj存在的就是弱引用关系，当下一次垃圾回收机制执行时，这块内存就会被释放掉。设想一下，如果我们要拷贝的对象非常庞大时，使用Map会对内存造成非常大的额外消耗，而且我们需要手动清除Map的属性才能释放这块内存，而WeakMap会帮我们巧妙化解这个问题。 引用ConardLi：https://juejin.im/post/5d6aa4f96fb9a06b112ad5b1 性能优化在上面的代码中，我们遍历数组和对象都使用了for in这种方式，实际上for in在遍历时效率是非常低的.经过比较执行效率 while &gt; for &gt; for in先实现一个通用的forEach 循环， iterate 是遍历的回调函数， 每次接收value和index两个参数：12345678function forEach(arr, iterate) &#123; let index = -1 const len = array.length while(++index &lt; len&gt;) &#123; iterate(array[index], index) &#125; return array&#125; 然后对之前的代码进行调整1234567891011121314151617181920212223function deep_clone3 (source, map = new Map()) &#123; if (typeof source === &apos;object&apos;) &#123; const isArray = Array.isArray(source) let target = isArray ? [] : &#123;&#125; // 专门处理循环引用问题（object类型) if(map.get(source)) &#123; return map.get(source) &#125; map.set(source, target) const keys = isArray ? undefined ? Object.keys(source) forEach(keys || source, (value, index)) &#123; if (keys) &#123; // 处理对象， value就是对象key key = value &#125; target[key] = deep_clone3(source[key], map) &#125; return target &#125;else&#123; return source &#125;&#125; 其他数据类型可继续遍历的类型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980const mapTag = &apos;[object Map]&apos;;const setTag = &apos;[object Set]&apos;;const arrayTag = &apos;[object Array]&apos;;const objectTag = &apos;[object Object]&apos;;const argsTag = &apos;[object Arguments]&apos;;const deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];function forEach(array, iteratee) &#123; let index = -1; const length = array.length; while (++index &lt; length) &#123; iteratee(array[index], index); &#125; return array;&#125;function isObject(target) &#123; const type = typeof target; return target !== null &amp;&amp; (type === &apos;object&apos; || type === &apos;function&apos;);&#125;function getType(target) &#123; return Object.prototype.toString.call(target);&#125;function getInit(target) &#123; const Ctor = target.constructor; return new Ctor();&#125;function clone(target, map = new WeakMap()) &#123; // 克隆原始类型 if (!isObject(target)) &#123; return target; &#125; // 初始化 const type = getType(target); let cloneTarget; if (deepTag.includes(type)) &#123; cloneTarget = getInit(target, type); &#125; // 防止循环引用 if (map.get(target)) &#123; return target; &#125; map.set(target, cloneTarget); // 克隆set if (type === setTag) &#123; target.forEach(value =&gt; &#123; cloneTarget.add(clone(value)); &#125;); return cloneTarget; &#125; // 克隆map if (type === mapTag) &#123; target.forEach((value, key) =&gt; &#123; cloneTarget.set(key, clone(value)); &#125;); return cloneTarget; &#125; // 克隆对象和数组 const keys = type === arrayTag ? undefined : Object.keys(target); forEach(keys || target, (value, key) =&gt; &#123; if (keys) &#123; key = value; &#125; cloneTarget[key] = clone(target[key], map); &#125;); return cloneTarget;&#125; 不可继续遍历的类型Bool、Number、String、Symbol、Date、Error这几种类型我们都可以直接用构造函数和原始数据创建一个新对象： 123456789101112131415161718192021222324252627282930function cloneOtherType(targe, type) &#123; const Ctor = targe.constructor; switch (type) &#123; case boolTag: case numberTag: case stringTag: case errorTag: case dateTag: return new Ctor(targe); case regexpTag: return cloneReg(targe); case symbolTag: return cloneSymbol(targe); default: return null; &#125;&#125;function cloneSymbol(targe) &#123; return Object(Symbol.prototype.valueOf.call(targe));&#125;克隆正则：function cloneReg(targe) &#123; const reFlags = /\\w*$/; const result = new targe.constructor(targe.source, reFlags.exec(targe)); result.lastIndex = targe.lastIndex; return result;&#125; 克隆函数首先，我们可以通过prototype来区分下箭头函数和普通函数，箭头函数是没有prototype的。我们可以直接使用eval和函数字符串来重新生成一个箭头函数，注意这种方法是不适用于普通函数的。我们可以使用正则来处理普通函数：分别使用正则取出函数体和函数参数，然后使用new Function ([arg1[, arg2[, …argN]],] functionBody)构造函数重新构造一个新的函数：1234567891011121314151617181920212223242526272829function cloneFunction(func) &#123; const bodyReg = /(?&lt;=&#123;)(.|\\n)+(?=&#125;)/m; const paramReg = /(?&lt;=\\().+(?=\\)\\s+&#123;)/; const funcString = func.toString(); if (func.prototype) &#123; console.log(&apos;普通函数&apos;); const param = paramReg.exec(funcString); const body = bodyReg.exec(funcString); if (body) &#123; console.log(&apos;匹配到函数体：&apos;, body[0]); if (param) &#123; const paramArr = param[0].split(&apos;,&apos;); console.log(&apos;匹配到参数：&apos;, paramArr); return new Function(...paramArr, body[0]); &#125; else &#123; return new Function(body[0]); &#125; &#125; else &#123; return null; &#125; &#125; else &#123; return eval(funcString); &#125;&#125;作者：ConardLi链接：https://juejin.im/post/5d6aa4f96fb9a06b112ad5b1来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 原文https://juejin.im/post/5d6aa4f96fb9a06b112ad5b1","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"}]},{"title":"变量、作用域和内存问题","slug":"js基本类型和引用类型","date":"2019-04-30T15:24:17.000Z","updated":"2019-08-08T06:46:59.934Z","comments":true,"path":"2019/04/30/js基本类型和引用类型/","link":"","permalink":"http://yongchao.tech:8080/2019/04/30/js基本类型和引用类型/","excerpt":"变量全局属性的两种创建方法的区别1. var a=’a’执行Object.getOwnPropertyDescriptor(window, ‘a’)123456&#123; value: &quot;a&quot;, writable: true, enumerable: true, configurable: false&#125; 2. a=’a’123456&#123; value: &quot;a&quot;, writable: true, enumerable: true, configurable: true&#125; 总而言之，最明显的区别就是var a = ‘a’这种方式定义的变量不能删除","text":"变量全局属性的两种创建方法的区别1. var a=’a’执行Object.getOwnPropertyDescriptor(window, ‘a’)123456&#123; value: &quot;a&quot;, writable: true, enumerable: true, configurable: false&#125; 2. a=’a’123456&#123; value: &quot;a&quot;, writable: true, enumerable: true, configurable: true&#125; 总而言之，最明显的区别就是var a = ‘a’这种方式定义的变量不能删除 复制变量的方式 复制基本类型时直接复制的是值 复制引用类型时复制的是一个指针 传递参数 传递参数的时候都是按值传递的。（在看了js高级程序设计之前，我是懵的。）访问变量有按值和按引用两种方式，而参数只能按值传递举个栗子就清楚了123456function setName(obj) &#123; obj.name = &quot;Nicholas&quot;;&#125;var person = new Object();setName(person);alert(person.name); //&quot;Nicholas&quot; 12345678function setName(obj) &#123; obj.name = &quot;Nicholas&quot;; obj = new Object(); obj.name = &quot;Greg&quot;;&#125;var person = new Object();setName(person);alert(person.name); //&quot;Nicholas&quot; 执行环境和作用域执行环境(execution context，为简单起见，有时也称为“环境”)是 JavaScript 中最为重要的一个概 念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个 与之关联的变量对象(variable object)，环境中定义的所有变量和函数都保存在这个对象中。虽然我们 编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。作用域链的用途，是 保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所 在环境的变量对象。如果这个环境是函数，则将其活动对象(activation object)作为变量对象。活动对 6 象在最开始时只包含一个变量，即 arguments 对象(这个对象在全局环境中是不存在的)。作用域链中 的下一个变量对象来自包含(外部)环境，而再下一个变量对象则来自下一个包含环境。这样，一直延 续到全局执行环境;全局执行环境的变量对象始终都是作用域链中的最后一个对象。标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始， 然后逐级地向后回溯，直至找到标识符为止(如果找不到标识符，通常会导致错误发生)。 基本类型 Undefined Unll Boolean Number String Symbol 小结1、基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中;2、从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本;3、引用类型的值是对象，保存在堆内存中;4、包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针;5、从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象","categories":[{"name":"js知识库","slug":"js知识库","permalink":"http://yongchao.tech:8080/categories/js知识库/"}],"tags":[]},{"title":"count-to组件","slug":"count-to组件","date":"2019-04-29T19:37:54.000Z","updated":"2019-10-16T03:24:59.179Z","comments":true,"path":"2019/04/30/count-to组件/","link":"","permalink":"http://yongchao.tech:8080/2019/04/30/count-to组件/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;template&gt; &lt;div&gt; &lt;slot name=&quot;prepend&quot;&gt;&lt;/slot&gt;&lt;span :class=&quot;classes&quot; ref=&quot;number&quot; :id=&quot;eleId&quot;&gt;&lt;/span&gt;&lt;slot name=&quot;append&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import CountUp from &apos;countup&apos;export default &#123; name: &apos;CountTo&apos;, props: &#123; satrtVal: &#123; type: Number, default: 0 &#125;, endVal: &#123; type: Number, required: true &#125;, /** * * @description 小数点的精度 */ decimals: &#123; type: Number, default: 0 &#125;, /** * * @description 动画时间，单位： 秒 */ duration: &#123; type: Number, default: 1 &#125;, separator: &#123; type: String, default: &apos;,&apos; &#125;, /** * * @description 是否使用分组 */ useGrouping: &#123; type: Boolean, default: true &#125;, /** * * @description 动画开始延迟，单位：毫秒 */ delay: &#123; type: Number, default: 0 &#125;, className: &#123; type: String, default: &apos;&apos; &#125; &#125;, data () &#123; return &#123; counter: &#123;&#125; &#125; &#125;, computed: &#123; eleId () &#123; return `count-to-$&#123;this._uid&#125;` &#125;, classes () &#123; return [ &apos;count-to-number&apos;, this.className ] &#125; &#125;, watch: &#123; endVal (newVal) &#123; this.counter.update(newVal) this.emitEndEvent() &#125; &#125;, methods: &#123; getCount () &#123; return this.$refs.number.innerText &#125;, /** * * @description 动画结束时发送事件 */ emitEndEvent () &#123; setTimeout(() =&gt; &#123; this.$nextTick(() =&gt; &#123; this.$emit(&apos;on-animation-end&apos;) &#125;) &#125;, this.duration * 1000 + 5) &#125; &#125;, mounted () &#123; this.$nextTick(() =&gt; &#123; this.counter = new CountUp(this.eleId, this.satrtVal, this.endVal, this.decimals, this.duration, &#123; useEasing: true, useGrouping: this.useGrouping, separator: this.separator, decimal: &apos;.&apos; &#125;) setTimeout(() =&gt; &#123; this.counter.start() this.emitEndEvent() &#125;, this.delay) &#125;) &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.count-to-number&#123; color: #000;&#125;&lt;/style&gt;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yongchao.tech:8080/tags/vue/"},{"name":"组件","slug":"组件","permalink":"http://yongchao.tech:8080/tags/组件/"}]},{"title":"button-popup","slug":"button-popup","date":"2019-04-29T17:58:49.000Z","updated":"2019-10-16T03:23:49.733Z","comments":true,"path":"2019/04/30/button-popup/","link":"","permalink":"http://yongchao.tech:8080/2019/04/30/button-popup/","excerpt":"效果图","text":"效果图 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;template&gt; &lt;Poptip :width=&quot;width&quot; placement=&quot;bottom-start&quot; trigger=&quot;click&quot;&gt; &lt;Button&gt;&#123;&#123;title&#125;&#125;&#123;&#123;checkAll ? &apos;(全选)&apos; : &apos;&apos;&#125;&#125;&lt;/Button&gt; &lt;div class=&quot;content&quot; slot=&quot;content&quot;&gt; &lt;Input v-model=&quot;search&quot; class=&quot;item&quot;/&gt; &lt;Checkbox v-model=&quot;checkAll&quot; class=&quot;item&quot; label=&quot;all&quot; @on-change=&quot;handleChangeAll&quot;&gt;全部&lt;/Checkbox&gt; &lt;CheckboxGroup v-model=&quot;select&quot; @on-change=&quot;handleChange&quot;&gt; &lt;Checkbox v-for=&quot;item in groups&quot; v-show=&quot;item.value.indexOf(search) &gt; -1&quot; :key=&quot;item.value&quot; :label=&quot;item.label&quot; class=&quot;item&quot;&gt; &#123;&#123;item.label&#125;&#125; &lt;/Checkbox&gt; &lt;/CheckboxGroup&gt; &lt;/div&gt; &lt;/Poptip&gt;&lt;/template&gt;&lt;script&gt;/** * 数据格式: * [&#123;label: &apos;&apos;, value: &apos;&apos;&#125;] * * or * * [&apos;XXX1&apos;, &apos;xxx2&apos;] */export default &#123; props: &#123; title: &#123; type: String, required: true &#125;, data: &#123; type: Array, required: true &#125;, value: &#123; type: Array, required: true &#125;, width: &#123; type: Number, default: 100 &#125; &#125;, data () &#123; return &#123; select: this.value, checkAll: false, search: &apos;&apos; &#125; &#125;, computed: &#123; groups () &#123; return this.data.map(item =&gt; &#123; if (typeof item === &apos;string&apos;) &#123; return &#123; label: item, value: item &#125; &#125; else if (typeof item === &apos;object&apos;) &#123; if ((&apos;value&apos; in item) &amp;&amp; (&apos;label&apos; in item)) &#123; return item &#125; &#125; else &#123; throw new Error(&apos;data is valid&apos;) &#125; &#125;) &#125; &#125;, watch: &#123; value () &#123; this.init() &#125; &#125;, methods: &#123; handleChange (val) &#123; if (val.length === this.data.length) &#123; this.select = this.data this.checkAll = true &#125; else &#123; this.checkAll = false &#125; this.$emit(&apos;on-change&apos;, this.select) &#125;, handleChangeAll (checkAll) &#123; if (checkAll) &#123; this.select = this.data &#125; else &#123; this.select = [] &#125; this.$emit(&apos;on-change&apos;, this.select) &#125;, init () &#123; this.select = this.value if (this.select.length === this.data.length) &#123; this.checkAll = true &#125; else &#123; this.checkAll = false &#125; &#125; &#125;, mounted () &#123; this.init() &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.content&#123; overflow: hidden;&#125;.item&#123; display: block; text-overflow: ellipsis;&#125;&lt;/style&gt;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yongchao.tech:8080/tags/vue/"},{"name":"组件","slug":"组件","permalink":"http://yongchao.tech:8080/tags/组件/"}]},{"title":"js的几种模块化方式","slug":"js的几种模块化方式","date":"2019-04-29T15:03:11.000Z","updated":"2019-08-08T06:46:59.934Z","comments":true,"path":"2019/04/29/js的几种模块化方式/","link":"","permalink":"http://yongchao.tech:8080/2019/04/29/js的几种模块化方式/","excerpt":"","text":"模块化的必要性：为了提高代码的开发效率，方便代码的维护，重构。 模块化与组件化的区别：模块可以理解为分解的页面逻辑，比如一个网站的登录，用户管理等；组件则是一个具体的功能。具体来说一个下拉框是一个组件，一个登录功能一个模块。 目前常见的模块化规范（排名不分先后）： AMD CMD CommonJS ES6 1. AMDAMD与CMD类似，不同的是AMD推崇依赖前置，–requireJS 推广过程中出现的规范。123456789/** main.js中引入1.js及2.js **/// 执行基本操作define([&quot;1.js&quot;,&quot;2.js&quot;],function($,_)&#123; // some code here&#125;);/** 如果1.js中又引入了3.js，那就会先广度优先，然后深度遍历。 请求1.js和2.js然后在1.js中进行3.js的请求，3.js返回结果后查看2.js是否已经返回， 如果已经返回则合并结果后返回给main.js**/ 2. CMDCMD推崇就近依赖。 –sea.js推广过程中出现的规范。但是因为在AMD&amp;CMD都是在浏览器端使用，采用的是异步加载，其实CMD还是需要在一开始就请求需要的，只是写法上更方便了。（采用的是正则匹配来获得js文件名，所以注释掉的仍然会请求，并且只可以书写字符串，不可以使用表达式）1234567891011121314151617/** AMD写法 **/define([&quot;1&quot;, &quot;2&quot;], function(1, 2) &#123; // 依赖前置 function foo()&#123; lib.log(&apos;hello world!&apos;); &#125; return &#123; foo: foo &#125;;&#125;);/** CMD写法 **/define(function(require, exports, module) &#123; var test = require(&apos;./1&apos;); //就近依赖 test.sayHi();&#125;); 3. CommonJS大前端使用的Node即时CommonJS的实例。与AMD&amp;CMD的不同之处在于CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。require参数规则: 3.1. 如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。比如，require(‘/home/marco/foo.js’)将加载/home/marco/foo.js。3.2. 如果参数字符串以“./”开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件。比如，require(‘./circle’)将加载当前脚本同一目录的circle.js。3.3. 如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块（位于Node的系统安装目录中），或者一个位于各级node_modules目录的已安装模块（全局安装或局部安装）。3.4. 如果参数字符串不以“./“或”/“开头，而且是一个路径，比如require(‘example-module/path/to/file’)，则将先找到example-module的位置，然后再以它为参数，找到后续路径。3.5. 如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索。.js件会以文本格式的JavaScript脚本文件解析，.json文件会以JSON格式的文本文件解析，.node文件会以编译后的二进制文件解析。3.6. 如果想得到require命令加载的确切文件名，使用require.resolve()方法。1234567const webpack = require(&apos;webpack&apos;);//引入const sayHi = function ()&#123; console.log(&apos;haha&apos;);&#125;module.exports = &#123; sayHi:sayHi&#125;//导出 4. ES6相对于以上的AMD&amp;CMD是用于浏览器端，CommonJS用于服务器端。ES6的模块化非常可喜可贺的是浏览器和服务器通用的模块解决方案。那它是怎么做到的呢？区别与以上三者需要在 进行时加载，ES6尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。使用：1234567ES6使用import进行引入，export default(比export更友好)进行导出。import &#123; lastName as surname &#125; from &apos;./profile.js&apos;;function foo() &#123; console.log(&apos;foo&apos;);&#125;export default foo; 作者：littleStar链接：https://juejin.im/post/5cc5909d518825253f4a5a68来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"}]},{"title":"js的有趣应用","slug":"js的有趣应用","date":"2019-04-29T14:14:53.000Z","updated":"2019-08-08T06:46:59.935Z","comments":true,"path":"2019/04/29/js的有趣应用/","link":"","permalink":"http://yongchao.tech:8080/2019/04/29/js的有趣应用/","excerpt":"","text":"打乱数组1let fn = (arr) =&gt; arr.slice().sort(() =&gt; Math.random() - 0.5) 生成随机的十六进制颜色11&apos;#&apos; + Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, &apos;0&apos;) 212Array.from(&#123;length:6&#125;,()=&gt;Math.floor(Math.random()*16).toString(16)).join(&quot;&quot;)// Array.from()的第一个参数指定了第二个参数的运行次数 数组去重1[new Set(arr)] 获取URL的查询参数1q=&#123;&#125;;location.search.replace(/([^?&amp;=]+)=([^&amp;]+)/g,(_,k,v)=&gt;q[k]=v);q; 返回一个键盘12// 用字符串返回一个键盘图形(_=&gt;[...&quot;`1234567890-=~~QWERTYUIOP[]\\\\~ASDFGHJKL;&apos;~~ZXCVBNM,./~&quot;].map(x=&gt;(o+=`/$&#123;b=&apos;_&apos;.repeat(w=x&lt;y?2:&apos; 667699&apos;[x=[&quot;BS&quot;,&quot;TAB&quot;,&quot;CAPS&quot;,&quot;ENTER&quot;][p++]||&apos;SHIFT&apos;,p])&#125;\\\\|`,m+=y+(x+&apos; &apos;).slice(0,w)+y+y,n+=y+b+y+y,l+=&apos; __&apos;+b)[73]&amp;&amp;(k.push(l,m,n,o),l=&apos;&apos;,m=n=o=y),m=n=o=y=&apos;|&apos;,p=l=k=[])&amp;&amp;k.join``)() 来源 https://juejin.im/post/5cc55eb5e51d456e577f93f0","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"}]},{"title":"全屏显示组件","slug":"全屏显示组件","date":"2019-04-29T10:29:38.000Z","updated":"2019-10-16T03:24:55.308Z","comments":true,"path":"2019/04/29/全屏显示组件/","link":"","permalink":"http://yongchao.tech:8080/2019/04/29/全屏显示组件/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;template&gt; &lt;Button type=&quot;primary&quot; @click=&quot;toggle&quot;&gt;&#123;&#123;full ? &apos;退出全屏&apos; : &apos;全屏&apos;&#125;&#125;&lt;/Button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;FullScreen&apos;, props: &#123; elem: &#123; type: HTMLDivElement, required: true &#125; &#125;, data () &#123; return &#123; full: false &#125; &#125;, methods: &#123; toggle () &#123; this.full = !this.full if (this.full) &#123; if (this.elem.requestFullscreen) &#123; this.elem.requestFullscreen() &#125; else if (this.elem.webkitRequestFullscreen) &#123; this.elem.webkitRequestFullscreen() &#125; else if (this.elem.mozRequestFullScreen) &#123; this.elem.mozRequestFullScreen() &#125; else if (this.elem.msRequestFullscreen) &#123; this.elem.msRequestFullscreen() &#125; &#125; else &#123; if (document.exitFullscreen) &#123; document.exitFullscreen() &#125; else if (document.webkitExitFullscreen) &#123; document.webkitExitFullscreen() &#125; else if (document.mozCancelFullScreen) &#123; document.mozCancelFullScreen() &#125; else if (document.msExitFullscreen) &#123; document.msExitFullscreen() &#125; &#125; this.$emit(&apos;on-change&apos;, this.full) &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.btn-con .ivu-tooltip-rel&#123; height: 64px; width: 64px; line-height: 56px;&#125;.btn-con .ivu-tooltip-rel i &#123; cursor: pointer;&#125;&lt;/style&gt;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yongchao.tech:8080/tags/vue/"},{"name":"组件","slug":"组件","permalink":"http://yongchao.tech:8080/tags/组件/"}]},{"title":"封装line和pie简单组件","slug":"封装line和pie简单组件","date":"2019-04-29T10:13:37.000Z","updated":"2019-10-16T03:24:46.109Z","comments":true,"path":"2019/04/29/封装line和pie简单组件/","link":"","permalink":"http://yongchao.tech:8080/2019/04/29/封装line和pie简单组件/","excerpt":"效果图:","text":"效果图: ChartLine.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250&lt;template&gt; &lt;Card dis-hover class=&quot;chart-item&quot; style=&quot;margin-bottom:20px&quot;&gt; &lt;template v-if=&quot;!simple&quot;&gt; &lt;div slot=&quot;title&quot; class=&quot;chart-item-title&quot;&gt; &#123;&#123; title &#125;&#125; &lt;span style=&quot;float:right&quot;&gt; &lt;slot name=&quot;extra&quot;&gt; &lt;template v-if=&quot;unit&quot;&gt; &lt;span class=&quot;desc-title&quot;&gt;单位&lt;/span&gt; &#123;&#123;unit&#125;&#125; &lt;span class=&apos;vertital-divider&apos;&gt;|&lt;/span&gt; &lt;/template&gt; &lt;/slot&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;chart-item-header&quot;&gt; &lt;slot name=&quot;operation&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; &lt;div ref=&quot;chart&quot; :class=&quot;[&apos;chart-item-content&apos;, &#123;&apos;simple&apos; : simple&#125;]&quot;&gt;&lt;/div&gt; &lt;/Card&gt;&lt;/template&gt;&lt;script&gt;import Highcharts from &apos;highcharts&apos;import HighchartsNoData from &apos;highcharts/modules/no-data-to-display&apos;import HighchartsExporting from &apos;highcharts/modules/exporting&apos;import mockData from &apos;./mock.js&apos;HighchartsNoData(Highcharts)HighchartsExporting(Highcharts)export default &#123; name: &apos;ChartItem&apos;, props: &#123; simple: &#123; type: Boolean, default: false &#125;, type: &#123; type: String, default: &apos;line&apos;, validator (val) &#123; if ([&apos;area&apos;, &apos;spline&apos;, &apos;line&apos;].indexOf(val) &gt; -1) &#123; return true &#125; else &#123; throw new Error(&apos;chart type must be oneof [line, spline, area]&apos;) &#125; &#125; &#125;, title: &#123; type: String, default: &apos;&apos; &#125;, // 图表名字 extra: Object, // 关于图表的一些其他信息 data: &#123; type: Array, required: true &#125;, unit: &#123; type: String, default: &apos;&apos; &#125;, plotLine: &#123; type: Object, default: null &#125;, notTimeStamp: &#123; type: Boolean, default: false &#125;, zoomType: &#123; type: String, default: &apos;none&apos; // 可用值 none x y xy &#125; &#125;, data () &#123; return &#123; chartInstance: null, mockData: mockData &#125; &#125;, computed: &#123; option () &#123; return &#123; chart: &#123; type: this.type, zoomType: zoomType &#125;, title: &#123; text: this.simple ? this.title : &apos;&apos;, style: &#123; fontWeight: &apos;bold&apos; &#125; &#125;, credits: &#123; text: &apos;http://xxx.com.cn&apos;, href: &apos;http://xxx.com.cn&apos; &#125;, legend: &#123; enabled: true, lineHeight: 20, maxHeight: 40 &#125;, tooltip: &#123; xDateFormat: &apos;%Y-%m-%d %H:%M&apos;, valueDecimals: 2, shared: true &#125;, xAxis: &#123; startOnTick: true, tickmarkPlacement: &apos;on&apos;, type: &apos;datetime&apos;, dateTimeLabelFormats: &#123; day: &apos;%Y/%b/%e&apos; &#125;, followPointer: true, crosshair: true &#125;, yAxis: &#123; startOnTick: true, lineWidth: 1, tickWidth: 1, title: &#123; align: &apos;middle&apos;, text: `值($&#123;this.unit&#125;)` &#125;, plotBands: [], min: this.min || null &#125;, plotOptions: &#123; series: &#123; lineWidth: 1, marker: &#123; enabled: false &#125; &#125; &#125;, exporting: &#123; enabled: true, buttons: &#123; contextButton: &#123; menuItems: [ &apos;viewFullscreen&apos;, &apos;downloadPNG&apos;, &apos;downloadJPEG&apos;, &apos;downloadPDF&apos;, &apos;downloadSVG&apos; ] &#125; &#125;, filename: this.title &#125;, series: this.innerData &#125; &#125;, innerData () &#123; if (this.notTimeStamp) &#123; return this.data.map(item =&gt; &#123; return [Date.parse(item[0]), item[1]] &#125;) &#125; else &#123; return this.data &#125; &#125; &#125;, watch: &#123; &#125;, methods: &#123; init () &#123; Highcharts.setOptions(&#123; global: &#123; useUTC: true &#125;, lang: &#123; loading: &apos;加载中...&apos;, shortMonths: [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;10&apos;, &apos;11&apos;, &apos;12&apos;], printChart: &apos;打印图表&apos;, downloadJPEG: &apos;导出jpeg&apos;, downloadPNG: &apos;导出png&apos;, downloadSVG: &apos;导出svg&apos;, downloadPDF: &apos;导出pdf&apos;, noData: &apos;暂无数据&apos;, contextButtonTitle: &apos;导出&apos;, viewFullscreen: &apos;全屏显示&apos;, viewData: &apos;表格显示数据&apos; &#125; &#125;) let option = this.option if (this.plotLine) &#123; option = Object.assign(this.option, &#123; yAxis: &#123; plotLines: [ &#123; value: this.plotLine.value, color: &apos;red&apos;, width: 2, dashStyle: &apos;solid&apos;, label: &#123; text: this.plotLine.text || &apos;&apos;, align: this.plotLine.align || &apos;left&apos;, style: &#123; color: &apos;red&apos;, fontSize: &apos;18px&apos; &#125; &#125; &#125; ] &#125; &#125;) &#125; Highcharts.chart(this.$refs.chart, option) &#125; &#125;, mounted () &#123; this.init() &#125;, beforeDestroy () &#123; this.chartInstance &amp;&amp; this.chartInstance.destroy() this.chartInstance = null &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.chart-item &#123; margin-bottom: 20px; &amp;-title &#123; font-weight: bold; height: 18px; line-height: 18px; .vertital-divider&#123; margin: 0 5px; display: inline-block; width: 1px; vertical-align: middle; color: #e8eaec; box-sizing: border-box; background: #e8eaec; &#125; .desc-title&#123; color: #888; &#125; &#125; &amp;-header &#123; text-align: right; &#125; &amp;-content &#123; height: 400px; &#125; .simple&#123; height: 446px; &#125;&#125;&lt;/style&gt; ChartPie.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184&lt;template&gt; &lt;Card dis-hover class=&quot;chart-item&quot; style=&quot;margin-bottom:20px&quot;&gt; &lt;template v-if=&quot;!simple&quot;&gt; &lt;div slot=&quot;title&quot; class=&quot;chart-item-title&quot;&gt; &#123;&#123; title &#125;&#125; &lt;span style=&quot;float:right&quot;&gt; &lt;slot name=&quot;extra&quot;&gt; &lt;template v-if=&quot;unit&quot;&gt; &lt;span class=&quot;desc-title&quot;&gt;单位&lt;/span&gt; &#123;&#123;unit&#125;&#125; &lt;span class=&apos;vertital-divider&apos;&gt;|&lt;/span&gt; &lt;/template&gt; &lt;/slot&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;chart-item-header&quot;&gt; &lt;slot name=&quot;operation&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; &lt;div ref=&quot;chart&quot; class=&quot;chart-item-content&quot;&gt;&lt;/div&gt; &lt;/Card&gt;&lt;/template&gt;&lt;script&gt;import Highcharts from &apos;highcharts&apos;import HighchartsNoData from &apos;highcharts/modules/no-data-to-display&apos;import HighchartsExporting from &apos;highcharts/modules/exporting&apos;HighchartsNoData(Highcharts)HighchartsExporting(Highcharts)export default &#123; name: &apos;ChartItem&apos;, props: &#123; simple: &#123; type: Boolean, default: false &#125;, title: String, // 图表名字 extra: Object, // 关于图表的一些其他信息 data: &#123; type: Array, required: true &#125;, unit: &#123; type: String, default: &apos;&apos; &#125; &#125;, data () &#123; return &#123; chartInstance: null &#125; &#125;, computed: &#123; // resize () &#123; // return this.$store.state.common.resize // &#125;, option () &#123; return &#123; chart: &#123; type: &apos;pie&apos; &#125;, title: &#123; text: this.simple ? this.title : &apos;&apos;, style: &#123; fontWeight: &apos;bold&apos; &#125; &#125;, credits: &#123; text: &apos;http://nevis.sina.com.cn&apos;, href: &apos;http://nevis.sina.com.cn&apos; &#125;, legend: &#123; enabled: true, lineHeight: 20, maxHeight: 40 &#125;, // 提示框 tooltip: &#123; pointFormat: &apos;&#123;series.name&#125;: &lt;b&gt;&#123;point.percentage:.2f&#125;%&lt;/b&gt;&apos; &#125;, // 数据点 plotOptions: &#123; pie: &#123; allowPointSelect: true, cursor: &apos;pointer&apos;, dataLabels: &#123; enabled: true, format: &apos;&lt;b&gt;&#123;point.name&#125;&lt;/b&gt;: &#123;point.percentage:.2f&#125; %&apos; &#125;, showInLegend: true &#125; &#125;, exporting: &#123; enabled: true, buttons: &#123; contextButton: &#123; menuItems: [ &apos;viewFullscreen&apos;, &apos;downloadPNG&apos;, &apos;downloadJPEG&apos;, &apos;downloadPDF&apos;, &apos;downloadSVG&apos; ] &#125; &#125;, filename: this.title &#125;, series: [ &#123; data: this.innerData &#125; ] &#125; &#125;, innerData () &#123; return this.data &#125; &#125;, watch: &#123; // resize () &#123; // this.chartInstance &amp;&amp; this.chartInstance.reflow() // &#125; &#125;, methods: &#123; init () &#123; Highcharts.setOptions(&#123; global: &#123; useUTC: true &#125;, lang: &#123; loading: &apos;加载中...&apos;, shortMonths: [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;10&apos;, &apos;11&apos;, &apos;12&apos;], printChart: &apos;打印图表&apos;, downloadJPEG: &apos;导出jpeg&apos;, downloadPNG: &apos;导出png&apos;, downloadSVG: &apos;导出svg&apos;, downloadPDF: &apos;导出pdf&apos;, noData: &apos;暂无数据&apos;, contextButtonTitle: &apos;导出&apos;, viewFullscreen: &apos;全屏显示&apos;, viewData: &apos;表格显示数据&apos; &#125; &#125;) Highcharts.chart(this.$refs.chart, this.option) &#125; &#125;, mounted () &#123; this.init() &#125;, beforeDestroy () &#123; this.chartInstance &amp;&amp; this.chartInstance.destroy() this.chartInstance = null &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.chart-item &#123; margin-bottom: 20px; &amp;-title &#123; font-weight: bold; height: 18px; line-height: 18px; .vertital-divider&#123; margin: 0 5px; display: inline-block; width: 1px; vertical-align: middle; color: #e8eaec; box-sizing: border-box; background: #e8eaec; &#125; .desc-title&#123; color: #888; &#125; &#125; &amp;-header &#123; text-align: right; &#125; &amp;-content &#123; height: 300px; &#125; .simple&#123; height: 346px; &#125;&#125;&lt;/style&gt; 使用12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt; &lt;div class=&quot;chart&quot;&gt; &lt;Row&gt; &lt;Col span=&quot;12&quot;&gt; &lt;chart-line :data=&quot;mockData.pie.count_tendency&quot; title=&quot;响应时间分布(simple)&quot; type=&quot;spline&quot; simple&gt;&lt;/chart-line&gt; &lt;/Col&gt; &lt;Col span=&quot;12&quot;&gt; &lt;chart-pie :data=&quot;mockData.pie.count&quot; title=&quot;响应时间分布&quot; type=&quot;spline&quot;&gt;&lt;/chart-pie&gt; &lt;/Col&gt; &lt;/Row&gt; &lt;chart-line type=&quot;spline&quot; :data=&quot;mockData.pie.count_tendency&quot; title=&quot;响应时间分布&quot; :plot-line=&quot;&#123;text: &apos;5000&apos;, value: 5000, align: &apos;right&apos;&#125;&quot; &gt;&lt;/chart-line&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import mockData from &apos;@/components/chart/mock.js&apos;import ChartLine from &apos;@/components/chart/ChartLine&apos;import ChartPie from &apos;@/components/chart/ChartPie&apos;export default &#123; name: &apos;chart&apos;, components: &#123; ChartLine, ChartPie &#125;, data () &#123; return &#123; mockData: mockData &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;.chart&#123;&#125;&lt;/style&gt;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yongchao.tech:8080/tags/vue/"},{"name":"组件","slug":"组件","permalink":"http://yongchao.tech:8080/tags/组件/"},{"name":"highcharts","slug":"highcharts","permalink":"http://yongchao.tech:8080/tags/highcharts/"}]},{"title":"vue中引入higcharts拓展模块","slug":"vue中引入higcharts拓展模块","date":"2019-04-12T19:01:37.000Z","updated":"2019-08-08T06:46:59.938Z","comments":true,"path":"2019/04/13/vue中引入higcharts拓展模块/","link":"","permalink":"http://yongchao.tech:8080/2019/04/13/vue中引入higcharts拓展模块/","excerpt":"","text":"场景vue中使用highcharts绘制图表的时候，当数据位空的时候，图表显示空白，没有问题提示，不太友好。 解决方法highcharts中存在很多拓展模块，当你引入import Highcharts from ‘highcharts’ 的时候，并没有自动引入，需手动引用.那里面又一个模块就是专门解决上述问题的，no-data-to-display模块。1234567891011121314import Highcharts from &apos;highcharts&apos;import HighchartsNoData from &apos;highcharts/modules/no-data-to-display&apos;HighchartsNoData(Highcharts)Highcharts.setOptions(&#123; global: &#123; useUTC: true &#125;, lang: &#123; loading: &apos;加载中...&apos;, shortMonths: [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;10&apos;, &apos;11&apos;, &apos;12&apos;], noData: &apos;暂无数据&apos; //指定无数据时的文字提示 &#125;&#125;) 结果如下","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yongchao.tech:8080/tags/vue/"},{"name":"graph","slug":"graph","permalink":"http://yongchao.tech:8080/tags/graph/"}]},{"title":"js中的this机制","slug":"js中的this机制","date":"2019-04-08T20:01:38.000Z","updated":"2019-08-08T06:46:59.934Z","comments":true,"path":"2019/04/09/js中的this机制/","link":"","permalink":"http://yongchao.tech:8080/2019/04/09/js中的this机制/","excerpt":"概念this是函数 ( 运行时,即指的是被调用时 )的上下文， 指向调用它的 (最近的上下文)。 绑定规则 函数绑定 new绑定 箭头函数绑定","text":"概念this是函数 ( 运行时,即指的是被调用时 )的上下文， 指向调用它的 (最近的上下文)。 绑定规则 函数绑定 new绑定 箭头函数绑定 1.函数调用JS（ES5）里面有三种函数调用形式：123func(p1, p2) obj.child.method(p1, p2)func.call(context, p1, p2) // 先不讲 apply 一般，初学者都知道前两种形式，而且认为前两种形式「优于」第三种形式。从看到这篇文章起，你一定要记住，第三种调用形式，才是正常调用形式：1func.call(context, p1, p2) 其他两种都是语法糖，可以等价地变为 call 形式：12345func(p1, p2) 等价于func.call(undefined, p1, p2)obj.child.method(p1, p2) &lt;=&gt;obj.child.method.call(obj.child, p1, p2) 请记下来。（我们称此代码为「转换代码」，方便下文引用）至此我们的函数调用只有一种形式：1func.call(context, p1, p2) 举些其他例子：123456789101112131415var a= &#123; name: &apos;XXX&apos;, xxx: function () &#123; console.log(this) &#125;&#125;function xxx() &#123; console.log(this)&#125;(b = a.xxx)()&lt;=&gt; var b = a.xxx.bind(undefined); b()(a.xxx)()&lt;=&gt; a.xxx() Dom元素绑定事件时的thisMDN这样解释： 通常来说this的值是触发事件的元素的引用，这种特性在多个相似的元素使用同一个通用事件监听器时非常让人满意。当使用 addEventListener() 为一个元素注册事件的时候，句柄里的 this 值是该元素的引用。其与传递给句柄的 event 参数的 currentTarget 属性的值一样。这种this绑定时浏览器内置的，不方便看，但可以假想为：123456var button = document.getElementById(&quot;btn)button.addEventListener(&apos;click&apos;, handlder)// 当事件被触发时handler.call(event.currentTarget, event) // 那么 this 是什么不言而喻 2.new绑定使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。1、创建（或者说构造）一个新的临时对象。2、指定原型。3、返回这个新对象(这个新对象会绑定到函数调用的this)。4、给原型指定名字为prototype 手写一个new实现12345678910111213141516171819function Person() &#123; // 1. 创建一个空的对象 var obj = new Object(), // 2. 链接到原型，obj 可以访问到构造函数原型中的属性 // 获得构造函数，arguments中去除第一个参数(构造函数) obj.__proto__ = Person.prototype; obj.__proto__.constructor = Person // 3. var ret = Person.apply(obj, arguments); return ret instanceof Object ? ret : obj;&#125;;//4.Person.prototype = &#123; constructor: null&#125; 3.箭头函数ES6新增一种特殊函数类型：箭头函数,根据外层（函数或者全局）作用域（词法作用域）来决定this。 foo()内部创建的箭头函数会捕获调用时foo()的this。由于foo()的this绑定到obj1，bar(引用箭头函数)的this也会绑定到obj1，箭头函数的绑定无法被修改(new也不行)。123456789101112131415function foo() &#123; // 返回一个箭头函数 return (a) =&gt; &#123; // this继承自foo() console.log( this.a ); &#125;;&#125;var obj1 = &#123; a: 2&#125;;var obj2 = &#123; a: 3&#125;var bar = foo.call( obj1 );bar.call( obj2 ); // 2，不是3！ ES6之前和箭头函数类似的模式，采用的是词法作用域取代了传统的this机制。12345678910function foo() &#123; var self = this; // lexical capture of this setTimeout( function() &#123; console.log( self.a ); // self只是继承了foo()函数的this绑定 &#125;, 100 );&#125;var obj = &#123; a: 2&#125;;foo.call(obj); // 2 代码风格统一问题：如果既有this风格的代码，还会使用 seft = this 或者箭头函数来否定this机制。 只使用词法作用域并完全抛弃错误this风格的代码； 完全采用this风格，在必要时使用bind(..)，尽量避免使用 self = this 和箭头函数。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"}]},{"title":"webpack","slug":"webpack","date":"2019-04-04T19:04:19.000Z","updated":"2019-08-08T06:46:59.939Z","comments":true,"path":"2019/04/05/webpack/","link":"","permalink":"http://yongchao.tech:8080/2019/04/05/webpack/","excerpt":"安装1npm install webpack webpack-cli webpack-dev-server -D 1.基本配置 webpack.config.js当在项目中直接运行webpack时，默认读取webpack.config.js中的配置，等同于运行 webpack webpack.config.js123456789101112131415161718192021222324252627282930313233343536373839404142434445const path = require(&apos;path&apos;);const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;) //自动生成htmlmodule.exports = &#123; mode: &apos;development&apos;, // 可选development|production entry: path.join(__dirname, &apos;src&apos;, &apos;main.js&apos;), watch: true, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), publicPath: &apos;&apos;, // js 路径为public + path + filename filename: &quot;main.js&quot;, chunkFilename: &apos;[name].js&apos; &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, // css-loader 导入css // style-loader 将css插入到style标签中 use: [&apos;style-loader&apos;, &apos;css-loader&apos;] &#125;, &#123; test: /\\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] &#125;, &#123; test: /\\.html$/, // 导入 html use: [&apos;html-loader&apos;] &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; filename: &apos;index.html&apos;, template: &apos;index.html&apos; &#125;) ], devtool: &apos;source-map&apos;, devServer: &#123; contentBase: path.join(&apos;/dist/&apos;), inline: true, host: &apos;127.0.0.1&apos;, port: 3000, &#125;&#125;;","text":"安装1npm install webpack webpack-cli webpack-dev-server -D 1.基本配置 webpack.config.js当在项目中直接运行webpack时，默认读取webpack.config.js中的配置，等同于运行 webpack webpack.config.js123456789101112131415161718192021222324252627282930313233343536373839404142434445const path = require(&apos;path&apos;);const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;) //自动生成htmlmodule.exports = &#123; mode: &apos;development&apos;, // 可选development|production entry: path.join(__dirname, &apos;src&apos;, &apos;main.js&apos;), watch: true, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), publicPath: &apos;&apos;, // js 路径为public + path + filename filename: &quot;main.js&quot;, chunkFilename: &apos;[name].js&apos; &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, // css-loader 导入css // style-loader 将css插入到style标签中 use: [&apos;style-loader&apos;, &apos;css-loader&apos;] &#125;, &#123; test: /\\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] &#125;, &#123; test: /\\.html$/, // 导入 html use: [&apos;html-loader&apos;] &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; filename: &apos;index.html&apos;, template: &apos;index.html&apos; &#125;) ], devtool: &apos;source-map&apos;, devServer: &#123; contentBase: path.join(&apos;/dist/&apos;), inline: true, host: &apos;127.0.0.1&apos;, port: 3000, &#125;&#125;; 2.html处理html-webpack-plugin: 可以指定模版生成html,并可以进行去除双引号、折叠空白符号之类的操作12345678910111213const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)plugins: [ new HtmlWebpackPlugin(&#123; template: &apos;./src/index.html&apos;, filename: &apos;index.html&apos;, minify: &#123; removeAttributeQuotes: true, collapseInlineTagWhitespace: true &#125;, hash: true &#125;)] 3.样式处理3.1基本设置123456789101112131415161718module: &#123; rules: [ &#123; test: /\\.css$/, use: [&#123; // 插入到style中 loader: &apos;style-loader&apos;, options: &#123; insertAt: &apos;bottom&apos; &#125; &#125;, &apos;css-loader&apos;] &#125;, &#123; test: /\\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] &#125; ]&#125; 3.2 将所有的样式抽离到一个css文件12345678910111213141516const MiniCssExtractPlugin= require(&apos;mini-css-extract-plugin&apos;)module: &#123; rules: [ &#123; test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, &apos;css-loader&apos;] &#125;, &#123; test: /\\.less$/, use: [MiniCssExtractPlugin.loader, &apos;css-loader&apos;, &apos;less-loader&apos;] &#125; ]&#125; 3.3 将样式自动添加前缀123456789101112131415161718192021222324cnpm install postcss-loader autoprefixer// webpack.config.jsmodule: &#123; rules: [ &#123; test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, &apos;css-loader&apos;, &apos;postcss-loader&apos;] &#125;, &#123; test: /\\.less$/, use: [MiniCssExtractPlugin.loader, &apos;css-loader&apos;, &apos;postcss-loader&apos;, &apos;less-loader&apos;] &#125; ]&#125;// postcss.config.jsmodule.exports = &#123; plugins: [ require(&apos;autoprefixer&apos;) ]&#125; 3.4 production 压缩css12345678910const OptimizeCSSAssetsPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;);module.exports = &#123; optimization: &#123; minimizer: [ new OptimizeCSSAssetsPlugin() ] &#125;, mode: &apos;production&apos;, // production | development&#125; 3.5 production 压缩js123456789101112131415cnpm install uglifyjs-webpack-plugin -D const UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;); //压缩jsmodule.exports = &#123; optimization: &#123; //优化项 minimizer: [ new UglifyWebpackplugin(&#123; test: /\\.js(\\?.*)?$/i, cache: true, // 是否并行处理 parallel: true, sourceMap: true &#125;) ] &#125;&#125; 4. 转换es6语法以及校验12345678910111213141516171819202122232425262728293031323334cnpm install babel-loader @babel/core @babel/preset-env -Dmodule.exports = &#123; entry: [&quot;@babel/polyfill&quot;, &quot;./src/main.js&quot;], module:[ &#123; test: /\\.js$/, include: path.resolve(__dirname, &apos;src&apos;), exclude: /node_modules/, use: &#123; loader: &apos;babel-loader&apos;, options: &#123; presets: [ &apos;@babel/preset-env&apos; ], plugins: [ &quot;@babel/plugin-proposal-class-properties&quot;, &quot;@babel/plugin-transform-runtime&quot; //根据自己的需求自行添加 ] &#125; &#125; &#125;, &#123; test: /\\.js$/, use: &#123; loader: &apos;eslint-loader&apos;, options: &#123; enfore: &apos;pre&apos; &#125; &#125; &#125;]&#125; 5. 全局变量引入的问题(以jquery为例) 全局loader expose-loader 前置loder 普通loader 内联loader 后置loader postcss-loader 5.1 import $ from ‘jquery’ 时1234module = [ test: require.resove(&apos;jquery&apos;), use:&apos;expose-loader?$&apos;] 5.2 将$注入到每一个模块中去，在模块中可以直接使用$123456const webpack = require(&apos;webpack&apos;)plugins: [ new webpack.ProvidePlugin(&#123; $: &apos;jquery&apos; &#125;)], 6.处理图片6.1 处理css，js中的图片引用123456module: [ &#123; test: /.(jpg|jpeg|png|gif|svg)$/, use:&apos;file-loader&apos; &#125;] 6.2 处理html中引入的图片123456module: [ &#123; test: /.html$/, use:&apos;html-withimg-loader&apos; &#125;] 6.3 将小的图片转成base64，减少http请求1234567891011module: [ &#123; loader: &apos;url-loader&apos;, options: &#123; // 小于50k的图片转成base64 limit: 50 * 1024, // 50k name: &apos;[hash:8].[ext]&apos;, outputPath: &apos;./images&apos; &#125; &#125;] 7.打包文件分类12345678910111213141516171819202122232425//imgmodule: [ &#123; loader: &apos;url-loader&apos;, options: &#123; // 小于50k的图片转成base64 limit: 50 * 1024, // 50k name: &apos;[hash:8].[ext]&apos;, outputPath: &apos;/images/&apos;, //图片打包到images下 //打包后为图片的引入路径前添加url前缀，可以在需要将图片使用cdn的时候用（和其他文件的publicPath不同） //publicPath: &apos;http://www.xxxcdn.com/&apos; &#125; &#125;]//cssplugins: [ new MiniCss(&#123; filename: &apos;css/main.css&apos; // 会将css文件打包为 dist/css/main.css &#125;),]// jsoutput: &#123; filename: &apos;js/main.js&apos;&#125;","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yongchao.tech:8080/tags/webpack/"}]},{"title":"伪类确定元素数量","slug":"伪类确定元素数量","date":"2019-03-30T11:48:10.000Z","updated":"2019-08-08T06:46:59.940Z","comments":true,"path":"2019/03/30/伪类确定元素数量/","link":"","permalink":"http://yongchao.tech:8080/2019/03/30/伪类确定元素数量/","excerpt":"","text":"原理12li:first-child:nth-last-child(n)&#123;&#125; 选中的li既是第一个元素也是倒数第n个元素，这就表明了一共有n个li元素代码链接https://codepen.io/xuyongchaos/pen/vMBLpY","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yongchao.tech:8080/tags/css/"}]},{"title":"前端入门--001","slug":"前端入门-001","date":"2019-03-28T19:55:17.000Z","updated":"2019-08-08T06:46:59.940Z","comments":true,"path":"2019/03/29/前端入门-001/","link":"","permalink":"http://yongchao.tech:8080/2019/03/29/前端入门-001/","excerpt":"htnl标签分类 block 块级标签 特点： 一行一个元素，有空间属性（可设置height, width）例如：div、h、section inline 内联标签 特点： 一行可多个元素，无空间属性 例如：span 、b、em、strong inline-block 特点： 一行可多个元素，有空间属性（可设置height, width）例如：img table 123456&lt;table&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;thead&gt;&lt;/thead&gt; &lt;tbody&gt;&lt;/tbody&gt; &lt;tfoot&gt;&lt;/tfoot&gt;&lt;/table&gt; 基本概念每一个或者每一对标签称之为元素(element),元素中有属性(attribute)和事件(event), 还可以在style中定义csss属性123&lt;a href=&quot;http://www.baidu.com&quot; onclick=&quot;handleClick()&quot; style=&quot;color:blue&quot;&gt;链接文字&lt;/a&gt;&lt;a&gt;&lt;/a&gt;就是一个元素，href就是属性， onclick就是事件, style=&quot;color:blue&quot; 设置文字为蓝色 css引入Css的几种方式1231. &lt;link href=&quot;&quot;&gt;2. &lt;style&gt;&lt;/style&gt;3. 元素的style=&quot;&quot; 颜色1.rgb(0-255,0-255,0-255) red green blue2.rgba(0-255,0-255,0-255, 0-1) red green blue alpha(透明度)3.#AD2342 或者 #3df(#33ddff的缩写)","text":"htnl标签分类 block 块级标签 特点： 一行一个元素，有空间属性（可设置height, width）例如：div、h、section inline 内联标签 特点： 一行可多个元素，无空间属性 例如：span 、b、em、strong inline-block 特点： 一行可多个元素，有空间属性（可设置height, width）例如：img table 123456&lt;table&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;thead&gt;&lt;/thead&gt; &lt;tbody&gt;&lt;/tbody&gt; &lt;tfoot&gt;&lt;/tfoot&gt;&lt;/table&gt; 基本概念每一个或者每一对标签称之为元素(element),元素中有属性(attribute)和事件(event), 还可以在style中定义csss属性123&lt;a href=&quot;http://www.baidu.com&quot; onclick=&quot;handleClick()&quot; style=&quot;color:blue&quot;&gt;链接文字&lt;/a&gt;&lt;a&gt;&lt;/a&gt;就是一个元素，href就是属性， onclick就是事件, style=&quot;color:blue&quot; 设置文字为蓝色 css引入Css的几种方式1231. &lt;link href=&quot;&quot;&gt;2. &lt;style&gt;&lt;/style&gt;3. 元素的style=&quot;&quot; 颜色1.rgb(0-255,0-255,0-255) red green blue2.rgba(0-255,0-255,0-255, 0-1) red green blue alpha(透明度)3.#AD2342 或者 #3df(#33ddff的缩写) 长度单位1.px2.em 相当于父元素font-size的倍数3.rem 相当于HTML根元素的font-size的倍数 选择器123456781. * 通配符选择器 （匹配所有元素）2. Tag&#123;&#125; 标签选择器， 例如: p&#123;&#125;匹配所有的p元素3. id选择器 PS: #id4. class选择器 ps: .class5. [attr=&apos;value&apos;] 属性选择器， ps: [type=&quot;number&quot;] 匹配到所有的type属性值为number的元素6. :focus 匹配到所有获得焦点的元素7. :checked 匹配到所有的被选中(例如checkbox , radio)的元素8. 其他... 选择器关系 祖先关系： 祖先选择器 子孙选择器 父子关系： 父元素&gt;子元素 相邻兄弟选择器： 可选择紧接在另一元素后的元素，且二者有相同父元素。例如： h1 + p{} 选择出h1后面紧跟着的p元素 通过css的display属性设置元素的类型 display: block; 将元素设置为block元素 display: inline; 将元素设置为inline元素 display: inline-block; 将元素设置为inline-block元素 盒子模型每一个元素都存在一个盒子模型：从内到外: content + padding + border + margin","categories":[],"tags":[{"name":"前端入门","slug":"前端入门","permalink":"http://yongchao.tech:8080/tags/前端入门/"}]},{"title":"执行栈和执行上下文","slug":"执行栈和执行上下文","date":"2019-03-26T09:57:17.000Z","updated":"2019-08-08T06:46:59.941Z","comments":true,"path":"2019/03/26/执行栈和执行上下文/","link":"","permalink":"http://yongchao.tech:8080/2019/03/26/执行栈和执行上下文/","excerpt":"执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。 执行上下文的类型执行上下文总共有三种类型 1.全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象。 2.函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。 3.Eval 函数执行上下文： 指的是运行在 eval 函数中的代码，不用很少用而且不建议使用。 执行栈执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。 首次运行JS代码时，会创建一个全局执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push到当前执行栈的栈顶。 根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的下一个执行上下文。 执行上下文的创建执行上下文分两个阶段创建：1）创建阶段； 2）执行阶段 创建阶段 1、确定 this 的值，也被称为 This Binding。 2、LexicalEnvironment（词法环境） 组件被创建。 3、VariableEnvironment（变量环境） 组件被创建。 直接看伪代码可能更加直观12345ExecutionContext = &#123; ThisBinding = &lt;this value&gt;, // 确定this LexicalEnvironment = &#123; ... &#125;, // 词法环境 VariableEnvironment = &#123; ... &#125;, // 变量环境&#125;","text":"执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。 执行上下文的类型执行上下文总共有三种类型 1.全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象。 2.函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。 3.Eval 函数执行上下文： 指的是运行在 eval 函数中的代码，不用很少用而且不建议使用。 执行栈执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。 首次运行JS代码时，会创建一个全局执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push到当前执行栈的栈顶。 根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的下一个执行上下文。 执行上下文的创建执行上下文分两个阶段创建：1）创建阶段； 2）执行阶段 创建阶段 1、确定 this 的值，也被称为 This Binding。 2、LexicalEnvironment（词法环境） 组件被创建。 3、VariableEnvironment（变量环境） 组件被创建。 直接看伪代码可能更加直观12345ExecutionContext = &#123; ThisBinding = &lt;this value&gt;, // 确定this LexicalEnvironment = &#123; ... &#125;, // 词法环境 VariableEnvironment = &#123; ... &#125;, // 变量环境&#125; This Binding全局执行上下文中，this 的值指向全局对象，在浏览器中this 的值指向 window对象，而在nodejs中指向这个文件的module对象。 函数执行上下文中，this 的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显式绑定（硬绑定）、new绑定、箭头函数，具体内容会在【this全面解析】部分详解。 词法环境（Lexical Environment） Global code:通俗点讲就是源文件代码，就是一个词法环境 函数代码 ：一个函数块内自己是一个新的词法环境 eval：进入eval调用的代码有时会创建一个新的词法环境 with结构：一个with结构块内也是自己一个词法环境 catch结构：一个catch结构快内也是自己一个词环境 读到这里有些小伙伴急了，“不对，不对，我记得只有在全局代码、函数代码、和eval代码三种情况，才会创建运行上下文，你专门有5种”。对，你说的没错，只有在全局代码、函数代码、和eval代码三种情况，才会创建运行上下文，但我这里说的是词法环境，Lexical Environments。不是运行上下文。 作者：G哥讲码堂链接：https://juejin.im/post/5c05120be51d4513416d2111来源：掘金 词法环境有两个组成部分 1、环境记录：存储变量和函数声明的实际位置 环境记录分为两种 declarative environment records 主要用于函数 、catch词法环境 object environment records. 主要用于with 和global的词法环境 declarative environment records可以简单理解为字典类型的结构，key-value形式结论变量等对应的名字和值。 而object environment records会关联一个对象，用这个对象的属性-值来登记变量等对应的名字和值。 2、对外部环境的引用：可以访问其外部词法环境 词法环境有两种类型 1、全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null。拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，this 的值指向这个全局对象。 2、函数环境：用户在函数中定义的变量被存储在环境记录中，包含了arguments 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。 直接看伪代码可能更加直观1234567891011121314151617GlobalExectionContext = &#123; // 全局执行上下文 LexicalEnvironment: &#123; // 词法环境 EnvironmentRecord: &#123; // 环境记录 Type: &quot;Object&quot;, // 全局环境 // 标识符绑定在这里 outer: &lt;null&gt; // 对外部环境的引用 &#125; &#125;FunctionExectionContext = &#123; // 函数执行上下文 LexicalEnvironment: &#123; // 词法环境 EnvironmentRecord: &#123; // 环境记录 Type: &quot;Declarative&quot;, // 函数环境 // 标识符绑定在这里 // 对外部环境的引用 outer: &lt;Global or outer function environment reference&gt; &#125; &#125; 变量环境变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。 在 ES6 中，词法 环境和 变量 环境的区别在于前者用于存储函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）绑定。 使用例子进行介绍1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859let a = 20; const b = 30; var c;function multiply(e, f) &#123; var g = 20; return e * f * g; &#125;c = multiply(20, 30);执行上下文如下所示GlobalExectionContext = &#123; ThisBinding: &lt;Global Object&gt;, LexicalEnvironment: &#123; EnvironmentRecord: &#123; Type: &quot;Object&quot;, // 标识符绑定在这里 a: &lt; uninitialized &gt;, b: &lt; uninitialized &gt;, multiply: &lt; func &gt; &#125; outer: &lt;null&gt; &#125;, VariableEnvironment: &#123; EnvironmentRecord: &#123; Type: &quot;Object&quot;, // 标识符绑定在这里 c: undefined, &#125; outer: &lt;null&gt; &#125; &#125;FunctionExectionContext = &#123; ThisBinding: &lt;Global Object&gt;, LexicalEnvironment: &#123; EnvironmentRecord: &#123; Type: &quot;Declarative&quot;, // 标识符绑定在这里 Arguments: &#123;0: 20, 1: 30, length: 2&#125;, &#125;, outer: &lt;GlobalLexicalEnvironment&gt; &#125;, VariableEnvironment: &#123; EnvironmentRecord: &#123; Type: &quot;Declarative&quot;, // 标识符绑定在这里 g: undefined &#125;, outer: &lt;GlobalLexicalEnvironment&gt; &#125; &#125; 变量提升的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined（在 var 的情况下）或保持未初始化（在 let 和 const 的情况下）。所以这就是为什么可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。 执行阶段此阶段，完成对所有变量的分配，最后执行代码。 如果 Javascript 引擎在源代码中声明的实际位置找不到 let 变量的值，那么将为其分配 undefined 值。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"}]},{"title":"vue实现文件下载","slug":"vue实现文件下载","date":"2019-03-21T10:45:33.000Z","updated":"2019-08-08T06:46:59.938Z","comments":true,"path":"2019/03/21/vue实现文件下载/","link":"","permalink":"http://yongchao.tech:8080/2019/03/21/vue实现文件下载/","excerpt":"","text":"原理1&lt;a href=&quot;url&quot; download=&quot;文件名.后缀名&quot;&gt; 实际使用场景上面的原理中适合开放的资源下载，http请求中无需验证时使用。在实际使用过程中，a标签中的url中直接设置header比较麻烦且不安全，而且从开发规范上api一般上要封装一下（header中需要一些特定设置），放到统一的文件。 解决办法：下载相关和api responseType设置为blob(!!!重要)，在以blob形式获取到文件之后js创建一个a标签，设置url和downlaod后并触发，最后释放url资源并删除创建的a标签123456789101112131415161718192021222324252627282930313233343536373839404142api:downloadFile (url) =&gt; &#123; axios.get(url, &#123; params: &#123; &#125;, headers: &#123; &#125;, // 重要 responseType: &apos;blob&apos; &#125;)&#125;html: &lt;button @click=&quot;download&quot;&gt;下载&lt;/button&gt;js: function downlaod (param)&#123; api.downloadFile(param).then(data =&gt; &#123; if (!data) &#123; this.$Message.error(&apos;下载内容为空&apos;) return &#125; let url = window.URL.createObjectURL(new Blob([data])) let link = document.createElement(&apos;a&apos;) link.style.display = &apos;none&apos; link.href = url link.setAttribute(&apos;download&apos;, etcdCluster + &apos;.zip&apos;) document.body.appendChild(link) link.click() //释放URL对象所占资源 window.URL.revokeObjectURL(url) //用完即删 document.body.removeChild(link) &#125;).catch(err =&gt; &#123; console.log(&apos;err: &apos;, err) &#125;) &#125; MDN相关链接https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURLhttps://developer.mozilla.org/zh-CN/docs/Web/API/URL/revokeObjectURL","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yongchao.tech:8080/tags/vue/"},{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"}]},{"title":"js自定义modal框","slug":"js自定义modal框","date":"2019-03-17T20:55:41.000Z","updated":"2019-08-08T06:46:59.935Z","comments":true,"path":"2019/03/18/js自定义modal框/","link":"","permalink":"http://yongchao.tech:8080/2019/03/18/js自定义modal框/","excerpt":"前言作为一个Web开发而言，modal模态框一定不会陌生。本文将简单的讲一下如何使用js自定义一个modal框，当然了，本文的重点并不是教你如何构建一个modal框，而是希望能够教你如何构建一个组件的思路。好了，废话不多说，正文开始。 modal是什么，有什么功能modal是位于用户主窗口之上的一个元素，当它打开的时候，主窗口无法操作，位于主窗口之上的modal框内可以操作。一个modal至少包含以下几个功能： 模态框的蒙版 .modal-overlay 头部 .modal-header 主体 .modal-body 脚步 .modal-footer 关闭按钮 .modal-close 关闭按钮包括多种方式：取消按钮（footer中）、关闭按钮(右上角)、ESC按键、点击模态框主体外的蒙版的区域 构建插件1.首先选择iife。这里使用了闭包的知识，因为闭包可以创建一个私有域。","text":"前言作为一个Web开发而言，modal模态框一定不会陌生。本文将简单的讲一下如何使用js自定义一个modal框，当然了，本文的重点并不是教你如何构建一个modal框，而是希望能够教你如何构建一个组件的思路。好了，废话不多说，正文开始。 modal是什么，有什么功能modal是位于用户主窗口之上的一个元素，当它打开的时候，主窗口无法操作，位于主窗口之上的modal框内可以操作。一个modal至少包含以下几个功能： 模态框的蒙版 .modal-overlay 头部 .modal-header 主体 .modal-body 脚步 .modal-footer 关闭按钮 .modal-close 关闭按钮包括多种方式：取消按钮（footer中）、关闭按钮(右上角)、ESC按键、点击模态框主体外的蒙版的区域 构建插件1.首先选择iife。这里使用了闭包的知识，因为闭包可以创建一个私有域。 123(function()&#123; var 私有变量 = 值&#125;)() 2.设置选项（options）1234567891011121314151617181920212223242526272829&lt;!-- 设置一个windo中可以访问的函数 --&gt;this.Modal = function() &#123; this.modal = null; // 模态弹出框 this.overlay = null; //蒙板 this.closeButton = null; // 右上角关闭按钮 this.footerCloseButton = null //footer关闭按钮 this.options = &#123; className: &apos;fade-and-drop&apos;, content: &apos;这是一个自定义的模态框&apos;, minHeight: &apos;300px&apos;, maxHeight: &apos;600px&apos;, closable: true, // 是否可关闭，决定着是否有关闭按钮 overlay: true &#125;; // 合并默认设置和用户自定义设置，用户自定义配置&gt;默认配置 if (arguments[0] &amp;&amp; typeof arguments[0] === &apos;object&apos;) &#123; this.options = mergeOptions(this.options, arguments[0]); &#125;&#125;;//合并对象属性的工具方法function mergeOptions(target, source) &#123; for (let property in source) &#123; if (source.hasOwnProperty(property)) &#123; target[property] = source[property]; &#125; &#125; return target;&#125; 3. 核心功能 现在我们对模态框的插件架构有了一定的了解，它包括了：构造函数、选项和公共方法。但它还不能做什么？接下来我们就要给他们添加相应的核心功能。所以我们再来看看，一个模态框应该做什么： 构建一个模态元素并将其添加到页面中 将选项（options）中的className指定一个类名，并将其添加到模态元素中 如果选项中的closeButton为true，则添加关闭按钮 如果选项中的content是 HTML 字符串，则将其设置为模态元素中的内容 如果选项中的content是domNode，则将其内部内容设置为模态元素的内容 分别设置模态的maxWidth和minWidth 如果选项中的overlay为true，则给模态框添加一个蒙层 当模态框显示时，添加一个scotch-open类名，可以在 CSS 中使用它来定义一个open状态 当模态框关闭时，删除scotch-open类名 如果模态框的高度超过视窗的高度，还可以添加一个scotch-anchored类，这样就可以处理这个场景的样式展示 代码思路12345678910111213141516171819202122232425262728293031323334353637(function()&#123; //构造函数 this.Modal = function () &#123; // 初始化默认option， this.options = &#123; &#125; //合并用户自定义配置和默认配置，并赋值给options, 每个实例都可能不一样，所有不能放在prototype上，同时在其它函数中又要引用它，所有定义为公有属性 this.options = mergeOptions(this.options, arguments[0]) &#125; // 打开Modal的方法,每个实例中的这个方法都是一样的,定义在prototype上 Modal.prototype.open = function()&#123; // 初始化Dom 1.overlay蒙版元素 2.modal元素&#123; close按钮 content footer &#125; // 初始化Event 包括：&#123; close事件 transitionEnd事件(关闭按钮中Css使用了过渡动画，等过渡动画完成之后才能移除dom)，需要注意的就是不同的的浏览器中这个时间的名字可能不一样 &#125; &#125; //关闭方法 Modal.prototype.close = function()&#123; //移除Dom &#125;&#125;)() !!!!完整的代码链接 https://codepen.io/xuyongchaos/pen/aMGXLy?editors=1010使用到的东西 闭包 DocumentFragment 如何减少浏览器回流 DOM操作 DOM事件 this相关call, bind css样式 总结：编写一个简单的插件需要的知识还是挺多的，没事的话可以自己编写一下，不仅锻炼了模块化编程思维，还可以对以前的知识进行查缺补漏。fighting!!!","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"}]},{"title":"从js的属性描述符描述vue.js的响应式视图","slug":"从js的属性描述符描述vue-js的响应式视图","date":"2019-03-15T19:57:05.000Z","updated":"2019-09-15T15:39:47.883Z","comments":true,"path":"2019/03/16/从js的属性描述符描述vue-js的响应式视图/","link":"","permalink":"http://yongchao.tech:8080/2019/03/16/从js的属性描述符描述vue-js的响应式视图/","excerpt":"前言JavaScript 的对象，拥有任意数量的唯一键，键可以是字符串（String）类型或标记（Symbol，ES6 新增的基本数据类型）类型，每个键对应一个值，值可以是任意类型的任意值。对于对象内的属性，JavaScript 提供了一个属性描述器接口 PropertyDescriptor 定义对象的属性123456789var obj = &#123; name: &apos;Tom&apos;, sex: &apos;man&#125;orvar obj = &#123;&#125;obj.name = &apos;Tom&apos; Object.defineProperty()上面使用的方式不能对属性描述符的操作，需要使用 Object.ddefineProperty(obj, prop, descriptor) 当使用 defineProperty()方法操作属性的时候，描述符的默认值为： value: undefined set: undefined get: undefined writable: false enumerable: false configable: false 不使用该方法定义属性，默认值为： value: undefined set: undefined get: undefined writable: true enumerable: true configable: true 还支持批量修改对象属性以及描述对象123456789Object.defineProperties(obj, &#123; name: &#123; value: &apos;Tom&apos;, configable: true &#125;, sex: &#123; value: &apos;man&apos; &#125;&#125;)","text":"前言JavaScript 的对象，拥有任意数量的唯一键，键可以是字符串（String）类型或标记（Symbol，ES6 新增的基本数据类型）类型，每个键对应一个值，值可以是任意类型的任意值。对于对象内的属性，JavaScript 提供了一个属性描述器接口 PropertyDescriptor 定义对象的属性123456789var obj = &#123; name: &apos;Tom&apos;, sex: &apos;man&#125;orvar obj = &#123;&#125;obj.name = &apos;Tom&apos; Object.defineProperty()上面使用的方式不能对属性描述符的操作，需要使用 Object.ddefineProperty(obj, prop, descriptor) 当使用 defineProperty()方法操作属性的时候，描述符的默认值为： value: undefined set: undefined get: undefined writable: false enumerable: false configable: false 不使用该方法定义属性，默认值为： value: undefined set: undefined get: undefined writable: true enumerable: true configable: true 还支持批量修改对象属性以及描述对象123456789Object.defineProperties(obj, &#123; name: &#123; value: &apos;Tom&apos;, configable: true &#125;, sex: &#123; value: &apos;man&apos; &#125;&#125;) 读取属性描述符对象 Object.getOwnPropertyDescriptor(obj,prop)属性描述符对象value 属性的值存储器函数（setter/getter）1.get2.set 123456789101112var x = &#123;&#125;Object.defineProperty(x, &apos;count&apos;, &#123; get: funciton () &#123; return this.value &#125;, set: function (val) &#123; this.count = val &#125; &#125;)console.log(x) x.count = 1 console.log(x.count) 执行上面的代码，会发现报错，执行栈溢出。 上述代码在执行set 函数中执行 count赋值操作的时候(this.count = val)，循环调用自己，形成了死循环。更改为以下代码：123456789101112var x = &#123;&#125;Object.defineProperty(x, &apos;count&apos;, &#123; get: () &#123; return this._count &#125; set: function (val) &#123; this._count = val &#125;&#125;)console.log(x) x.count = 1 console.log(x.count) 实际上，在使用 defineProperty()方法设置对象的属性的时候，通常需要在对象内部维护一个新的内部变量(以下划线_开头，表示为内部变量) 注：当设置了存取器描述时，不能设置value 和writable, 可以当作没有这两个属性 writable 指定对象的value是否可以改变enumerable 指定对象中的某属性是否可以枚举，就是for in 操作是否可以遍历出来configable 指定对象属性的描述符是否可以改变","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yongchao.tech:8080/tags/vue/"},{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"}]},{"title":"stringify的使用","slug":"stringify的使用","date":"2019-03-13T14:34:07.000Z","updated":"2019-08-08T06:46:59.936Z","comments":true,"path":"2019/03/13/stringify的使用/","link":"","permalink":"http://yongchao.tech:8080/2019/03/13/stringify的使用/","excerpt":"","text":"这篇文章的由来是这样的：前两天遇到这样一个场景，接口返回了一个json对象，要求我进行格式化显示（显示出json对象的结构）。那么我就想了，一个对象要想显示出来，得转成string 类型的，于是我就使用了JSON.stringify(),但是转成字符串之后并没有缩进，显示出来的是一个长长的字符串。难道我还要自己人为的遍历对象,自己拼接一个带缩进的字符串么？太TM扯了！于是查看了stringify的官方文档，发现了很多有意思的东西，这个函数的作用远远不止是将json对象转成string那么简单，下面是我列举的stringify的几个小功能: json格式化，带缩进 过滤掉无效的字段 对符合某种条件的字段做操作 原始数据12345678person = &#123; sex: &apos;man&apos;, name: &apos;Tom&apos;, telphones: [ &quot;234123423&quot;, &quot;2345234523&quot; ]&#125; 一、原始情况，直接显示json字符串 code:1JOSN.stringify(person) 运行结果：1&#123;&quot;sex&quot;:&quot;man&quot;,&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:22,&quot;telphones&quot;:[&quot;2341234123&quot;,&quot;3452345&quot;]&#125; 二、将一个json对象格式化显示出来 code:1JSON.stringify(person, null, 2) 运行结果：12345678&#123; sex: &apos;man&apos;, name: &apos;Tom&apos;, telphones: [ &quot;234123423&quot;, &quot;2345234523&quot; ] &#125; 三、不显示某些字段（哪些字段不需要显示就返回undefined） code 123456JOSN.stringify(person, function(k, v)&#123; if (k === &apos;telphones&apos;)&#123; return undefined &#125; return v&#125;, 2) 运行结果：1234&#123; sex: &apos;man&apos;, name: &apos;Tom&apos;&#125; 四、只显示某些字段 code 1JOSN.stringify(person, [&apos;sex&apos;], 2) 运行结果：123&#123; sex: &apos;man&apos;&#125; 更多详情https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"},{"name":"JSON","slug":"json","permalink":"http://yongchao.tech:8080/tags/json/"}]},{"title":"将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组","slug":"将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组","date":"2019-03-09T18:48:18.000Z","updated":"2019-08-08T06:46:59.941Z","comments":true,"path":"2019/03/10/将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组/","link":"","permalink":"http://yongchao.tech:8080/2019/03/10/将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组/","excerpt":"1var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]; 解决方法11[...new Set(arr.flat(Infinity).sort((a,b) =&gt; a-b))] 解决方法2123[...new Set(arr.toString().split(&apos;,&apos;).map(Number).sort((a,b) =&gt; a-b))]orArrary.froms(new Set(arr.toString().split(&apos;,&apos;).map(Number).sort((a,b) =&gt; a-b)))","text":"1var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]; 解决方法11[...new Set(arr.flat(Infinity).sort((a,b) =&gt; a-b))] 解决方法2123[...new Set(arr.toString().split(&apos;,&apos;).map(Number).sort((a,b) =&gt; a-b))]orArrary.froms(new Set(arr.toString().split(&apos;,&apos;).map(Number).sort((a,b) =&gt; a-b))) 解决方法31234567function flatten(arr)&#123; while(arr.some(item =&gt; Array.isArray(item)))&#123; arr = [].concat(...arr) &#125; return arr&#125;Array.from(new Set(flatten(arr))).sort((a,b) =&gt; a-b) 解决方法4123456Arrary.prototype.flat = function()&#123; return [].concat[...this.map(item =&gt; (Array.isArray(item) ? item.flat() : [item]))]&#125;Arrary.prototype.unique = function() &#123; return [...new Set(this)]&#125; 补充：12345678910数组实例的flat()特点：1.falt()默认为“拉平”一层2.如果原数组有空位， flat()方法会跳过空位flatMap方法：介绍：对原方法中的每个成员执行一个函数，然后对返回值的数组执行flat()方法。该方法返回一个新数组，不改变原数组// 相当于 [[2, 4], [3, 6], [4, 8]].flat()[2, 3, 4].flatMap((x) =&gt; [x, x * 2])// [2, 4, 3, 6, 4, 8]","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"}]},{"title":"vue中使用cytoscape绘制拓扑图方案","slug":"vue中使用cytoscape绘制拓扑图方案","date":"2019-03-08T15:36:50.000Z","updated":"2019-10-16T03:25:06.540Z","comments":true,"path":"2019/03/08/vue中使用cytoscape绘制拓扑图方案/","link":"","permalink":"http://yongchao.tech:8080/2019/03/08/vue中使用cytoscape绘制拓扑图方案/","excerpt":"有一个需求需要绘制拓扑图，然后选图表库选择了cytoscape,看了官方文档http://js.cytoscape.org，感觉和network.js很像，包括两种element,一种是node（描述其相关信息），另一种是 edge(描述node之间的关系， 通过指明source, target确定指向)，其余的都是一些样式配置和事件的监听，可以说是非常的清晰明了了。此外文档的Extensions部分提供了各种的UI插件和API插件，拓展性也不错。 数据结构1234567891011121314151617181920212223242526nodes: [ &#123; \"id\": \"a\",//required \"name\": \"demo\",//optional // ... &#125;, &#123; \"id\": \"b\",//required \"name\": \"demo\",//optional &#125;]edges: [ //描述了 a--&gt;b &#123; \"id\": \"aadsfasdf\", //optional \"source\": \"a\", //required, source-node-id \"target\": \"b\", //required target-node-id &#125;, //描述了 a--&gt;a,会出现一个指向自己的圆，不过想要实现这一点需要cytoscape-edgehandles插件 &#123; \"id\": \"aadsfasdf\", //optional \"source\": \"a\", //required, source-node-id \"target\": \"a\", //required target-node-id &#125;]","text":"有一个需求需要绘制拓扑图，然后选图表库选择了cytoscape,看了官方文档http://js.cytoscape.org，感觉和network.js很像，包括两种element,一种是node（描述其相关信息），另一种是 edge(描述node之间的关系， 通过指明source, target确定指向)，其余的都是一些样式配置和事件的监听，可以说是非常的清晰明了了。此外文档的Extensions部分提供了各种的UI插件和API插件，拓展性也不错。 数据结构1234567891011121314151617181920212223242526nodes: [ &#123; \"id\": \"a\",//required \"name\": \"demo\",//optional // ... &#125;, &#123; \"id\": \"b\",//required \"name\": \"demo\",//optional &#125;]edges: [ //描述了 a--&gt;b &#123; \"id\": \"aadsfasdf\", //optional \"source\": \"a\", //required, source-node-id \"target\": \"b\", //required target-node-id &#125;, //描述了 a--&gt;a,会出现一个指向自己的圆，不过想要实现这一点需要cytoscape-edgehandles插件 &#123; \"id\": \"aadsfasdf\", //optional \"source\": \"a\", //required, source-node-id \"target\": \"a\", //required target-node-id &#125;] 实际栗子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218&lt;template&gt; &lt;div id=&quot;cy&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import cytoscape from &apos;cytoscape&apos;&lt;!--为edge添加事件和二维的布局 --&gt;import edgehandles from &apos;cytoscape-edgehandles&apos;&lt;!-- 提供类似于tooltip的提示框 --&gt;import popper from &apos;cytoscape-popper&apos;import tippy from &apos;tippy.js&apos;&lt;!-- 引入data --&gt;import data from &apos;./data.js&apos;&lt;!-- 使用插件 --&gt;cytoscape.use(edgehandles)cytoscape.use(popper)&lt;!-- 可以使用自己选的配色 --&gt;let colors = [&apos;#FFFFCC&apos;, &apos;#CCFFFF&apos;, &apos;#FFCCCC&apos;, &apos;#FFFF99&apos;, &apos;#CCCCFF&apos;, &apos;#FF9966&apos;, &apos;#FF6666&apos;, &apos;#FFCC99&apos;, &apos;#CCFF99&apos;, &apos;#CCCCCC&apos;, &apos;#CCFFCC&apos;, &apos;#99CC99&apos;, &apos;#99CCCC&apos;]let colors1 = [&apos;#FF6666&apos;, &apos;#006699&apos;, &apos;#FF9966&apos;, &apos;#0066CC&apos;, &apos;#339933&apos;, &apos;#FFCC33&apos;, &apos;#FF9900&apos;, &apos;#FFFFCC&apos;, &apos;#CC6600&apos;, &apos;#CCCC44&apos;, &apos;#99CC33&apos;, &apos;#0099CC&apos;, &apos;#99CCCC&apos;, &apos;#FF0033&apos;, &apos;#333399&apos;, &apos;#CCCC00&apos;, &apos;#33CC99&apos;, &apos;#FFFF00&apos;, &apos;#336699&apos;]let colors2 = [&apos;#CCFF99&apos;, &apos;#99CCFF&apos;, &apos;#99CCCC&apos;, &apos;#CCFFCC&apos;, &apos;#66CCCC&apos;, &apos;#CCCCFF&apos;, &apos;#FFFFCC&apos;, &apos;#CCFFFF&apos;, &apos;#66CCFF&apos;, &apos;#6699CC&apos;]let vm = nullexport default &#123; props: &#123; &#125;, components: &#123; &#125;, data () &#123; return &#123; tippyInstance: null &#125; &#125;, computed: &#123; &#125;, watch: &#123; &#125;, methods: &#123; draw () &#123; let nodes = data.nodes let edges = data.edges nodes.map((x, i) =&gt; &#123; x.data.color = colors[i % 13] // x.data.color = colors1[i % 19] x.data.color = colors2[i % 10] return x &#125;) let cy = cytoscape(&#123; container: document.getElementById(&apos;cy&apos;), layout: &#123; name: &apos;grid&apos;, concentric: function (n) &#123; return n.id() === &apos;j&apos; ? 200 : 0 &#125;, levelWidth: function (nodes) &#123; return 100 &#125;, minNodeSpacing: 100 &#125;, style: [ &#123; selector: &apos;node&apos;, style: &#123; &apos;content&apos;: &apos;data(name)&apos;, &apos;width&apos;: &apos;mapData(size, 0, 1.0, 40, 60)&apos;, &apos;height&apos;: &apos;mapData(size, 0, 1.0, 40, 60)&apos;, &apos;background-color&apos;: &apos;data(color)&apos; &#125; &#125;, &#123; selector: &apos;edge&apos;, style: &#123; &apos;curve-style&apos;: &apos;unbundled-bezier&apos;, &apos;target-arrow-shape&apos;: &apos;triangle&apos;, &apos;target-arrow-color&apos;: &apos;data(colour)&apos;, &apos;line-color&apos;: &apos;data(colour)&apos;, &apos;width&apos;: &apos;mapData(width, 0, 1.0, 1, 3)&apos;, // &apos;label&apos;: &apos;data(info)&apos; &apos;control-point-distances&apos;: [40, -40], &apos;control-point-weights&apos;: [0.25, 0.75] &#125; &#125;, // some style for the extension &#123; selector: &apos;.eh-handle&apos;, style: &#123; &apos;background-color&apos;: &apos;red&apos;, &apos;width&apos;: 12, &apos;height&apos;: 12, &apos;shape&apos;: &apos;ellipse&apos;, &apos;overlay-opacity&apos;: 0, &apos;border-width&apos;: 12, // makes the handle easier to hit &apos;border-opacity&apos;: 0 &#125; &#125;, &#123; selector: &apos;.eh-hover&apos;, style: &#123; &apos;background-color&apos;: &apos;red&apos; &#125; &#125;, &#123; selector: &apos;.eh-source&apos;, style: &#123; &apos;border-width&apos;: 2, &apos;border-color&apos;: &apos;red&apos; &#125; &#125;, &#123; selector: &apos;.eh-target&apos;, style: &#123; &apos;border-width&apos;: 2, &apos;border-color&apos;: &apos;red&apos; &#125; &#125;, &#123; selector: &apos;.eh-preview, .eh-ghost-edge&apos;, style: &#123; &apos;background-color&apos;: &apos;red&apos;, &apos;line-color&apos;: &apos;red&apos;, &apos;target-arrow-color&apos;: &apos;red&apos;, &apos;source-arrow-color&apos;: &apos;red&apos; &#125; &#125;, &#123; selector: &apos;.eh-ghost-edge.eh-preview-active&apos;, style: &#123; &apos;opacity&apos;: 0 &#125; &#125;, &#123; selector: &apos;.edge-out-highlight&apos;, style: &#123; &apos;line-color&apos;: &apos;black&apos;, &apos;target-arrow-color&apos;: &apos;black&apos;, width: 3 &#125; &#125;, &#123; selector: &apos;.edge-in-highlight&apos;, style: &#123; &apos;line-color&apos;: &apos;purple&apos;, &apos;target-arrow-color&apos;: &apos;purple&apos;, width: 3 &#125; &#125; ], elements: &#123; nodes: nodes, edges: edges &#125; &#125;) // edge添加事件 cy.on(&apos;tap&apos;, &apos;edge&apos;, function (evt) &#123; var node = evt.target if (vm.tippyInstance) &#123; vm.tippyInstance.hide() vm.tippyInstance.destroy() &#125; vm.makeTippy(node) vm.tippyInstance.show() &#125;) // node 添加事件 cy.on(&apos;tap&apos;, &apos;edge&apos;, function (evt) &#123; var node = evt.target if (vm.tippyInstance) &#123; vm.tippyInstance.hide() vm.tippyInstance.destroy() &#125; vm.makeTippy(node) vm.tippyInstance.show() &#125;) cy.on(&apos;tap&apos;, &apos;node&apos;, function (evt) &#123; var node = evt.target node.incomers(&apos;edge&apos;).toggleClass(&apos;edge-in-highlight&apos;) node.edgesWith(&apos;*&apos;).toggleClass(&apos;edge-out-highlight&apos;) &#125;) &#125;, makeTippy (node) &#123; &lt;!-- 点击edge出现一个弹框，显示一些额外的信息 --&gt; this.tippyInstance = tippy(node.popperRef(), &#123; content: function () &#123; var div = document.createElement(&apos;div&apos;) div.innerHTML = `&lt;p style=&quot;text-align:left;padding-top:8px;&quot;&gt;$&#123;node._private.data.info&#125;&lt;/p&gt;` return div &#125;, trigger: &apos;manual&apos;, arrow: true, placement: &apos;bottom&apos;, hideOnClick: false, multiple: true, sticky: true &#125;) &#125; &#125;, created () &#123; vm = this &#125;, mounted () &#123; this.$nextTick(() =&gt; &#123; this.draw() &#125;) &#125;&#125;&lt;/script&gt; 效果图","categories":[{"name":"graph","slug":"graph","permalink":"http://yongchao.tech:8080/categories/graph/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yongchao.tech:8080/tags/vue/"},{"name":"graph","slug":"graph","permalink":"http://yongchao.tech:8080/tags/graph/"}]},{"title":"cytoscape的简单使用","slug":"cytoscape的简单使用","date":"2019-03-07T14:29:42.000Z","updated":"2019-09-16T00:56:06.811Z","comments":true,"path":"2019/03/07/cytoscape的简单使用/","link":"","permalink":"http://yongchao.tech:8080/2019/03/07/cytoscape的简单使用/","excerpt":"","text":"cy实例对象常用操作添加cy.add(eleObj/eleObjs/eles) removecy.remove(elems/selector) 获取cy.colleciton 返回一个new empty collection cy.getElementById() or cy.$id() return one element cy.$(selector)、cy.elements(selector) return elements cy.nodes(selector) cy.edges(selector) cy.filter(selector) return elements cy.filter(function(ele, i, eles)) - ele The current element under consideration for filtering. - i The counter used for iteration over the elements in the graph. - eles The collection of elements being filtered ps: cy.nodes(‘[weight &gt; 50]’); 批量修改(能够有效的减少渲染成本)cy.batch() cy.satrtBatch() cy.endBatch() demo如下 12345678910cy.startBatch();&lt;!-- 多次的样式修改操作 --&gt;cy.$(&apos;#j&apos;) .data(&apos;weight&apos;, &apos;70&apos;) .addClass(&apos;funny&apos;) .removeClass(&apos;serious&apos;)cy.endBatch();能够减少中间的redraw的成本，和jquery中将一系列修改样式的操作合并到一个类中，对这个类进行操作一个道理。 createcy.mount() cy.unmount() 销毁cy.destroy() 有利于gc 临时数据操作cy.scratch([namespace], [value]) cy.removeScratch() 全局函数： cytoscape在调试过程中在console中打印一些错 cytoscape.warnings(false) 禁止报错 cytoscape.warnings(true) 开启报错 cytoscape.warnings() 得到当前状态 collection的一些操作","categories":[{"name":"graph","slug":"graph","permalink":"http://yongchao.tech:8080/categories/graph/"}],"tags":[{"name":"graph","slug":"graph","permalink":"http://yongchao.tech:8080/tags/graph/"},{"name":"cytoscape","slug":"cytoscape","permalink":"http://yongchao.tech:8080/tags/cytoscape/"}]},{"title":"post和get的区别","slug":"post和get的区别","date":"2019-03-05T17:02:27.000Z","updated":"2019-08-08T06:46:59.936Z","comments":true,"path":"2019/03/06/post和get的区别/","link":"","permalink":"http://yongchao.tech:8080/2019/03/06/post和get的区别/","excerpt":"","text":"介绍首先， GET、POST 都是htt请求的的方法。它们本质上并无差别。HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的 。 问题那么， 问题来了。1、”GET请求在URL中传送的参数是有长度限制的，而POST没有”是什么鬼？。 答： url长度限制都是浏览器设置的；而GET也可以在request body中传递参数，只不过不同的服务器对这些数据的处理方式不同，有些接受，有些忽略。 2、GET和POST还有一个重大区别，简单的说：GET产生一个TCP数据包；POST产生两个TCP数据包。长的说：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 答： 1. GET与POST都有自己的语义，不能随便混用。 2. 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 3. 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://yongchao.tech:8080/tags/http/"}]},{"title":"webhook-demo","slug":"webhook-demo","date":"2019-03-05T09:46:15.000Z","updated":"2019-08-08T06:46:59.939Z","comments":true,"path":"2019/03/05/webhook-demo/","link":"","permalink":"http://yongchao.tech:8080/2019/03/05/webhook-demo/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var http = require(&apos;http&apos;) , exec = require(&apos;exec&apos;)const PORT = process.env.PORT || 9988let transporter = nodemailer.createTransport(&#123; service: &apos;smpt.163.com&apos;, host: &apos;smtp.163.com&apos;, secureConnection: true, port: 465, auth: &#123; user: &apos;XXX@163.com&apos;, pass: &apos;XXXXXXX&apos; &#125;&#125;);let defaultOpions = &#123; from: &apos;yongchao blog &lt;XXX@163.com&gt;&apos;, to: &apos;XXXX@qq.com&apos;, subject: &apos;yongchao blog&apos;, html: &apos;&lt;b&gt;blog deploy success !&lt;/b&gt;&apos;&#125;var deployServer = http.createServer(function(request, response) &#123; if (request.url.search(/deploy\\/?$/i) &gt; 0) &#123; var commands = [ &apos;make restart&apos; //这是我自定义的重新部署的代码 ].join(&apos; &amp;&amp; &apos;) exec(commands, function(err, out, code) &#123; if (err instanceof Error) &#123; response.writeHead(500) response.end(&apos;Server Internal Error.&apos;) throw err &#125; process.stderr.write(err) process.stdout.write(out) response.writeHead(200) response.end(&apos;Deploy Done.&apos;) transporter.sendMail(defaultOpions, (err, info) =&gt; &#123; if(err) &#123; console.error(err) &#125;else&#123; console.log(err, info) &#125; &#125;) &#125;) &#125; else &#123; response.writeHead(404) response.end(&apos;Not Found.&apos;) &#125;&#125;)deployServer.listen(PORT, () =&gt; &#123; console.log(&apos;start service&apos; + PORT)&#125;)","categories":[],"tags":[]},{"title":"vue-directive","slug":"vue-directive","date":"2019-03-04T19:34:37.000Z","updated":"2019-08-08T06:46:59.937Z","comments":true,"path":"2019/03/05/vue-directive/","link":"","permalink":"http://yongchao.tech:8080/2019/03/05/vue-directive/","excerpt":"vue-directive 的几个钩子函数 bind 指令第一次被绑定到元素时调用，只调用一次 inserted 被绑定元素插入到父节点时调用 update 被绑定元素所在模版更新时调用，不论绑定值是否变化都调用 componentUpdated 被绑定元素所在模版在完成一次更新周期时调用 unbind 元素解绑时调用，只调用一次","text":"vue-directive 的几个钩子函数 bind 指令第一次被绑定到元素时调用，只调用一次 inserted 被绑定元素插入到父节点时调用 update 被绑定元素所在模版更新时调用，不论绑定值是否变化都调用 componentUpdated 被绑定元素所在模版在完成一次更新周期时调用 unbind 元素解绑时调用，只调用一次 每个钩子函数都有参数： el: 指令绑定的element,用来操作dom binging 一个对象，包含以下属性 name: 指令名，不包含v-前缀 value: 指令的绑定值，例如 v-my-directive=叮+ l”， value的值是，2 oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用.无论value 值是否改变都可用。 expression: 绑定值的字符串形式。例如v-my-directive=”1+ 1”，expression的值是”1+I”. arg： 指令的arguments, 例如 v-my-directive:foo, arg 的值是 foo modifiers: 一个包含修饰符的对象 。 例如 v-my-directive.foo.bar，修饰符对象 modifiers的值是{ foo: true, bar: true } vnode oldVnode: 上一个虚拟节点仅在 update 和 componentUpdated 钩子中可用 。 clickoutsize指令的实现12345678910111213141516171819202122232425262728Vue.directive(&apos;clickoutside&apos;, &#123; bind: function (el, binding) &#123; function documentHandler (e) &#123; if (binding.arg === &apos;esc&apos; &amp;&amp; e.keyCode === 27) &#123; &lt;!-- v-clickoutside的value 是一个函数，这里相当于执行绑定的函数 --&gt; binding.value(e) &#125; &lt;!-- 如果点击的元素是在绑定了v-clickoutside指令元素的内容，则忽略 --&gt; if (el.contains(e.target)) &#123; return false &#125; if (binding.expression) &#123; binding.value(e) &#125; &#125; &lt;!-- 在元素添加一个元素用来存绑定的函数，是为了unbind的时候能够找到这个函数 --&gt; el.__vueClickOutside__ = documentHandler &lt;!-- 在全局添加一些事件 --&gt; window.addEventListener(&apos;keydown&apos;, documentHandler) document.addEventListener(&apos;click&apos;, documentHandler) document.addEventListener(&apos;keydown&apos;, documentHandler) &#125;, unbind: function (el) &#123; document.removeEventListener(&apos;click&apos;, el.__vueClickOutside__) delete el.__vueClickOutside__ &#125;&#125;)","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yongchao.tech:8080/tags/vue/"}]},{"title":"对于echarts图表随着浏览器窗口resize的优化","slug":"对于echarts图表随着浏览器窗口resize的优化","date":"2019-03-04T19:07:32.000Z","updated":"2019-08-08T06:46:59.941Z","comments":true,"path":"2019/03/05/对于echarts图表随着浏览器窗口resize的优化/","link":"","permalink":"http://yongchao.tech:8080/2019/03/05/对于echarts图表随着浏览器窗口resize的优化/","excerpt":"说明： 有时候项目中会显示一些图表，而且width可能并不是固定的（可能100%），那么当浏览器窗口变化的时候，图表的大小应该跟随着变大或变小，称之为resize","text":"说明： 有时候项目中会显示一些图表，而且width可能并不是固定的（可能100%），那么当浏览器窗口变化的时候，图表的大小应该跟随着变大或变小，称之为resize 1234567891011121314151617181920212223242526272829303132333435363738/** * 用来处理每一个有图表的页面添加resize , 离开时移除resize函数 */import echarts from &apos;echarts&apos;import _ from &apos;lodash&apos;export default &#123; data () &#123; return &#123; doms: [] &#125; &#125;, computed: &#123; chartResize () &#123; return _.throttle(() =&gt; &#123; return this.doms.forEach(dom =&gt; &#123; dom &amp;&amp; dom.resize() &#125;) &#125;, 400) &#125; &#125;, methods: &#123; initChart () &#123; this.doms.forEach(dom =&gt; &#123; dom &amp;&amp; echarts.init(dom) &#125;) &#125; &#125;, mounted () &#123; console.log(&apos;mixins mounted&apos;) this.doms = [this.$refs[&apos;charts&apos;]] this.initChart() window.addEventListener(&apos;resize&apos;, this.chartResize) &#125;, destroyed () &#123; console.log(&apos;mixins destroyed&apos;) window.removeEventListener(&apos;resize&apos;, this.chartResize) &#125;&#125; ps: 使用的时候在需要图表的页面引入这个mixins","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yongchao.tech:8080/tags/vue/"}]},{"title":"覆盖ui框架css原生样式","slug":"覆盖ui框架css原生样式","date":"2019-03-04T19:03:48.000Z","updated":"2019-08-08T06:46:59.942Z","comments":true,"path":"2019/03/05/覆盖ui框架css原生样式/","link":"","permalink":"http://yongchao.tech:8080/2019/03/05/覆盖ui框架css原生样式/","excerpt":"","text":"加scoped 1234567891011&lt;style scoped&gt;/deep/.rootName .className&#123; &#125;or .rootName &gt;&gt;&gt; .className&#123; &#125;&lt;/style&gt; 不加scoped原理：在组件中添加了父css类, 在修改的样式作用域限定为父css类，减小css的影响范围 1234&lt;style&gt;.rootName .className&#123;&#125;&lt;/style&gt;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yongchao.tech:8080/tags/vue/"}]},{"title":"vue-intro使用方法及注意点","slug":"vue-intro使用方法及注意点","date":"2019-03-04T19:01:39.000Z","updated":"2019-08-08T06:46:59.937Z","comments":true,"path":"2019/03/05/vue-intro使用方法及注意点/","link":"","permalink":"http://yongchao.tech:8080/2019/03/05/vue-intro使用方法及注意点/","excerpt":"","text":"1、使用时必须引入intro.js2、let intro=Intro.intro()3、intro.setOptions({}).start().oncomplete().onskip(function)4、intro这个插件只能提示一些静态的页面上已经有的一些元素，异步的或者是后来动态显示的元素无法加上提示.","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yongchao.tech:8080/tags/vue/"}]},{"title":"vue中定时器问题","slug":"vue中定时器问题","date":"2019-03-04T18:58:04.000Z","updated":"2019-08-26T09:15:57.832Z","comments":true,"path":"2019/03/05/vue中定时器问题/","link":"","permalink":"http://yongchao.tech:8080/2019/03/05/vue中定时器问题/","excerpt":"Vue中使用了定时器后在关闭页面后必须手动清理","text":"Vue中使用了定时器后在关闭页面后必须手动清理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758方案一data: &#123; tiemr: null &#125;,method: &#123; method1 () &#123; this.timer = setInterval(()=&gt; &#123; // logic &#125;, interval) &#125; &#125;,beforeDestroy() &#123; clearInterval(this.timer) this.timer = null&#125;方案二：通过$once来监听定时器，在beforeDestroy中可以被清除优点：这两段代码写在一起，不用特意定义一个data.timer,减少了数据监听的成本消耗缺点：适用于只有离开页面关闭定时器的情况，const timer = setInterval(()=&gt;&#123; // logic&#125;, interval)this.$once(&apos;hook:beforeDestroy&apos;, ()=&gt;&#123; clearInterval(timer)&#125;)ps: template&gt; &lt;div class=&quot;test&quot;&gt; &lt;Button @click=&quot;addInterval()&quot;&gt;add&lt;/Button&gt; &lt;h1&gt;测试&lt;/h1&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; addInterval () &#123; const timer = setInterval(() =&gt; &#123; console.log(&apos;aaa&apos;) &#125;, 100) this.$once(&apos;hook:beforeDestroy&apos;, () =&gt; &#123; clearInterval(timer) &#125;) &#125; &#125;&#125;&lt;/script&gt;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yongchao.tech:8080/tags/vue/"}]},{"title":"js的灵活","slug":"js的灵活","date":"2019-03-04T14:53:55.000Z","updated":"2019-08-08T06:46:59.935Z","comments":true,"path":"2019/03/04/js的灵活/","link":"","permalink":"http://yongchao.tech:8080/2019/03/04/js的灵活/","excerpt":"js是超级灵活的语言step11234567891011121314var checkObj = function () &#123;&#125; checkObj.prototype.checkName = function()&#123; console.log(&apos;checkName&apos;)&#125;checkObj.prototype.checkEmail = function()&#123; console.log(&apos;checkEmail&apos;)&#125;checkObj.prototype.checkPassword = function()&#123; console.log(&apos;checkPassword&apos;)&#125;var a = new checkObj()a.checkName()a.checkEmail()a.checkPassword()","text":"js是超级灵活的语言step11234567891011121314var checkObj = function () &#123;&#125; checkObj.prototype.checkName = function()&#123; console.log(&apos;checkName&apos;)&#125;checkObj.prototype.checkEmail = function()&#123; console.log(&apos;checkEmail&apos;)&#125;checkObj.prototype.checkPassword = function()&#123; console.log(&apos;checkPassword&apos;)&#125;var a = new checkObj()a.checkName()a.checkEmail()a.checkPassword() step212345678910111213141516var checkObj = function () &#123;&#125;checkObj.prototype = &#123; checkName:function()&#123; console.log(&apos;checkName&apos;) &#125;, checkEmail: function()&#123; console.log(&apos;checkEmail&apos;) &#125;, checkPassword: function()&#123; console.log(&apos;checkPassword&apos;) &#125;&#125;var a = new checkObj()a.checkName()a.checkEmail()a.checkPassword() step3 链式调用1234567891011121314151617var checkObj = function () &#123;&#125; checkObj.prototype = &#123; checkName:function()&#123; console.log(&apos;checkName&apos;) return this &#125;, checkEmail: function()&#123; console.log(&apos;checkEmail&apos;) return this &#125;, checkPassword: function()&#123; console.log(&apos;checkPassword&apos;) return this &#125;&#125;var a = new checkObj()a.checkName().checkEmail().checkPassword()","categories":[],"tags":[]},{"title":"js的封装和继承","slug":"js原型","date":"2019-03-04T14:20:07.000Z","updated":"2019-09-05T02:10:17.392Z","comments":true,"path":"2019/03/04/js原型/","link":"","permalink":"http://yongchao.tech:8080/2019/03/04/js原型/","excerpt":"### 简单介绍谈到JAVASCRIPT的继承，只有一种结构：对象。每个对象都有一个私有属性proto 指向它的原型对象(prototype) . 原型对象也有自己的proto ,层层向上直到一个对象的原型对象为NULL.根据定义，NULL是没有原型的，并作为这个原型链的最后一个环节。 ！！！ 实例对象的proto 等于该对象构造函数的prototypeps:123var obj = &#123;&#125;obj.__proto__ === Object.prototype","text":"### 简单介绍谈到JAVASCRIPT的继承，只有一种结构：对象。每个对象都有一个私有属性proto 指向它的原型对象(prototype) . 原型对象也有自己的proto ,层层向上直到一个对象的原型对象为NULL.根据定义，NULL是没有原型的，并作为这个原型链的最后一个环节。 ！！！ 实例对象的proto 等于该对象构造函数的prototypeps:123var obj = &#123;&#125;obj.__proto__ === Object.prototype 封装12345678910111213141516171819202122232425var Book = function (id,name, price) &#123; // 私有属性 var num = 1 // 私有函数 function checkId()&#123; &#125; // 公有属性 this.id = id this.name = name this.price = price // 公有函数 this.getName=function()&#123;&#125; this.getPrice = function()&#123;&#125; this.setName = function (name)&#123;this.name = name&#125; this.setPrice = function(price)&#123;this.price = price&#125; this.getNum = function()&#123;return num&#125;&#125;//类静态公有属性（对象不能访问）Book.isChinese = true//类静态公有方法（对象不能访问）Book.resetTime = function()&#123;&#125;var book = new Book(&apos;adf2323&apos;,&apos;js设计模式&apos;, 232)console.log(book.name, book.price, book.id)console.log(book.getNum()) ### New的作用 1234567Function Book(id, name , price) &#123; Var this = &#123;&#125; This.name = name This.id = id This.price = price Return this&#125; 类的原型对象的作用继承通过将父类的实例赋值给子类的原型对象。 类的原型对象的作用就是为类的原型添加共有方法，但是类并不能直接访问这些函数和方法。当我实例化的时候，新创建的对象复制了父类的构造函数内的属性与方法并且将原型__proto__ 指向父类的原型对象，这样就拥有了父类的原型对象上的属性和方法，并且这个新创建的对象可以访问到父类原型对象上到的属性和方法 常见的继承的几种方式类式继承12345678910111213141516171819//声明父类function SuperClass()&#123;&#125;// 为父类添加共有方法SuperClass.prototype.getSuperValue=function()&#123;&#125;//声明子类function SubClass()&#123; this.subValue = false&#125;//继承SubClass.prototype = new SuperClass();// 为子类添加共有方法SubClass.prototype.getSubValue = function ()&#123; return this.subValue&#125;缺点：由于子类通过其原型prototype 对父类进行实例化，继承了父类。所以说父类中的共有属性如果是引用类型，就会被子类中的所有实例共用，存在被修改的可能。 构造函数式继承123456789101112131415function SuperClass(id)&#123; this.books = [&apos;js&apos;, &apos;html&apos;, &apos;css&apos;] this.id = id&#125;SuperClass.prototype.getSuperValue = function () &#123; console.log(&apos;getSuperValue&apos;)&#125;function SubClass(id)&#123; // 继承父类 SuperClass.call(this, id)&#125;缺点：只继承了父类构造函数中的公有属性。如果一个函数后者变量想要被继承么，就必须放在父类构造函数中，这样创建的每个实例都会单独拥有一份而不能共用，这样违背了代码复用的原则。为了综合这两种模式的有点，后来有了组合式继承。 组合式继承123456789101112131415161718192021function SuperClass(id)&#123; // 将公有引用类型放在构造函数中 this.books = [&apos;js&apos;, &apos;html&apos;, &apos;css&apos;] this.id = id&#125;SuperClass.prototype.getSuperValue = function () &#123; console.log(&apos;getSuperValue&apos;)&#125;function SubClass(id)&#123; // 继承父类中构造函数的属性和方法 SuperClass.call(this, id)&#125;SubClass.prototype = new SuperClass()SubClass.prototype.getTime = function()&#123; &#125;缺点： SuperClass.call(this, id)执行了一次父类构造函数new SuperClass()又执行了一次父类构造函数 寄生组合式继承1234567891011121314151617181920function SuperClass(id)&#123; // 将公有引用类型放在构造函数中 this.books = [&apos;js&apos;, &apos;html&apos;, &apos;css&apos;] this.id = id&#125;SuperClass.prototype.getSuperValue = function () &#123; console.log(&apos;getSuperValue&apos;)&#125;function SubClass(id)&#123; // 继承父类中构造函数的属性和方法 SuperClass.call(this, id)&#125;function inherit(subClass, superClass)&#123; //定义了一个没有自有属性的对象 var F = function()&#123;&#125; F.prototype = superClass.prototype subClass.prototype = new F() // 干净的继承了父类的公有属性&#125; 补充：inherit函数1234567891011function inherit(p)&#123; if(p === null) throw TypeError if(Object.create)&#123; return Object.create(p) &#125; let t = typeof p if(t !== &quot;object&quot; || t!== &quot;function&quot;) throw TypeError function F()&#123;&#125; F.prototype = p return new F();&#125;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yongchao.tech:8080/tags/js/"}]},{"title":"nodejs发送邮件","slug":"nodejs发送邮件","date":"2019-03-04T10:44:17.000Z","updated":"2019-08-08T06:46:59.935Z","comments":true,"path":"2019/03/04/nodejs发送邮件/","link":"","permalink":"http://yongchao.tech:8080/2019/03/04/nodejs发送邮件/","excerpt":"使用nodemailer包实现发送邮件","text":"使用nodemailer包实现发送邮件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var express = require(&apos;express&apos;)const nodemailer = require(&apos;nodemailer&apos;)const app = express()const PORT = process.env.PORT || 3000// 配置163邮箱let transporter = nodemailer.createTransport(&#123; service: &apos;smpt.163.com&apos;, host: &apos;smtp.163.com&apos;, secureConnection: true, port: 465, auth: &#123; user: &apos;XXXX@163.com&apos;, pass: &apos;XXXX&apos; &#125;&#125;);// 配置gmail邮箱// let transporter = nodeMailer.createTransport(&apos;SMTP&apos;,&#123;// service: &apos;gmail&apos;,// host: &apos;smtp.gmail.com&apos;,// secure: true,// port:465,// auth: &#123;// //邮箱// user: &apos;XXXXXXX@gmail.com&apos;,// //登入密码// pass: &apos;XXXXXXX&apos;,// &#125; // &#125;);let defaultOpions = &#123; from: &apos;XXX@163.com&apos;, to: &apos;XXX@qq.com&apos;, subject: &apos;主题&apos;, text: &apos;内容&apos;, html: &apos;&lt;b&gt;内容&lt;/b&gt;&apos;&#125;app.get(&apos;/&apos;, (req, res) =&gt; &#123; transporter.sendMail(defaultOpions, (err, info) =&gt; &#123; if(err) &#123; console.error(err) &#125;else&#123; console.log(err, info) &#125; res.send() &#125;)&#125;)app.listen(PORT, () =&gt; &#123; console.log(&apos;start service&apos;)&#125;)","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://yongchao.tech:8080/tags/node/"}]},{"title":"git常用知识点","slug":"git常用知识点","date":"2019-03-03T21:43:19.000Z","updated":"2019-08-08T06:46:59.933Z","comments":true,"path":"2019/03/04/git常用知识点/","link":"","permalink":"http://yongchao.tech:8080/2019/03/04/git常用知识点/","excerpt":"常用的几个命令12345678910git addgit commitgit statusgit diff git branchgit remotegit pull git push git resetgit tag","text":"常用的几个命令12345678910git addgit commitgit statusgit diff git branchgit remotegit pull git push git resetgit tag 常见的场景版本需要回退到旧版本123456789101、git reset git reset --hard &quot;目标版本commmit-id&quot; git push origin master -f 暴力，不建议 适用场景： 如果想恢复到之前某个提交的版本，且那个版本之后提交的版本我们都不要了，就可以用这种方法。2、git revert git revert的作用通过反做创建一个新的版本，这个版本的内容与我们要回退到的目标版本一样，但是HEAD指针是指向这个新生成的版本，而不是目标版本。 git revert -n 版本号 git commit -m 版本名 适用场景： 如果我们想恢复之前的某一版本（该版本不是merge类型），但是又想保留该目标版本后面的版本，记录下这整个版本变动流程，就可以用这种方法。 拉取远程分支并创建本地分支1231、git checkout -b newBranch origin/remoteBranch2、git fetch origin remoteBranch:newBranch3、git checkout -b newBranch --trace origin/remoteBranch 修改上一次commit的信息，未push到远程分支1git commit -m &apos;message&apos; --amend 忽略对某个文件或者文件夹的的修改将文件或者文件夹的名字添加到.gitignore文件","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yongchao.tech:8080/tags/git/"}]},{"title":"npm常用知识点","slug":"npm常用知识点","date":"2019-03-03T14:26:47.000Z","updated":"2019-08-08T06:46:59.935Z","comments":true,"path":"2019/03/03/npm常用知识点/","link":"","permalink":"http://yongchao.tech:8080/2019/03/03/npm常用知识点/","excerpt":"更新到最新正式版本1npm install npm@latest -g 更新到未来将会释放的版本1npm install npm@next -g 列出某个包的所有历史banbe1npm view &lt;package&gt; versions 初始化1npm init or npm init --yes(直接使用默认的设置)","text":"更新到最新正式版本1npm install npm@latest -g 更新到未来将会释放的版本1npm install npm@next -g 列出某个包的所有历史banbe1npm view &lt;package&gt; versions 初始化1npm init or npm init --yes(直接使用默认的设置) 安装包1npm install package or npm i package 安装包之 –save1npm install package --save 安装包并将包的信息写入package.json中的dependencies 安装包之 –save-dev1npm install package --save-dev 安装包并将包的信息写入package.json中的devDependencies 安装包之 指定版本1npm install package@version 全局包12345安装：npm install package -g查看那些全局包过期： npm outdated -g --depth=0更新某个全局包：npm update package -g更新所有的全局包： npm update -g卸载全局包： npm uninstall package -g semver package的版本问题 semver的格式： 主版本号.次版本号.修订号 range12345&lt; &lt;= &gt; &gt;== Advanceed Range Syntax 1.2.3 - 2.3.4 := &gt;=1.2.3 &lt;=2.3.4 1.2.3 - 2.3 := &gt;=1.2.3 &lt;2.4.0 1.2.3 - 2 := &gt;=1.2.3 &lt;3.0.0 X-Ranges := &gt;=0.0.0 (Any version satisfies) 1.x := &gt;=1.0.0 &lt;2.0.0 (Matching major version) 1.2.x := &gt;=1.2.0 &lt;1.3.0 (Matching major and minor versions)","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://yongchao.tech:8080/tags/npm/"}]},{"title":"bfc/float","slug":"bfc-float","date":"2019-03-02T17:17:26.000Z","updated":"2019-08-08T06:46:59.932Z","comments":true,"path":"2019/03/03/bfc-float/","link":"","permalink":"http://yongchao.tech:8080/2019/03/03/bfc-float/","excerpt":"block format context 特点是内部子元素绝不会影响外部的元素如何触发一个盒子的bfc ? 1、body 根元素 2、浮动元素：float 除 none 以外的值 3、绝对定位元素：position (absolute、fixed) 4、display 为 inline-block、table-cells、flex 5、overflow 除了 visible 以外的值 (hidden、auto、scroll)","text":"block format context 特点是内部子元素绝不会影响外部的元素如何触发一个盒子的bfc ? 1、body 根元素 2、浮动元素：float 除 none 以外的值 3、绝对定位元素：position (absolute、fixed) 4、display 为 inline-block、table-cells、flex 5、overflow 除了 visible 以外的值 (hidden、auto、scroll) 浮动元素产生了浮动流 所有产生了浮动流的元素，块级元素看不到他们，产生了bfc的元素和文本类属性（inline）的元素以及文本都能看到浮动元素。 ==ps==: 能清除浮动的只有块级元素 BFC有以下用途, BFC 特性及应用1. 上线外边距发生折叠123456789101112&lt;head&gt; div&#123; width: 100px; height: 100px; background: lightblue; margin: 100px; &#125;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; 从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 。 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。 首先这不是 CSS 的 bug，我们可以理解为一种规范，如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。 1234567891011121314151617&lt;div class=&quot;container&quot;&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;container&quot;&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;.container &#123; overflow: hidden;&#125;p &#123; width: 100px; height: 100px; background: lightblue; margin: 100px;&#125;这时候，两个盒子边距就变成了 200px 2. BFC 可以包含浮动的元素我们都知道，浮动的元素会脱离普通文档流 由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。 3. BFC 可以阻止元素被浮动元素覆盖先来看一个文字环绕效果： 我是一个左浮动的元素我是一个没有设置浮动,也没有触发 BFC 元素, width: 200px; height:200px; background: #eee; 这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 overflow: hidden 这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yongchao.tech:8080/tags/css/"}]},{"title":"overflow-x/overflow-y一个为visible,一个为非visible时候的怪异行为","slug":"overflow-x-overflow-y一个为visible-一个为非visible时候的怪异行为","date":"2019-03-02T17:12:50.000Z","updated":"2019-08-08T06:46:59.936Z","comments":true,"path":"2019/03/03/overflow-x-overflow-y一个为visible-一个为非visible时候的怪异行为/","link":"","permalink":"http://yongchao.tech:8080/2019/03/03/overflow-x-overflow-y一个为visible-一个为非visible时候的怪异行为/","excerpt":"","text":"MDN的官方解释： 1The computed values of ‘overflow-x’ and ‘overflow-y’ are the same as their specified values, except that some combinations with ‘visible’ are not possible: if one is specified as ‘visible’ and the other is ‘scroll’ or ‘auto’, then ‘visible’ is set to ‘auto’. The computed value of ‘overflow’ is equal to the computed value of ‘overflow-x’ if ‘overflow-y’ is the same; otherwise it is the pair of computed values of ‘overflow-x’ and ‘overflow-y’. overflow-x 和overflow-y的计算值和它们指定的值是相同的，除了某些与visible组合的是不可能的。 如果一个为visible, 另一个被指定为scroll、 auto 、hidden(实际测试所得) ，那么visible 将被设置为auto 如果overflow的指定值和overflow-x相等的话（如果overflow-y相同的话） 其余情况，overflow-x 和overflow-y的值和指定的值相同","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yongchao.tech:8080/tags/css/"}]},{"title":"js/jquery判断是否包含类","slug":"js-jquery判断是否包含类","date":"2019-03-02T17:09:29.000Z","updated":"2019-08-08T06:46:59.933Z","comments":true,"path":"2019/03/03/js-jquery判断是否包含类/","link":"","permalink":"http://yongchao.tech:8080/2019/03/03/js-jquery判断是否包含类/","excerpt":"","text":"123456789新版本jQuery hasClass(&quot;className&quot;) is(&quot;.className&quot;)原生js element.classList.contains(className)旧版jQuery: hasClass(&quot;.className&quot;)","categories":[],"tags":[{"name":"jquery","slug":"jquery","permalink":"http://yongchao.tech:8080/tags/jquery/"}]},{"title":"双层边框样式","slug":"双层边框样式","date":"2019-02-28T16:00:13.000Z","updated":"2019-08-08T06:46:59.940Z","comments":true,"path":"2019/03/01/双层边框样式/","link":"","permalink":"http://yongchao.tech:8080/2019/03/01/双层边框样式/","excerpt":"","text":"outline用于创建两个边框的时候好处: outline的样式是可变的，缺点: 是border如果是圆角，outline仍然是矩形，经测试，outline只对right bottom占据空间，对left top不产生影响 box-shadow可以用于产生多个边框好处: border是什么样，投影就是什么样，完美贴合缺点: 指定描绘实线阴影，不能改变阴影的样式color inset box-shadow: h-shadow(水平偏移) v-shadow(垂直偏移) blur(模糊距离) spread(阴影尺寸) color inset(边框类型) 1234567891011121314.box&#123; height:50px; width: 100px; background: #666; border: solid 5px yellowgreen; border-radius: 10px; margin: 30px;&#125;.outline-box&#123; outline: red 10px solid;&#125;.shadow-box&#123; box-shadow: 0 0 0 10px red;","categories":[],"tags":[]},{"title":"button样式的实现","slug":"button样式的实现","date":"2019-02-28T15:57:49.000Z","updated":"2019-08-08T06:46:59.932Z","comments":true,"path":"2019/02/28/button样式的实现/","link":"","permalink":"http://yongchao.tech:8080/2019/02/28/button样式的实现/","excerpt":"","text":"使用stylus 编写工具函数: 1234567vendor(prop,value) -webkit-&#123;prop&#125; value -moz-&#123;prop&#125; value &#123;prop&#125; valueborder-radius(n = 5px) vendor(border-radius,n) 1234567891011121314.btn padding: 0 40px border:none height:40px border-radius(5px) background-color: #5df cursor pointer transition: all .5s ease &amp;:hover background-color #666 color #fff transition: all .5s ease &amp;:focus outline: none 12345678910.btn-3d position relative top 0 box-shadow: 0 7px 0 rgba(0,0,0,.2), 0 8px 3px #333 transition: all .15s ease &amp;:active position relative top 5px box-shadow: 0 2px 0 rgba(0,0,0,.2), 0 3px 3px #333 transition: all .3s ease 12345678910.btn-glowing animation: glowing 3s infinite;@keyframes glowing from box-shadow: 0 0 0 rgba(44, 154, 219, 0.3) 50% box-shadow: 0 0 20px rgba(44, 154, 219, 0.8) to box-shadow: 0 0 0 rgba(44, 154, 219, 0.3) 按钮菜单1234567891011121314151617181920212223242526272829303132333435363738394041424344454647.btn-dropdown position relative overflow visible display inline-block &amp;:hover,&amp;:active .btn-dropdown-list display inline-block.btn-dropdown-list display none position absolute top 100% left 0 margin 0 padding 0 z-index 1000 min-width 100% list-style-type: none background: rgba(255, 255, 255, 0.95) border-style: solid border-width: 1px border-color: #d4d4d4 font-family: &quot;Helvetica Neue Light&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, &quot;Lucida Grande&quot;, sans-serif -webkit-box-shadow: 0 2px 7px rgba(0, 0, 0, 0.2) box-shadow: 0 2px 7px rgba(0, 0, 0, 0.2) border-radius: 3px -webkit-box-sizing: border-box -moz-box-sizing: border-box box-sizing: border-box &amp;:hover display inline-block.btn-dropdown-list&gt;li padding: 0 margin: 0 display: block.btn-dropdown-list&gt;li&gt;a display: block line-height: 40px font-size: 12.8px padding: 5px 10px float: none color: #666 text-decoration: none &amp;:hover color: #5e5e5e background: #f6f6f6 text-decoration: none 12345678910111213141516171819.btn-group position relative display inline-block &amp;:after content: &apos;&apos; display block clear both.btn-group .btn border-radius: 0 float: left border: solid 1px #333 &amp;:first-child border-top-left-radius: 5px border-bottom-left-radius: 5px &amp;:last-child border-top-right-radius: 5px border-bottom-right-radius: 5px &amp;:not(:last-child) border-right none 123456789.btn-raised border-color: #e1e1e1 border-style: solid border-width: 1px line-height: 38px background: -webkit-gradient(linear, left top, left bottom, from(#f6f6f6), to(#e1e1e1)) background: linear-gradient(#333, #e1e1e1) -webkit-box-shadow: inset 0px 1px 0px rgba(255, 255, 255, 0.3), 0 1px 2px rgba(0, 0, 0, 0.15) box-shadow: inset 0px 1px 0px rgba(255, 255, 255, 0.3), 0 1px 2px rgba(0, 0, 0, 0.15) 123456789.btn-wrap display inline-block padding 9px border-radius 200px border solid 1px #e3e3e3 background linear-gradient(#f2f2f2,#fff) box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.04) &amp; .btn border-radius: 200px","categories":[],"tags":[]},{"title":"css实现单行、多行文本溢出","slug":"css实现单行、多行文本溢出","date":"2019-02-28T15:09:23.000Z","updated":"2019-08-08T06:46:59.932Z","comments":true,"path":"2019/02/28/css实现单行、多行文本溢出/","link":"","permalink":"http://yongchao.tech:8080/2019/02/28/css实现单行、多行文本溢出/","excerpt":"","text":"### 单行：123overflow: hidden;text-overflow:ellipsis;white-space: nowrap; ### 多行：1234display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 3;overflow: hidden;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yongchao.tech:8080/tags/css/"}]},{"title":"timeline样式实现","slug":"timeline样式实现","date":"2019-02-28T14:59:51.000Z","updated":"2019-08-08T06:46:59.936Z","comments":true,"path":"2019/02/28/timeline样式实现/","link":"","permalink":"http://yongchao.tech:8080/2019/02/28/timeline样式实现/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334&lt;ul&gt; &lt;li&gt; &lt;div class=&quot;head&quot;&gt; &lt;span class=&quot;title&quot;&gt;标题1&lt;/span&gt; &lt;span class=&quot;extra&quot;&gt;2019/01/03&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt;内容内容内容内容内容内容内容内容内容内容内容内容内容&lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=&quot;head&quot;&gt; &lt;span class=&quot;title&quot;&gt;标题2&lt;/span&gt; &lt;span class=&quot;extra&quot;&gt;2019/01/04&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内 &lt;/li&gt;&lt;/ul&gt;.head&#123; overflow:hidden; height:25px; line-height:25px; padding:0 5px;&#125;.extra&#123; float:right;&#125;.content&#123; border-left:solid 3px #333; padding-left:5px;&#125;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yongchao.tech:8080/tags/css/"},{"name":"components","slug":"components","permalink":"http://yongchao.tech:8080/tags/components/"}]},{"title":"如何搭建hexo博客","slug":"如何搭建hexo博客","date":"2019-02-28T09:48:34.000Z","updated":"2019-08-08T06:46:59.940Z","comments":true,"path":"2019/02/28/如何搭建hexo博客/","link":"","permalink":"http://yongchao.tech:8080/2019/02/28/如何搭建hexo博客/","excerpt":"","text":"准备开发环境（默认已安装好node、git）1npm install -g hexo-cli 创建项目123mkdir blogcd blognpm install hexo-autoprefixer hexo-generator-feed hexo-generator-json-content hexo-generator-search hexo-helper-qrcode hexo-related-popular-posts hexo-renderer-less hexo-renderer-marked --save 此时是如下目录结构 .├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 更换配置更改项目根目录下的_config.ymal中的url、author、keywords等参数","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yongchao.tech:8080/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"http://yongchao.tech:8080/tags/blog/"}]},{"title":"ubuntu16.04更新源","slug":"ubuntu16-04更新源","date":"2019-02-27T17:48:39.000Z","updated":"2019-08-08T06:46:59.937Z","comments":true,"path":"2019/02/28/ubuntu16-04更新源/","link":"","permalink":"http://yongchao.tech:8080/2019/02/28/ubuntu16-04更新源/","excerpt":"1.备份source.list1cp /etc/apt/source.list /etc/apt/source.list.bak 2.打开source.list文件，删除全部内容1vim /etc/apt/sources.list 复制章节3中的源内容到sources.list文件并保存 3.国内主流的更新源","text":"1.备份source.list1cp /etc/apt/source.list /etc/apt/source.list.bak 2.打开source.list文件，删除全部内容1vim /etc/apt/sources.list 复制章节3中的源内容到sources.list文件并保存 3.国内主流的更新源 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#sohu shangdongdeb http://mirrors.sohu.com/ubuntu/ trusty main restricted universe multiversedeb http://mirrors.sohu.com/ubuntu/ trusty-security main restricted universe multiversedeb http://mirrors.sohu.com/ubuntu/ trusty-updates main restricted universe multiversedeb http://mirrors.sohu.com/ubuntu/ trusty-proposed main restricted universe multiversedeb http://mirrors.sohu.com/ubuntu/ trusty-backports main restricted universe multiversedeb-src http://mirrors.sohu.com/ubuntu/ trusty main restricted universe multiversedeb-src http://mirrors.sohu.com/ubuntu/ trusty-security main restricted universe multiversedeb-src http://mirrors.sohu.com/ubuntu/ trusty-updates main restricted universe multiversedeb-src http://mirrors.sohu.com/ubuntu/ trusty-proposed main restricted universe multiversedeb-src http://mirrors.sohu.com/ubuntu/ trusty-backports main restricted universe multiverse#163 guangdongdeb http://mirrors.163.com/ubuntu/ trusty main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ trusty-security main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ trusty main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ trusty-security main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse#aliyundeb-src http://archive.ubuntu.com/ubuntu xenial main restricteddeb http://mirrors.aliyun.com/ubuntu/ xenial main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universedeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb http://archive.canonical.com/ubuntu xenial partnerdeb-src http://archive.canonical.com/ubuntu xenial partnerdeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse#tsinghua.edudeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricteddeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricteddeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial universedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates universedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial multiversedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates multiversedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiversedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricteddeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security universedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security multiverse#neu.edudeb-src http://mirror.neu.edu.cn/ubuntu/ xenial main restricted #Added by software-propertiesdeb http://mirror.neu.edu.cn/ubuntu/ xenial main restricteddeb-src http://mirror.neu.edu.cn/ubuntu/ xenial restricted multiverse universe #Added by software-propertiesdeb http://mirror.neu.edu.cn/ubuntu/ xenial-updates main restricteddeb-src http://mirror.neu.edu.cn/ubuntu/ xenial-updates main restricted multiverse universedeb http://mirror.neu.edu.cn/ubuntu/ xenial universedeb http://mirror.neu.edu.cn/ubuntu/ xenial-updates universedeb http://mirror.neu.edu.cn/ubuntu/ xenial multiversedeb http://mirror.neu.edu.cn/ubuntu/ xenial-updates multiversedeb http://mirror.neu.edu.cn/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirror.neu.edu.cn/ubuntu/ xenial-backports main restricted universe multiversedeb http://archive.canonical.com/ubuntu xenial partnerdeb-src http://archive.canonical.com/ubuntu xenial partnerdeb http://mirror.neu.edu.cn/ubuntu/ xenial-security main restricteddeb-src http://mirror.neu.edu.cn/ubuntu/ xenial-security main restricted multiverse universedeb http://mirror.neu.edu.cn/ubuntu/ xenial-security universedeb http://mirror.neu.edu.cn/ubuntu/ xenial-security multiverse 4.执行update命令更新1apt-get update","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://yongchao.tech:8080/tags/ubuntu/"}]},{"title":"css各种情况下的居中","slug":"css各种情况下的居中","date":"2019-02-27T15:39:58.000Z","updated":"2019-09-07T07:24:23.786Z","comments":true,"path":"2019/02/27/css各种情况下的居中/","link":"","permalink":"http://yongchao.tech:8080/2019/02/27/css各种情况下的居中/","excerpt":"1.水平居中行内元素只需要把行内元素包裹在一个属性display为block的父层元素中，并且把父层元素添加text-align: center即可。适用元素：文字，链接，及其其它inline或者inline-*类型元素（inline-block，inline-table，inline-flex ) 2.水平居中(多个块状元素居中)1. 如果页面里有多个块状元素需要水平排列居中，可以将元素的display属性设置为inline-block，并且把父元素的text-align属性设置为center即可实现。 2. 使用flex布局解决，父元素定义display:flex; 3.垂直居中（单行、多行的元素居中）当一个行内元素，即inline，inline-*类型的元素需要居中的话，可以将它的height和line-height同时设置为父元素的高度即可实现垂直居中效果。 多行元素居中： 组合使用display:table-cell和vertical-align:middle属性来定义需要居中的元素的父容器元素生成效果","text":"1.水平居中行内元素只需要把行内元素包裹在一个属性display为block的父层元素中，并且把父层元素添加text-align: center即可。适用元素：文字，链接，及其其它inline或者inline-*类型元素（inline-block，inline-table，inline-flex ) 2.水平居中(多个块状元素居中)1. 如果页面里有多个块状元素需要水平排列居中，可以将元素的display属性设置为inline-block，并且把父元素的text-align属性设置为center即可实现。 2. 使用flex布局解决，父元素定义display:flex; 3.垂直居中（单行、多行的元素居中）当一个行内元素，即inline，inline-*类型的元素需要居中的话，可以将它的height和line-height同时设置为父元素的高度即可实现垂直居中效果。 多行元素居中： 组合使用display:table-cell和vertical-align:middle属性来定义需要居中的元素的父容器元素生成效果 4.垂直居中（未知块状元素高度）12345.item&#123; top: 50%; position: absolute; transform: translateY(-50%); /* 这里我们使用css3的transform来达到类似效果 */&#125; 5.水平垂直居中（使用flex布局实现）123456789.parent&#123; display: flex; justify-content:center; align-items: center; /* 注意这里需要设置高度来查看垂直居中效果 */ background: #AAA; height: 300px;&#125; 6.水平垂直居中(已知高度和宽度的元素解决方案)设置元素定位为absolute，并且设置top, left绝对值为50%，margin-top和margin-left为元素高度一半的负值即可，如下： 1234567.item&#123; position: absolute; top: 50%; left: 50%; margin-top: -75px; margin-left: -75px;&#125; 7.水平垂直居中（未知高度和宽度元素解决方案）使用类似的transform属性来定义，即可实现，如下： 123456.item&#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; 8.水平居中总结 水平居中之inline-block+text-align 兼容性非常好 inline+zoom:1 //兼容IE8以下 child会继承text-align:center，需要对子元素进行reset 水平居中之table+margin table元素宽度为内容宽度 只需要设置child ,IE6 7可以child可以采用table的方式如th tr来实现 水平居中之absolute+transform 脱离文档流 不会对其他元素产生影响 不兼容低版本IE 水平居中之flex+justify-content 123.child&#123; margin: 0 auto&#125; -不兼容低版本IE","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yongchao.tech:8080/tags/css/"}]}]}