<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tim上校的小屋</title>
  
  <subtitle>A fast, simple &amp; powerful blog framework powered by Node.js.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yongchao.tech:8080/"/>
  <updated>2019-10-16T02:40:37.160Z</updated>
  <id>http://yongchao.tech:8080/</id>
  
  <author>
    <name>yongchao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue组件生命周期</title>
    <link href="http://yongchao.tech:8080/2019/10/16/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yongchao.tech:8080/2019/10/16/生命周期/</id>
    <published>2019-10-16T10:36:39.000Z</published>
    <updated>2019-10-16T02:40:37.160Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h3 id="单个组件的生命周期"><a href="#单个组件的生命周期" class="headerlink" title="单个组件的生命周期"></a>单个组件的生命周期</h3><p><img src="/images/vue/562EB77D-1EFF-403B-ADAC-78D83DC7C898.png" alt="d35ef48bce6fd2950ef8f54cd3ac7f75.png"></p><p>分为三个阶段：</p><ul><li><p>初始化阶段：</p><ol><li>只有默认的事件，没有data,methods</li><li>beforeCreate</li><li>监听对象和初始化事件坚挺</li><li>created 此时已经可以访问data和methods</li><li>内存中编译好模版</li><li>beforeMount 此时页面仍然是旧的，没有挂载到上面</li><li>vm.$el 替换 el ，挂载页面</li><li>mounted</li><li>挂载完成，页面此时是最新的</li></ol></li><li><p>运行阶段：</p><ol><li>监听数据变化</li><li>beforeUpdate</li><li>diff, 虚拟dom 重新绘制, patch</li><li>updated</li></ol></li><li>销毁阶段：<ol><li>beforeDestroy 此时仍然可以正常访问data, methods</li><li>关闭watchers和子组件的事件监听</li><li>destroyed</li></ol></li></ul><h3 id="Vue-的父组件和子组件生命周期钩子函数执行顺序可以归类为以下-4-部分："><a href="#Vue-的父组件和子组件生命周期钩子函数执行顺序可以归类为以下-4-部分：" class="headerlink" title="Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分："></a>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</h3><h4 id="加载渲染过程"><a href="#加载渲染过程" class="headerlink" title="加载渲染过程"></a>加载渲染过程</h4><p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p><h4 id="子组件更新过程"><a href="#子组件更新过程" class="headerlink" title="子组件更新过程"></a>子组件更新过程</h4><p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p><h4 id="父组件更新过程"><a href="#父组件更新过程" class="headerlink" title="父组件更新过程"></a>父组件更新过程</h4><p>父 beforeUpdate -&gt; 父 updated</p><h4 id="销毁过程"><a href="#销毁过程" class="headerlink" title="销毁过程"></a>销毁过程</h4><p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h3 id=&quot;单个组件的生命周期&quot;&gt;&lt;a href=&quot;#单个组件的生命周期&quot; class=&quot;headerlink&quot; title=&quot;单个组件的生命周期&quot;&gt;&lt;/a&gt;单个组件的生命周期&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/vue/562EB77
      
    
    </summary>
    
    
      <category term="vue" scheme="http://yongchao.tech:8080/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>webpack配置</title>
    <link href="http://yongchao.tech:8080/2019/10/11/webpack%E9%85%8D%E7%BD%AE/"/>
    <id>http://yongchao.tech:8080/2019/10/11/webpack配置/</id>
    <published>2019-10-11T00:26:56.000Z</published>
    <updated>2019-10-16T02:16:33.629Z</updated>
    
    <content type="html"><![CDATA[<h4 id="devtool"><a href="#devtool" class="headerlink" title="devtool"></a>devtool</h4><p>如果是生产环境,压根不应该有devtool这个选项，这样build之后不会产生map文件，如果需要map文件用来方便查找问题，则设置devtool就行</p><h4 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">performance: &#123;</span><br><span class="line">    hints: &apos;warning&apos;, // false | warning | error</span><br><span class="line">    maxEntrypointSize: 1048576, // 入口文件最大值为1M</span><br><span class="line">    maxAssetSize: 3145728, // 资源文件最大值为3M</span><br><span class="line">    assetFilter: function (assetFilename) &#123;</span><br><span class="line">      // 只给出js文件的性能提示</span><br><span class="line">      return assetFilename.endsWith(&apos;.js&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="resolve-alias用来设置快捷方式"><a href="#resolve-alias用来设置快捷方式" class="headerlink" title="resolve.alias用来设置快捷方式"></a>resolve.alias用来设置快捷方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line">    // 只能匹配到vue$结尾的字符串</span><br><span class="line">    // 比如：import Test1 from &apos;vue&apos;;</span><br><span class="line">    // 不能匹配 import Test1 from &apos;vue-router&apos;;</span><br><span class="line">    vue$: &apos;vue/dist/vue.esm.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  // 自动解析确定的扩展, ps: import File from &apos;../path/to/file&apos;;</span><br><span class="line"></span><br><span class="line">  extensions: [&apos;*&apos;, &apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h4><p>防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖(external dependencies)。</p><p>例如，从 CDN 引入 jQuery，而不是把它打包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">externals: &#123;</span><br><span class="line">    highcharts: &#123;</span><br><span class="line">      root: &apos;Highcharts&apos;,</span><br><span class="line">      commonjs: &apos;highcharts&apos;,</span><br><span class="line">      commonjs2: &apos;highcharts&apos;,</span><br><span class="line">      amd: &apos;highcharts&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><h4 id="library-和-libraryTarget"><a href="#library-和-libraryTarget" class="headerlink" title="library 和 libraryTarget"></a>library 和 libraryTarget</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: &apos;[name].js&apos;,</span><br><span class="line">    // 以何种形式暴露library， 指的是暴露出来的名字</span><br><span class="line">    library: &apos;HighchartsVueXyc&apos;,</span><br><span class="line">    // 选项将导致 bundle 带有更完整的模块头部，以确保与各种模块系统的兼容性。</span><br><span class="line">    // 将你的 library 暴露为所有的模块定义下都可运行的方式。它将在 CommonJS, AMD 环境下运行，或将模块导出到 global 下的变量。</span><br><span class="line">    libraryTarget: &apos;umd&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;./dist&apos;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;devtool&quot;&gt;&lt;a href=&quot;#devtool&quot; class=&quot;headerlink&quot; title=&quot;devtool&quot;&gt;&lt;/a&gt;devtool&lt;/h4&gt;&lt;p&gt;如果是生产环境,压根不应该有devtool这个选项，这样build之后不会产生map文件，如果需要m
      
    
    </summary>
    
    
      <category term="js" scheme="http://yongchao.tech:8080/tags/js/"/>
    
      <category term="webpack" scheme="http://yongchao.tech:8080/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack前端页面分析插件</title>
    <link href="http://yongchao.tech:8080/2019/09/18/webpack%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%88%86%E6%9E%90%E6%8F%92%E4%BB%B6/"/>
    <id>http://yongchao.tech:8080/2019/09/18/webpack前端页面分析插件/</id>
    <published>2019-09-17T19:23:07.000Z</published>
    <updated>2019-09-17T11:48:53.079Z</updated>
    
    <content type="html"><![CDATA[<p>1.添加插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install webpack-bundle-analyzer -save</span><br></pre></td></tr></table></figure></p><ol start="2"><li>vue.config.js文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">chainWebpack: config =&gt; &#123;</span><br><span class="line">   // 运行npm run analyze 显示性能分析</span><br><span class="line">   if (process.env.analyze &amp;&amp; process.NODE_ENV === production) &#123;</span><br><span class="line">     config</span><br><span class="line">       .plugin(&quot;webpack-bundle-analyzer&quot;)</span><br><span class="line">       .use(require(&quot;webpack-bundle-analyzer&quot;).BundleAnalyzerPlugin);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></li></ol><p>3.scripts中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;analyz&quot;: &quot;NODE_ENV=production analyze=true npm run build&quot;</span><br></pre></td></tr></table></figure></p><ol start="4"><li>运行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run analyze</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.添加插件&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="vue" scheme="http://yongchao.tech:8080/tags/vue/"/>
    
      <category term="js" scheme="http://yongchao.tech:8080/tags/js/"/>
    
      <category term="webpack" scheme="http://yongchao.tech:8080/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>vue-cli3中iview按需引入</title>
    <link href="http://yongchao.tech:8080/2019/09/18/vue-cli3%E4%B8%ADiview%E6%8C%89%E9%9C%80%E5%BC%95%E5%85%A5/"/>
    <id>http://yongchao.tech:8080/2019/09/18/vue-cli3中iview按需引入/</id>
    <published>2019-09-17T19:16:59.000Z</published>
    <updated>2019-09-17T11:22:30.012Z</updated>
    
    <content type="html"><![CDATA[<p>1.安装babel-plugin-import插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install babel-plugin-import --save-dev</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>在文件.babelrc中添加配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;plugins&quot;: [</span><br><span class="line">    &quot;transform-vue-jsx&quot;, &quot;transform-runtime&quot;,</span><br><span class="line">    [&quot;import&quot;, &#123;</span><br><span class="line">      &quot;libraryName&quot;: &quot;iview&quot;,</span><br><span class="line">      &quot;libraryDirectory&quot;: &quot;src/components&quot;</span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>在plugins文件夹中新建一个iview.js文件</p><figure class="highlight plain"><figcaption><span>Vue from 'vue'</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">import &apos;iview/dist/styles/iview.css&apos;</span><br><span class="line">import &#123;</span><br><span class="line">  Row,</span><br><span class="line">  Col,</span><br><span class="line">  Switch,</span><br><span class="line">  Form,</span><br><span class="line">  FormItem,</span><br><span class="line">  Select,</span><br><span class="line">  Input,</span><br><span class="line">  InputNumber,</span><br><span class="line">  Button,</span><br><span class="line">  Icon,</span><br><span class="line">  Card,</span><br><span class="line">  Modal,</span><br><span class="line">  Menu,</span><br><span class="line">  MenuItem,</span><br><span class="line">  Submenu,</span><br><span class="line">  Message,</span><br><span class="line">  Notice,</span><br><span class="line">  Layout,</span><br><span class="line">  Sider,</span><br><span class="line">  Content,</span><br><span class="line">  Tag,</span><br><span class="line">  Table,</span><br><span class="line">  Poptip,</span><br><span class="line">  Page,</span><br><span class="line">  Timeline,</span><br><span class="line">  TimelineItem,</span><br><span class="line">  Tabs,</span><br><span class="line">  TabPane,</span><br><span class="line">  Tooltip,</span><br><span class="line">  Alert,</span><br><span class="line">  Checkbox,</span><br><span class="line">  CheckboxGroup,</span><br><span class="line">  RadioGroup,</span><br><span class="line">  Radio</span><br><span class="line">&#125; from &apos;iview&apos;</span><br><span class="line"></span><br><span class="line">Vue.component(&apos;Row&apos;, Row)</span><br><span class="line">Vue.component(&apos;Col&apos;, Col)</span><br><span class="line">Vue.component(&apos;iSwitch&apos;, Switch)</span><br><span class="line">Vue.component(&apos;Form&apos;, Form)</span><br><span class="line">Vue.component(&apos;FormItem&apos;, FormItem)</span><br><span class="line">Vue.component(&apos;Select&apos;, Select)</span><br><span class="line">Vue.component(&apos;Input&apos;, Input)</span><br><span class="line">Vue.component(&apos;InputNumber&apos;, InputNumber)</span><br><span class="line">Vue.component(&apos;Button&apos;, Button)</span><br><span class="line">Vue.component(&apos;Icon&apos;, Icon)</span><br><span class="line">Vue.component(&apos;Card&apos;, Card)</span><br><span class="line">Vue.component(&apos;Modal&apos;, Modal)</span><br><span class="line">Vue.component(&apos;Card&apos;, Card)</span><br><span class="line">Vue.component(&apos;Menu&apos;, Menu)</span><br><span class="line">Vue.component(&apos;Submenu&apos;, Submenu)</span><br><span class="line">Vue.component(&apos;MenuItem&apos;, MenuItem)</span><br><span class="line">Vue.component(&apos;Layout&apos;, Layout)</span><br><span class="line">Vue.component(&apos;Sider&apos;, Sider)</span><br><span class="line">Vue.component(&apos;Content&apos;, Content)</span><br><span class="line">Vue.component(&apos;Tag&apos;, Tag)</span><br><span class="line">Vue.component(&apos;Table&apos;, Table)</span><br><span class="line">Vue.component(&apos;Poptip&apos;, Poptip)</span><br><span class="line">Vue.component(&apos;Page&apos;, Page)</span><br><span class="line">Vue.component(&apos;Timeline&apos;, Timeline)</span><br><span class="line">Vue.component(&apos;TimelineItem&apos;, TimelineItem)</span><br><span class="line">Vue.component(&apos;Tabs&apos;, Tabs)</span><br><span class="line">Vue.component(&apos;TabPane&apos;, TabPane)</span><br><span class="line">Vue.component(&apos;Tooltip&apos;, Tooltip)</span><br><span class="line">Vue.component(&apos;Alert&apos;, Alert)</span><br><span class="line">Vue.component(&apos;Checkbox&apos;, Checkbox)</span><br><span class="line">Vue.component(&apos;CheckboxGroup&apos;, CheckboxGroup)</span><br><span class="line">Vue.component(&apos;RadioGroup&apos;, RadioGroup)</span><br><span class="line">Vue.component(&apos;Radio&apos;, Radio)</span><br><span class="line"></span><br><span class="line">Vue.component(&apos;Message&apos;, Message)</span><br><span class="line">Vue.component(&apos;Notice&apos;, Notice)</span><br></pre></td></tr></table></figure></li></ol><p>4.在main.js文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// import iView from &apos;iview&apos;</span><br><span class="line">// Vue.use(iView)</span><br><span class="line">import &apos;@/plugins/iview</span><br></pre></td></tr></table></figure></p><ol start="5"><li>到这里基本完成，但是还有一些iview的全局API是需要额外处理的，这里就不多说了</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.安装babel-plugin-import插件&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td
      
    
    </summary>
    
    
      <category term="vue" scheme="http://yongchao.tech:8080/tags/vue/"/>
    
      <category term="js" scheme="http://yongchao.tech:8080/tags/js/"/>
    
      <category term="webpack" scheme="http://yongchao.tech:8080/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>proxy体验</title>
    <link href="http://yongchao.tech:8080/2019/09/17/proxy%E4%BD%93%E9%AA%8C/"/>
    <id>http://yongchao.tech:8080/2019/09/17/proxy体验/</id>
    <published>2019-09-16T19:22:32.000Z</published>
    <updated>2019-09-16T12:45:46.327Z</updated>
    
    <content type="html"><![CDATA[<h3 id="todoList"><a href="#todoList" class="headerlink" title="todoList"></a>todoList</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; id=&quot;input&quot;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        TODO:</span><br><span class="line">        &lt;span id=&quot;text&quot;&gt;&lt;/span&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;button id=&quot;btn&quot;&gt;Add To Todo List&lt;/button&gt;</span><br><span class="line">      &lt;ul id=&quot;list&quot;&gt;&lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      const input = document.getElementById(&apos;input&apos;)</span><br><span class="line">    const text = document.getElementById(&apos;text&apos;)</span><br><span class="line">    const list = document.getElementById(&apos;list&apos;)</span><br><span class="line">    const btn = document.getElementById(&apos;btn&apos;)</span><br><span class="line"></span><br><span class="line">    let render</span><br><span class="line"></span><br><span class="line">    const inputObj = new Proxy(&#123;&#125;, &#123;</span><br><span class="line">      get (target, key, receiver) &#123;</span><br><span class="line">        return Reflect.get(target, key, receiver)</span><br><span class="line">      &#125;,</span><br><span class="line">      set (target, key, value, receiver) &#123;</span><br><span class="line">        if (key === &apos;text&apos;) &#123;</span><br><span class="line">          input.value = value</span><br><span class="line">          text.innerHTML = value</span><br><span class="line">        &#125;</span><br><span class="line">        return Reflect.set(target, key, value, receiver)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    class Render &#123;</span><br><span class="line">      constructor (arr) &#123;</span><br><span class="line">        this.arr = arr</span><br><span class="line">      &#125;</span><br><span class="line">      init () &#123;</span><br><span class="line">        const fragment = document.createDocumentFragment()</span><br><span class="line">        for (let i = 0; i &lt; this.arr.length; i++) &#123;</span><br><span class="line">          const li = document.createElement(&apos;li&apos;)</span><br><span class="line">          li.textContent = this.arr[i]</span><br><span class="line">          fragment.appendChild(li)</span><br><span class="line">        &#125;</span><br><span class="line">        list.appendChild(fragment)</span><br><span class="line">      &#125;</span><br><span class="line">      addList (val) &#123;</span><br><span class="line">        const li = document.createElement(&apos;li&apos;)</span><br><span class="line">        li.textContent = val</span><br><span class="line">        list.appendChild(li)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const todoList = new Proxy([], &#123;</span><br><span class="line">      get (target, key, receiver) &#123;</span><br><span class="line">        return Reflect.get(target, key, receiver)</span><br><span class="line">      &#125;,</span><br><span class="line">      set (target, key, value, receiver) &#123;</span><br><span class="line">        console.log(target, key, value, receiver)</span><br><span class="line">        if (key !== &apos;length&apos;) &#123;</span><br><span class="line">          render.addList(value)</span><br><span class="line">        &#125;</span><br><span class="line">        return Reflect.set(target, key, value, receiver)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    window.onload = () =&gt; &#123;</span><br><span class="line">      render = new Render([])</span><br><span class="line">      render.init()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    input.addEventListener(&apos;keyup&apos;, e =&gt; &#123;</span><br><span class="line">      inputObj.text = e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    btn.addEventListener(&apos;click&apos;, () =&gt; &#123;</span><br><span class="line">      todoList.push(inputObj.text) // 每次 增加和删除 都会引起 length 的改变</span><br><span class="line">      inputObj.text = &apos;&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(todoList)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;todoList&quot;&gt;&lt;a href=&quot;#todoList&quot; class=&quot;headerlink&quot; title=&quot;todoList&quot;&gt;&lt;/a&gt;todoList&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="es6" scheme="http://yongchao.tech:8080/categories/es6/"/>
    
    
      <category term="js" scheme="http://yongchao.tech:8080/tags/js/"/>
    
      <category term="proxy" scheme="http://yongchao.tech:8080/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>css特性</title>
    <link href="http://yongchao.tech:8080/2019/09/16/css%E7%89%B9%E6%80%A7/"/>
    <id>http://yongchao.tech:8080/2019/09/16/css特性/</id>
    <published>2019-09-16T00:11:25.000Z</published>
    <updated>2019-09-15T16:23:55.787Z</updated>
    
    <content type="html"><![CDATA[<h3 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h3><ul><li>！important  Infinity</li><li>行间样式         1000 </li><li>id               100</li><li>class |属性|伪类   10</li><li>标签选择器|伪元素    1</li><li>通配符             0</li><li>继承<blockquote><p>不存在进位的情况，只要高位大，就不用比了，权重一定高</p></blockquote></li></ul><a id="more"></a><h3 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h3><p>当同一个元素的有多个样式且权重相同时，后面覆盖前面的</p><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><ol><li>content</li><li>padding</li><li>border</li><li>margin<blockquote><p>box-sizing属性可以设置盒模型</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;权重&quot;&gt;&lt;a href=&quot;#权重&quot; class=&quot;headerlink&quot; title=&quot;权重&quot;&gt;&lt;/a&gt;权重&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;！important  Infinity&lt;/li&gt;
&lt;li&gt;行间样式         1000 &lt;/li&gt;
&lt;li&gt;id               100&lt;/li&gt;
&lt;li&gt;class |属性|伪类   10&lt;/li&gt;
&lt;li&gt;标签选择器|伪元素    1&lt;/li&gt;
&lt;li&gt;通配符             0&lt;/li&gt;
&lt;li&gt;继承&lt;blockquote&gt;
&lt;p&gt;不存在进位的情况，只要高位大，就不用比了，权重一定高&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://yongchao.tech:8080/tags/css/"/>
    
      <category term="权重" scheme="http://yongchao.tech:8080/tags/%E6%9D%83%E9%87%8D/"/>
    
      <category term="盒模型" scheme="http://yongchao.tech:8080/tags/%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>模拟一些常见的js函数</title>
    <link href="http://yongchao.tech:8080/2019/09/16/%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84js%E5%87%BD%E6%95%B0/"/>
    <id>http://yongchao.tech:8080/2019/09/16/模拟一些常见的js函数/</id>
    <published>2019-09-15T23:29:42.000Z</published>
    <updated>2019-09-15T15:31:02.142Z</updated>
    
    <content type="html"><![CDATA[<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myapply = function(context, arr) &#123;</span><br><span class="line">  var context = Object(context) || window;</span><br><span class="line">  context.fn = this;</span><br><span class="line"></span><br><span class="line">  var result;</span><br><span class="line">  if (!arr) &#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    var args = [];</span><br><span class="line">    for (var i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      args.push(&quot;arr[&quot; + i + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    result = eval(&quot;context.fn(&quot; + args + &quot;)&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  delete context.fn;</span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall = function(context) &#123;</span><br><span class="line">  context.fn = this</span><br><span class="line">  let args = Array.prototype.slice(arguments, 1)</span><br><span class="line">  let result = context.fn(...args)</span><br><span class="line">  delete context.fn</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>都知道instanceof实际上是用来判断对象的原型链上面能不能找到指定类型的原型。然后就按照这个原理来写歌demo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function instance_of(l, r)&#123;</span><br><span class="line">    let proto = r.__proto__</span><br><span class="line">    l = l.__proto__</span><br><span class="line">    while(l) &#123;</span><br><span class="line">        if (l === proto) return true</span><br><span class="line">        if(l === null) return false</span><br><span class="line">        l = l.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;apply&quot;&gt;&lt;a href=&quot;#apply&quot; class=&quot;headerlink&quot; title=&quot;apply&quot;&gt;&lt;/a&gt;apply&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
    
      <category term="js" scheme="http://yongchao.tech:8080/tags/js/"/>
    
      <category term="模拟函数" scheme="http://yongchao.tech:8080/tags/%E6%A8%A1%E6%8B%9F%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>stopImmediatePropagation和stopPropagation的区别</title>
    <link href="http://yongchao.tech:8080/2019/09/16/stopImmediatePropagation%E5%92%8CstopPropagation%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yongchao.tech:8080/2019/09/16/stopImmediatePropagation和stopPropagation的区别/</id>
    <published>2019-09-15T18:22:11.000Z</published>
    <updated>2019-09-15T10:28:02.921Z</updated>
    
    <content type="html"><![CDATA[<p>在事件处理程序中，每个事件处理程序中间都会有一个event对象，而这个event对象有两个方法，一个是stopPropagation方法，一个是stopImmediatePropagation方法，两个方法只差一个Immediate，这里就说说这两个方法的区别<br><a id="more"></a></p><h3 id="stopImmediatePropagation方法："><a href="#stopImmediatePropagation方法：" class="headerlink" title="stopImmediatePropagation方法："></a>stopImmediatePropagation方法：</h3><p>stopImmediatePropagation方法作用在当前节点以及事件链上的所有后续节点上，目的是在执行完当前事件处理程序之后，停止当前节点以及所有后续节点的事件处理程序的运行</p><h3 id="stopPropagation方法"><a href="#stopPropagation方法" class="headerlink" title="stopPropagation方法"></a>stopPropagation方法</h3><p>stopPropagation方法作用在后续节点上，目的在执行完绑定到当前元素上的所有事件处理程序之后，停止执行所有后续节点的事件处理程序</p><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><p>从概念上讲，在调用完stopPropagation函数之后，就会立即停止对后续节点的访问，但是会执行完绑定到当前节点上的所有事件处理程序；而调用stopImmediatePropagation函数之后，除了所有后续节点，绑定到当前元素上的、当前事件处理程序之后的事件处理程序就不会再执行了</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// html</span><br><span class="line">&lt;div id = &quot;div1&quot;&gt;</span><br><span class="line">    &lt;button id = &quot;button1&quot;&gt;&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// js</span><br><span class="line">　var div = document.getElementById(&quot;div1&quot;);</span><br><span class="line">  var btn = document.getElementById(&quot;button1&quot;);</span><br><span class="line">          </span><br><span class="line">  div.addEventListener(&quot;click&quot; , function(e)&#123;</span><br><span class="line">    // e.stopImmediatePropagation()</span><br><span class="line">    e.stopPropagation()</span><br><span class="line">    alert(&quot;第一次执行&quot;);</span><br><span class="line">  &#125; , true);        //1</span><br><span class="line">  div.addEventListener(&quot;click&quot; , function()&#123;alert(&quot;第二次执行&quot;);&#125; , true);        //2</span><br><span class="line">  btn.addEventListener(&quot;click&quot; , function()&#123;alert(&quot;button 执行&quot;);&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>1.在这里，给 1 函数alert后加上stopImmediatePropagation， 那么之后弹出窗口“第一次执行”<br>2.但是如果给 1 函数alert后加上stopPropagation ， 那么之后会弹出窗口“第一次执行”，“第二次执行”两个窗口</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在事件处理程序中，每个事件处理程序中间都会有一个event对象，而这个event对象有两个方法，一个是stopPropagation方法，一个是stopImmediatePropagation方法，两个方法只差一个Immediate，这里就说说这两个方法的区别&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yongchao.tech:8080/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js的事件模型</title>
    <link href="http://yongchao.tech:8080/2019/09/16/js%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yongchao.tech:8080/2019/09/16/js的事件模型/</id>
    <published>2019-09-15T18:21:20.000Z</published>
    <updated>2019-09-15T10:26:59.567Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>其实，说起js的事件模型，有点基础的都能说几句， 分为三个阶段， 捕获-事件处理-冒泡，巴拉巴拉…。但是这并没有考虑到我们 <strong>“伟大”</strong> 的IE，有点考虑的不够全面。接下来系统性的详细的讲一波儿</p><h3 id="事件模型的前世今生"><a href="#事件模型的前世今生" class="headerlink" title="事件模型的前世今生"></a>事件模型的前世今生</h3><p>故事源于传说中的浏览器大战，微软的 IE 和网景的Netspace Navigator。<br>IE的事件流是冒泡 从里面往上面冒, netscape是从外部元素往内部元素捕获;后来出来了个W3C委员会，想要统一，为了兼容，宣布了后来的W3C事件模型（捕获-事件处理-冒泡），从此天下一统。 </p><a id="more"></a><h3 id="事件的三种模型"><a href="#事件的三种模型" class="headerlink" title="事件的三种模型"></a>事件的三种模型</h3><h4 id="DOM0-原始事件模型"><a href="#DOM0-原始事件模型" class="headerlink" title="DOM0(原始事件模型)"></a>DOM0(原始事件模型)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;myButton&quot; type=&quot;button&quot; value=&quot;Press Me&quot; onclick=&quot;alert(&apos;thanks&apos;);&quot; &gt;</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">document.getElementById(&quot;myButton&quot;).onclick = function () &#123;alert(&apos;thanks&apos;);&#125;</span><br></pre></td></tr></table></figure><p>通常情况下事件监听函数如果返回一个值并且是false，则会阻止浏览器执行默认的动作</p><p>优点：</p><blockquote><p>所有浏览器都兼容</p></blockquote><p>缺点：</p><blockquote><ol><li>代码耦合严重</li><li>事件监听器只能有一个，重复赋值，后面会覆盖前面的</li><li>没有事件的冒泡、委托等机制完成更为负载的情况</li></ol></blockquote><h4 id="IE"><a href="#IE" class="headerlink" title="IE"></a>IE</h4><p>IE将event作为window的一个属性。IE的事件模型只有两步，执行处理函数，然后冒泡。<br>添加和移除事件监听的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">attachEvent( &quot;eventType&quot;,&quot;handler&quot;)</span><br><span class="line">//其中evetType为事件的类型，如onclick，注意要加’on’。</span><br><span class="line"></span><br><span class="line">detachEvent(&quot;eventType&quot;,&quot;handler&quot; )</span><br></pre></td></tr></table></figure></p><h4 id="DOM2"><a href="#DOM2" class="headerlink" title="DOM2"></a>DOM2</h4><p>事件分为三个阶段： 捕获-处理目标-冒泡（IE8以及更早版本不支持DOM事件流）</p><ol><li>捕获阶段： 事件被从document一直向下传播到目标元素,在这过程中依次检查经过的节点是否注册了该事件的监听函数，若有则执行。</li><li>事件处理： 事件到达目标元素,执行目标元素的事件处理函数</li><li>冒泡：    事件从目标元素上升一直到达document，同样依次检查经过的节点是否注册了该事件的监听函数，有则执行。</li></ol><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><h4 id="常用对象和属性"><a href="#常用对象和属性" class="headerlink" title="常用对象和属性"></a>常用对象和属性</h4><ul><li>DOM事件模型中的事件对象常用属性:</li></ul><ol><li>type用于获取事件类型</li><li>currentTarget 当前正在处理的事件的节点，在事件捕获或冒泡阶段</li><li>target获取事件目标</li><li>stopPropagation()阻止事件冒泡</li><li>preventDefault()阻止事件默认行为</li><li>keyCode：按下的键的值；</li><li>stopImmediatePropagation() (DOM3)阻止任何事件的运行；详情看<a href="http://39.105.159.58:8080/2019/09/16/stopImmediatePropagation%E5%92%8CstopPropagation%E7%9A%84%E5%8C%BA%E5%88%AB/" target="_blank" rel="noopener">http://39.105.159.58:8080/2019/09/16/stopImmediatePropagation%E5%92%8CstopPropagation%E7%9A%84%E5%8C%BA%E5%88%AB/</a></li></ol><ul><li>IE事件模型中的事件对象常用属性:</li></ul><ol><li>type用于获取事件类型</li><li>srcElement获取事件目标</li><li>cancelBubble阻止事件冒泡</li><li>returnValue阻止事件默认行为</li></ol><h4 id="事件对象中和定位相关的属性"><a href="#事件对象中和定位相关的属性" class="headerlink" title="事件对象中和定位相关的属性"></a>事件对象中和定位相关的属性</h4><ol><li>x/y与clientX/clientY值一样，表示距浏览器可视区域（工具栏除外区域）左/上的距离；</li><li>pageX/pageY，距页面左/上的距离，它与clientX/clientY的区别是不随滚动条的位置变化；</li><li>screenX/screenY，距计算机显示器左/上的距离，拖动你的浏览器窗口位置可以看到变化；</li><li>layerX/layerY与offsetX/offsetY值一样，表示距有定位属性的父元素左/上的距离。</li></ol><h3 id="事件委托-代理"><a href="#事件委托-代理" class="headerlink" title="事件委托/代理"></a>事件委托/代理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;li class=&quot;child&quot;&gt;1&lt;/li&gt;</span><br><span class="line">  &lt;li class=&quot;child&quot;&gt;2&lt;/li&gt;</span><br><span class="line">  &lt;li class=&quot;child&quot;&gt;3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  //父元素</span><br><span class="line">  var dom= document.getElementById(&apos;parent&apos;);</span><br><span class="line"></span><br><span class="line">  //父元素绑定事件，代理子元素的点击事件</span><br><span class="line">  dom.onclick= function(event) &#123;</span><br><span class="line">    var event= event || window.event;</span><br><span class="line">    var curTarget= event.target || event.srcElement;</span><br><span class="line"></span><br><span class="line">    if (curTarget.tagName.toLowerCase() == &apos;li&apos;) &#123; //找到被代理的节点</span><br><span class="line">      //事件处理</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>优点：</p><ol><li>节省内存占用，减少事件注册</li><li>新增子对象时无需再次对其绑定事件，适合动态添加元素</li></ol><h3 id="eventBus的事件模型"><a href="#eventBus的事件模型" class="headerlink" title="eventBus的事件模型"></a>eventBus的事件模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 完整的思路就是，使用一个map存储 type：处理函数</span><br><span class="line"> *  有两种存储形式</span><br><span class="line"> *  type: function</span><br><span class="line"> *  type: [function, funciton, ...]</span><br><span class="line"> *  删除和添加的时候考虑到这两种情况就行了</span><br><span class="line"> */</span><br><span class="line">class EventEmitter&#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this._events = this._events || new Map()</span><br><span class="line">    this._maxListeners = this._maxListeners || 10</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.emit = function(type, ...args)&#123;</span><br><span class="line">  let handler = this._events.get(type)</span><br><span class="line">  if (Array.isArray(handler)) &#123;</span><br><span class="line">    for(let i=0;i&lt;handler.length;i++) &#123;</span><br><span class="line">      if(args.length &gt; 0) &#123;</span><br><span class="line">        handler[i].apply(this, args)</span><br><span class="line">      &#125;else &#123;</span><br><span class="line">        handler[i].call(this)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    if(args.length &gt;0) &#123;</span><br><span class="line">      handler.apply(this, args)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      handler.call(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.addListener = function(type, fn) &#123;</span><br><span class="line">  const handler = this._events.get(type)</span><br><span class="line">  if(!handler) &#123;</span><br><span class="line">    this._events.set(type, handler)</span><br><span class="line">  &#125;else if(handler &amp;&amp; typeof handler === &apos;function&apos;) &#123;</span><br><span class="line">    this._events.set(type, [handler, fn])</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    handler.push(fn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.removeListener = function(type, fn) &#123;</span><br><span class="line">  const handler = this._events.get(type)</span><br><span class="line">  if(handler &amp;&amp; typeof handler === &apos;function&apos;) &#123;</span><br><span class="line">    this._events.delete(type)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    let position = -1</span><br><span class="line">    for (let i=0;i&lt;handler.length;i++) &#123;</span><br><span class="line">      if (handler[i] === fn) &#123;</span><br><span class="line">        position = i</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (position !== -1) &#123;</span><br><span class="line">      handler.splice(position, 1)</span><br><span class="line">      if (handler.length === 1) &#123;</span><br><span class="line">        this._events.set(type, handler[0])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return this</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;其实，说起js的事件模型，有点基础的都能说几句， 分为三个阶段， 捕获-事件处理-冒泡，巴拉巴拉…。但是这并没有考虑到我们 &lt;strong&gt;“伟大”&lt;/strong&gt; 的IE，有点考虑的不够全面。接下来系统性的详细的讲一波儿&lt;/p&gt;
&lt;h3 id=&quot;事件模型的前世今生&quot;&gt;&lt;a href=&quot;#事件模型的前世今生&quot; class=&quot;headerlink&quot; title=&quot;事件模型的前世今生&quot;&gt;&lt;/a&gt;事件模型的前世今生&lt;/h3&gt;&lt;p&gt;故事源于传说中的浏览器大战，微软的 IE 和网景的Netspace Navigator。&lt;br&gt;IE的事件流是冒泡 从里面往上面冒, netscape是从外部元素往内部元素捕获;后来出来了个W3C委员会，想要统一，为了兼容，宣布了后来的W3C事件模型（捕获-事件处理-冒泡），从此天下一统。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yongchao.tech:8080/tags/js/"/>
    
      <category term="事件模型" scheme="http://yongchao.tech:8080/tags/%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>装箱和拆箱</title>
    <link href="http://yongchao.tech:8080/2019/09/12/%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1/"/>
    <id>http://yongchao.tech:8080/2019/09/12/装箱和拆箱/</id>
    <published>2019-09-12T11:07:11.000Z</published>
    <updated>2019-09-12T03:11:11.748Z</updated>
    
    <content type="html"><![CDATA[<ul><li>装箱转换：把基本类型转换为对应的包装类型</li><li>拆箱操作：把引用类型转换为基本类型</li></ul><p>既然原始类型不能扩展属性和方法，那么我们是如何使用原始类型调用方法的呢？</p><p>每当我们操作一个基础类型时，后台就会自动创建一个包装类型的对象，从而让我们能够调用一些方法和属性，例如下面的代码：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;ConardLi&quot;;</span><br><span class="line">var name2 = name.substring(2);</span><br></pre></td></tr></table></figure><p>实际上发生了以下几个过程：</p><ol><li>创建一个String的包装类型实例</li><li>在实例上调用substring方法</li><li>销毁实例</li></ol><p>也就是说，我们使用基本类型调用方法，就会自动进行装箱和拆箱操作，相同的，我们使用Number和Boolean类型时，也会发生这个过程。</p><p>从引用类型到基本类型的转换，也就是拆箱的过程中，会遵循ECMAScript规范规定的toPrimitive原则，一般会调用引用类型的valueOf和toString方法，你也可以直接重写toPeimitive方法。一般转换成不同类型的值遵循的原则不同，例如：</p><ul><li>引用类型转换为Number类型，先调用valueOf，再调用toString</li><li>引用类型转换String类型, 先调用toString，再调用valueOf</li></ul><p>若valueOf和toString都不存在，或者没有返回基本类型，则抛出TypeError异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  valueOf: () =&gt; &#123; console.log(&apos;valueOf&apos;); return 123; &#125;,</span><br><span class="line">  toString: () =&gt; &#123; console.log(&apos;toString&apos;); return &apos;ConardLi&apos;; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj - 1);   // valueOf   122</span><br><span class="line">console.log(`$&#123;obj&#125;ConardLi`); // toString  ConardLiConardLi</span><br><span class="line"></span><br><span class="line">const obj2 = &#123;</span><br><span class="line">  [Symbol.toPrimitive]: () =&gt; &#123; console.log(&apos;toPrimitive&apos;); return 123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj2 - 1);   // valueOf   122</span><br><span class="line"></span><br><span class="line">const obj3 = &#123;</span><br><span class="line">  valueOf: () =&gt; &#123; console.log(&apos;valueOf&apos;); return &#123;&#125;; &#125;,</span><br><span class="line">  toString: () =&gt; &#123; console.log(&apos;toString&apos;); return &#123;&#125;; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj3 - 1);  </span><br><span class="line">// valueOf  </span><br><span class="line">// toString</span><br><span class="line">// TypeError</span><br></pre></td></tr></table></figure></p><p>除了程序中的自动拆箱和自动装箱，我们还可以手动进行拆箱和装箱操作。我们可以直接调用包装类型的valueOf或toString，实现拆箱操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var num =new Number(&quot;123&quot;);  </span><br><span class="line">console.log( typeof num.valueOf() ); //number</span><br><span class="line">console.log( typeof num.toString() ); //string</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;装箱转换：把基本类型转换为对应的包装类型&lt;/li&gt;
&lt;li&gt;拆箱操作：把引用类型转换为基本类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然原始类型不能扩展属性和方法，那么我们是如何使用原始类型调用方法的呢？&lt;/p&gt;
&lt;p&gt;每当我们操作一个基础类型时，后台就会自动创建一个包装类型的对象，从而让我们能够调用一些方法和属性，例如下面的代码：&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yongchao.tech:8080/tags/js/"/>
    
      <category term="类型" scheme="http://yongchao.tech:8080/tags/%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>判断类型的方式</title>
    <link href="http://yongchao.tech:8080/2019/09/12/%E5%88%A4%E6%96%AD%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://yongchao.tech:8080/2019/09/12/判断类型的方式/</id>
    <published>2019-09-12T11:04:47.000Z</published>
    <updated>2019-10-16T03:00:52.534Z</updated>
    
    <content type="html"><![CDATA[<h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><p>取值范围</p><ul><li>number</li><li>string</li><li>object</li><li>function</li><li>boolean</li><li>symbol</li><li>boolean</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typeof 12 // &apos;number&apos;</span><br><span class="line">typeof &apos;aa&apos; // &apos;string&apos;</span><br><span class="line">typeof false // &apos;boolean&apos;</span><br><span class="line">typeof &#123;&#125; // &apos;object&apos;</span><br><span class="line">typeof function()&#123;&#125; // &apos;function&apos;</span><br><span class="line">typeof [] // &apos;object&apos;</span><br><span class="line">typeof new Date() // &apos;object&apos;</span><br><span class="line">typeof Symbol() // &apos;symbol&apos;</span><br><span class="line">typeof /\w+/ig  // &apos;object&apos;</span><br></pre></td></tr></table></figure><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>instanceof操作符可以帮助我们判断引用类型具体是什么类型的对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[] instanceof Array // true</span><br><span class="line">new Date() instanceof Date // true</span><br><span class="line">new RegExp() instanceof RegExp // true</span><br></pre></td></tr></table></figure></p><p>我们先来回顾下原型链的几条规则：</p><pre><code>1.所有引用类型都具有对象特性，即可以自由扩展属性2.所有引用类型都具有一个__proto__（隐式原型）属性，是一个普通对象3.所有的函数都具有prototype（显式原型）属性，也是一个普通对象4.所有引用类型__proto__值指向它构造函数的prototype5.当试图得到一个对象的属性时，如果变量本身没有这个属性，则会去他的__proto__中去找</code></pre><p>[] instanceof Array实际上是判断Array.prototype是否在[]的原型链上。</p><p>所以，使用instanceof来检测数据类型，不会很准确，这不是它设计的初衷：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] instanceof Object // true</span><br><span class="line">function()&#123;&#125;  instanceof Object // true</span><br></pre></td></tr></table></figure></p><p>另外，使用instanceof也不能检测基本数据类型，所以instanceof并不是一个很好的选择。</p><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><p>上面我们在拆箱操作中提到了toString函数，我们可以调用它实现从引用类型的转换。</p><blockquote><p>每一个引用类型都有toString方法，默认情况下，toString()方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中type是对象的类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;;</span><br><span class="line">obj.toString() // [object Object]</span><br></pre></td></tr></table></figure></p></blockquote><p>注意，上面提到了如果此方法在自定义对象中未被覆盖，toString才会达到预想的效果，事实上，大部分引用类型比如Array、Date、RegExp等都重写了toString方法。</p><p>我们可以直接调用Object原型上未被覆盖的toString()方法，使用call来改变this指向来达到我们想要的效果。</p><p><img src="/.tech:8080//tyep_convert.png" alt="69d729d45ae5c456c6035c53f824b7d1.png"></p><h4 id="jquery中判断类型的方式"><a href="#jquery中判断类型的方式" class="headerlink" title="jquery中判断类型的方式"></a>jquery中判断类型的方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">var types = [</span><br><span class="line">  &apos;Boolean&apos;,</span><br><span class="line">  &apos;Number&apos;,</span><br><span class="line">  &apos;String&apos;,</span><br><span class="line">  &apos;Function&apos;,</span><br><span class="line">  &apos;Array&apos;,</span><br><span class="line">  &apos;Date&apos;,</span><br><span class="line">  &apos;RegExp&apos;,</span><br><span class="line">  &apos;Object&apos;,</span><br><span class="line">  &apos;Error&apos;,</span><br><span class="line">  &apos;Symbol&apos;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">var class2type = &#123;&#125;</span><br><span class="line"></span><br><span class="line">types.forEach(name =&gt; &#123;</span><br><span class="line">  class2type[`[object $&#123;name&#125;]`] = name.toLocaleLowerCase()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function type(obj) &#123;</span><br><span class="line">  if (obj == null) &#123;</span><br><span class="line">    return obj+&apos;&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  return typeof obj === &apos;object&apos; </span><br><span class="line">  ? class2type[Object.prototype.toString.call(obj)] || &apos;object&apos; </span><br><span class="line">  : typeof obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">测试：</span><br><span class="line">console.log(type(12))   // number</span><br><span class="line">console.log(type(&apos;12&apos;))  // string </span><br><span class="line">console.log(type(false))  // boolean</span><br><span class="line">console.log(type(&#123;&#125;))    // object</span><br><span class="line">console.log(type([]))  // object</span><br><span class="line">console.log(type(Symbol()))   //symbol</span><br><span class="line">console.log(type(function()&#123;&#125;))  //function</span><br><span class="line">console.log(type(undefined))     //undefined</span><br><span class="line">console.log(type(null))    // null</span><br><span class="line">console.log(type(Boolean(1)))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;typeof&quot;&gt;&lt;a href=&quot;#typeof&quot; class=&quot;headerlink&quot; title=&quot;typeof&quot;&gt;&lt;/a&gt;typeof&lt;/h4&gt;&lt;p&gt;取值范围&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;number&lt;/li&gt;
&lt;li&gt;string&lt;/li&gt;
&lt;li&gt;object&lt;/li&gt;
&lt;li&gt;function&lt;/li&gt;
&lt;li&gt;boolean&lt;/li&gt;
&lt;li&gt;symbol&lt;/li&gt;
&lt;li&gt;boolean&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yongchao.tech:8080/tags/js/"/>
    
      <category term="类型" scheme="http://yongchao.tech:8080/tags/%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>类型转换</title>
    <link href="http://yongchao.tech:8080/2019/09/12/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yongchao.tech:8080/2019/09/12/类型转换/</id>
    <published>2019-09-12T11:04:11.000Z</published>
    <updated>2019-09-12T03:10:02.238Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-类型转换规则"><a href="#1-类型转换规则" class="headerlink" title="1. 类型转换规则"></a>1. 类型转换规则</h4><p><img src="/images/leixingzhuanhuan.png" alt="1aa4dd552dadf8f2b6b10384bb7dd6fc.png"><br><a id="more"></a></p><h4 id="2-If语句和逻辑语句"><a href="#2-If语句和逻辑语句" class="headerlink" title="2. If语句和逻辑语句"></a>2. If语句和逻辑语句</h4><p>在if语句和逻辑语句中，如果只有单个变量，会先将变量转换为Boolean值，只有下面几种情况会转换成false，其余被转换成true：</p><ul><li>null</li><li>undefined</li><li>‘’</li><li>NaN</li><li>0</li><li>false</li></ul><h4 id="3-各种运数学算符"><a href="#3-各种运数学算符" class="headerlink" title="3.各种运数学算符"></a>3.各种运数学算符</h4><p>我们在对各种非Number类型运用数学运算符(- * /)时，会先将非Number类型转换为Number类型;</p><ul><li>1 - true // 0</li><li>1 - null // 1</li><li>1 * undefined // NaN</li><li>2 * [‘5’] //10</li></ul><blockquote><p>注意+是个例外，执行+操作符时：<br>1.当一侧为String类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。<br>2.当一侧为Number类型，另一侧为原始类型，则将原始类型转换为Number类型。<br>3.当一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后拼接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">123 + &apos;123&apos; // 123123   （规则1）</span><br><span class="line">123 + null  // 123    （规则2）</span><br><span class="line">123 + true // 124    （规则2）</span><br><span class="line">123 + &#123;&#125;  // 123[object Object]    （规则3）</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="4"><a href="#4" class="headerlink" title="4. =="></a>4. ==</h4><p>使用==时，若两侧类型相同，则比较结果和===相同，否则会发生隐式转换，使用==时发生的转换可以分为几种不同的情况（只考虑两侧类型不同）</p><h5 id="4-1-NaN"><a href="#4-1-NaN" class="headerlink" title="4-1. NaN"></a>4-1. NaN</h5><p>NaN和其他任何类型比较永远返回false(包括和他自己)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NaN == NaN // false</span><br></pre></td></tr></table></figure></p><h5 id="4-2-Boolean"><a href="#4-2-Boolean" class="headerlink" title="4-2. Boolean"></a>4-2. Boolean</h5><p>Boolean和其他任何类型比较，Boolean首先被转换为Number类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true == 1  // true </span><br><span class="line">true == &apos;2&apos;  // false</span><br><span class="line">true == [&apos;1&apos;]  // true</span><br><span class="line">true == [&apos;2&apos;]  // false</span><br></pre></td></tr></table></figure></p><blockquote><p>这里注意一个可能会弄混的点：undefined、null和Boolean比较，虽然undefined、null和false都很容易被想象成假值，但是他们比较结果是false，原因是false首先被转换成0</p></blockquote><h5 id="4-3-String和Number"><a href="#4-3-String和Number" class="headerlink" title="4-3.String和Number"></a>4-3.String和Number</h5><p>String和Number比较，先将String转换为Number类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">123 == &apos;123&apos; // true</span><br><span class="line">&apos;&apos; == 0 // true</span><br></pre></td></tr></table></figure></p><h5 id="4-4-null和undefined"><a href="#4-4-null和undefined" class="headerlink" title="4-4 null和undefined"></a>4-4 null和undefined</h5><p>null == undefined比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">null == undefined // true</span><br><span class="line">null == &apos;&apos;       // false</span><br><span class="line">null == 0        // false</span><br><span class="line">null == false    // false</span><br><span class="line">undefined == &apos;&apos;  // false</span><br><span class="line">undefined == 0   // false</span><br><span class="line">undefined == false // false</span><br></pre></td></tr></table></figure></p><h5 id="4-5-原始类型和引用类型"><a href="#4-5-原始类型和引用类型" class="headerlink" title="4-5 原始类型和引用类型"></a>4-5 原始类型和引用类型</h5><p>当原始类型和引用类型做比较时，对象类型会依照ToPrimitive规则转换为原始类型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;[object Object]&apos; == &#123;&#125; // true</span><br><span class="line">&apos;1,2,3&apos; == [1, 2, 3]   // true</span><br></pre></td></tr></table></figure></p><p>来看看下面这个比较：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] == ![] // true</span><br></pre></td></tr></table></figure></p><p>!的优先级高于==，![]首先会被转换为false，然后根据上面第三点，false转换成Number类型0，左侧[]转换为0，两侧比较相等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[null] == false     // true</span><br><span class="line">[undefined] == false // true</span><br></pre></td></tr></table></figure></p><p>根据数组的ToPrimitive规则，数组元素为null或undefined时，该元素被当做空字符串处理，所以[null]、[undefined]都会被转换为0。</p><blockquote><p>所以，说了这么多，推荐使用===来判断两个值是否相等…😭</p></blockquote><h4 id="有意思的面试题"><a href="#有意思的面试题" class="headerlink" title="有意思的面试题"></a>有意思的面试题</h4><p>一道经典的面试题，如何让：a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3。<br>根据上面的拆箱转换，以及==的隐式转换，我们可以轻松写出答案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">   value:[3,2,1],</span><br><span class="line">   valueOf: function () &#123;return this.value.pop(); &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">var a = &#123;</span><br><span class="line">   value:[1,2,3],</span><br><span class="line">   valueOf: function () &#123;return this.value.shift(); &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>对象和数字比较==，对象会隐式转换为number, 调用valueOf函数</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-类型转换规则&quot;&gt;&lt;a href=&quot;#1-类型转换规则&quot; class=&quot;headerlink&quot; title=&quot;1. 类型转换规则&quot;&gt;&lt;/a&gt;1. 类型转换规则&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/images/leixingzhuanhuan.png&quot; alt=&quot;1aa4dd552dadf8f2b6b10384bb7dd6fc.png&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yongchao.tech:8080/tags/js/"/>
    
      <category term="类型" scheme="http://yongchao.tech:8080/tags/%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>dataTable中自定义列排序问题</title>
    <link href="http://yongchao.tech:8080/2019/09/11/dataTable%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%97%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"/>
    <id>http://yongchao.tech:8080/2019/09/11/dataTable中自定义列排序问题/</id>
    <published>2019-09-10T22:49:54.000Z</published>
    <updated>2019-09-17T14:53:12.097Z</updated>
    
    <content type="html"><![CDATA[<p>在使用dataTables的时候，有些列中会是一些包含内容的按钮或链接，不是单纯的文字内容。那么dataTables会将这些内容视为字符串，进行排序，有时候这不符合我们的期望。那么就需要自己能够灵活的指定某些列按照我们的意愿进行排序，幸运的是dataTable支持这样的插件拓展。</p><ol><li>首先创建一个文件叫dataTables.sort.plungin.js，加入以下代码。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend(jQuery.fn.dataTableExt.oSort, &#123;</span><br><span class="line">    &quot;html-percent-pre&quot;: function (a) &#123;</span><br><span class="line">        var x = String(a).replace(/&lt;[\s\S]*?&gt;/g, &quot;&quot;);    //去除html标记</span><br><span class="line">        x = x.replace(/&amp;amp;nbsp;/ig, &quot;&quot;);                   //去除空格</span><br><span class="line">        x = x.replace(/%/, &quot;&quot;);                          //去除百分号</span><br><span class="line">        return parseFloat(x);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &quot;html-percent-asc&quot;: function (a, b) &#123;                //正序排序引用方法</span><br><span class="line">        return ((a &lt; b) ? -1 : ((a &gt; b) ? 1 : 0));</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &quot;html-percent-desc&quot;: function (a, b) &#123;                //倒序排序引用方法</span><br><span class="line">        return ((a &lt; b) ? 1 : ((a &gt; b) ? -1 : 0));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><a id="more"></a><p>2.在前台页面中加入以下的 js 引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;jquery.dataTables.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;dataTables.numericComma.js&quot;&gt;&lt;/script&gt; </span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">            var oTable1 = $(&apos;#table_report&apos;).dataTable(&#123;</span><br><span class="line">                &quot;aoColumnDefs&quot;: [</span><br><span class="line">                    &#123; &quot;sType&quot;: &quot;html-percent&quot;, &quot;aTargets&quot;: [8] &#125;,    //指定列号使用自定义排序</span><br><span class="line">                ],</span><br><span class="line">                &quot;bLengthChange&quot;: true, //开关，是否显示每页大小的下拉框</span><br><span class="line">                &quot;aLengthMenu&quot;: [[5, 10, 25, -1], [5, 10, 25, &quot;所有&quot;]],</span><br><span class="line">                &apos;iDisplayLength&apos;: 25, //每页显示10条记录</span><br><span class="line">                &apos;bFilter&apos;: true,  //是否使用内置的过滤功能</span><br><span class="line">                &quot;bInfo&quot;: true, //开关，是否显示表格的一些信息</span><br><span class="line">                &quot;bPaginate&quot;: true //开关，是否显示分页器</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用dataTables的时候，有些列中会是一些包含内容的按钮或链接，不是单纯的文字内容。那么dataTables会将这些内容视为字符串，进行排序，有时候这不符合我们的期望。那么就需要自己能够灵活的指定某些列按照我们的意愿进行排序，幸运的是dataTable支持这样的插件拓展。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先创建一个文件叫dataTables.sort.plungin.js，加入以下代码。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;jQuery.extend(jQuery.fn.dataTableExt.oSort, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;html-percent-pre&amp;quot;: function (a) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var x = String(a).replace(/&amp;lt;[\s\S]*?&amp;gt;/g, &amp;quot;&amp;quot;);    //去除html标记&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        x = x.replace(/&amp;amp;amp;nbsp;/ig, &amp;quot;&amp;quot;);                   //去除空格&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        x = x.replace(/%/, &amp;quot;&amp;quot;);                          //去除百分号&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return parseFloat(x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;html-percent-asc&amp;quot;: function (a, b) &amp;#123;                //正序排序引用方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return ((a &amp;lt; b) ? -1 : ((a &amp;gt; b) ? 1 : 0));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;html-percent-desc&amp;quot;: function (a, b) &amp;#123;                //倒序排序引用方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return ((a &amp;lt; b) ? 1 : ((a &amp;gt; b) ? -1 : 0));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="插件" scheme="http://yongchao.tech:8080/categories/%E6%8F%92%E4%BB%B6/"/>
    
    
      <category term="js" scheme="http://yongchao.tech:8080/tags/js/"/>
    
      <category term="dataTable" scheme="http://yongchao.tech:8080/tags/dataTable/"/>
    
  </entry>
  
  <entry>
    <title>codemirror基本配置</title>
    <link href="http://yongchao.tech:8080/2019/09/10/codemirror%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
    <id>http://yongchao.tech:8080/2019/09/10/codemirror基本配置/</id>
    <published>2019-09-09T22:51:12.000Z</published>
    <updated>2019-09-17T14:58:46.645Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">export const editorOption = &#123;</span><br><span class="line">  tabSize: 2,</span><br><span class="line">  styleActiveLine: true,</span><br><span class="line">  line: true,</span><br><span class="line">  mode: &apos;text/x-nginx-conf&apos;,</span><br><span class="line">  lineNumbers: true,  // 显示行号</span><br><span class="line">  theme: &apos;solarized&apos;,  // 设置主题</span><br><span class="line">  keyMap: &apos;sublime&apos;,  // 绑定sublime</span><br><span class="line">  fullScreen: false,  // 全屏模式</span><br><span class="line">  matchBrackets: true,  // 括号匹配</span><br><span class="line">  indentWithTabs: true,</span><br><span class="line">  readOnly: false</span><br><span class="line">&#125;</span><br><span class="line">import &#123; codemirror &#125; from &apos;vue-codemirror&apos;</span><br><span class="line">import &#123; editorOption &#125; from &apos;@/api/convention&apos;</span><br><span class="line">require(&apos;codemirror/keymap/sublime.js&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;div style=&quot;width: 80%;&quot;&gt;</span><br><span class="line">   &lt;codemirror v-model=&quot;templateForm.content&quot; :options=&quot;editorOption&quot;&gt;&lt;/codemirror&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.CodeMirror &#123;</span><br><span class="line">  height: 360px;</span><br><span class="line">&#125;</span><br><span class="line">.CodeMirror-fullscreen &#123;</span><br><span class="line">  z-index: 9999;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="插件" scheme="http://yongchao.tech:8080/categories/%E6%8F%92%E4%BB%B6/"/>
    
    
      <category term="js" scheme="http://yongchao.tech:8080/tags/js/"/>
    
      <category term="codemirror" scheme="http://yongchao.tech:8080/tags/codemirror/"/>
    
  </entry>
  
  <entry>
    <title>比较两个值相等</title>
    <link href="http://yongchao.tech:8080/2019/09/08/%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E5%80%BC%E7%9B%B8%E7%AD%89/"/>
    <id>http://yongchao.tech:8080/2019/09/08/比较两个值相等/</id>
    <published>2019-09-07T22:54:00.000Z</published>
    <updated>2019-09-17T14:57:14.096Z</updated>
    
    <content type="html"><![CDATA[<p>首先回顾javascript的数据类型：</p><ol><li>string</li><li>number</li><li>boolean</li><li>undefined</li><li>null</li><li>object(array 、function、普通object )</li><li>symbol(es6新加)</li></ol><p>其中 string、number、boolean 、undefined、null 是直接比较值的，可以通过===判断<br>object 、symbol是比较地址的，地址相同则视为相等</p><p>so,</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function valueEqual (a, b) &#123;</span><br><span class="line">    //处理number string boolean undefined null function symbol</span><br><span class="line">    if (a === b) return true</span><br><span class="line">    //处理数组前的预判断</span><br><span class="line">    if (!(a instanceof Array) || !(b instanceof Array)) return false</span><br><span class="line">    if (a.length !== b.length) return false</span><br><span class="line">    //正式判断数组和对象</span><br><span class="line">    for (let i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">        if (a[i] !== b[i]) return false</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先回顾javascript的数据类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;string&lt;/li&gt;
&lt;li&gt;number&lt;/li&gt;
&lt;li&gt;boolean&lt;/li&gt;
&lt;li&gt;undefined&lt;/li&gt;
&lt;li&gt;null&lt;/li&gt;
&lt;li&gt;object(array 、function、普通object )&lt;/li&gt;
&lt;li&gt;symbol(es6新加)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中 string、number、boolean 、undefined、null 是直接比较值的，可以通过===判断&lt;br&gt;object 、symbol是比较地址的，地址相同则视为相等&lt;/p&gt;
&lt;p&gt;so,&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yongchao.tech:8080/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>监听快捷键</title>
    <link href="http://yongchao.tech:8080/2019/09/08/%E7%9B%91%E5%90%AC%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yongchao.tech:8080/2019/09/08/监听快捷键/</id>
    <published>2019-09-07T22:52:48.000Z</published>
    <updated>2019-09-17T15:21:07.295Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt; </span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; </span><br><span class="line">&lt;script type=&quot;text/javascript&quot; language=JavaScript&gt; </span><br><span class="line">       document.onkeydown=function(event)&#123; </span><br><span class="line">            var e = event || window.event || arguments.callee.caller.arguments[0]; </span><br><span class="line">            if(e &amp;&amp; e.keyCode==27)&#123; // 按 Esc  </span><br><span class="line">                //要做的事情 </span><br><span class="line">alert(&quot;按 esc&quot;); </span><br><span class="line">            &#125; </span><br><span class="line">            if(e &amp;&amp; e.keyCode==113)&#123; // 按 F2  </span><br><span class="line">                //要做的事情 </span><br><span class="line">alert(&quot;按 f2&quot;); </span><br><span class="line">            &#125;             </span><br><span class="line">            if(e &amp;&amp; e.keyCode==13)&#123; // enter 键 </span><br><span class="line">                //要做的事情 </span><br><span class="line">alert(&quot;按 Enter&quot;); </span><br><span class="line">            &#125;</span><br><span class="line">if (e.keyCode == 86 &amp;&amp; e.ctrlKey) &#123;  </span><br><span class="line">                alert(&quot;你按下了ctrl+V&quot;);  </span><br><span class="line">            &#125;</span><br><span class="line">         &#125;;  </span><br><span class="line">&lt;/script&gt; </span><br><span class="line">&lt;/head&gt; </span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt; </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="js" scheme="http://yongchao.tech:8080/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>repaint重绘和reflow回流</title>
    <link href="http://yongchao.tech:8080/2019/09/07/repaint%E9%87%8D%E7%BB%98%E5%92%8Creflow%E5%9B%9E%E6%B5%81/"/>
    <id>http://yongchao.tech:8080/2019/09/07/repaint重绘和reflow回流/</id>
    <published>2019-09-07T12:16:40.000Z</published>
    <updated>2019-09-15T10:25:27.710Z</updated>
    
    <content type="html"><![CDATA[<p>前言： 为什么不能用CSS通配符 *，CSS选择器层叠为什么不能超过三层，CSS为什么尽量使用类选择器，书写HTML为什么少使用table，为什么结构要尽量简单-DOM树要小….</p><h3 id="浏览器解析大概的工作流程大致可归纳为四个步骤："><a href="#浏览器解析大概的工作流程大致可归纳为四个步骤：" class="headerlink" title="浏览器解析大概的工作流程大致可归纳为四个步骤："></a>浏览器解析大概的工作流程大致可归纳为四个步骤：</h3><ol><li>解析HTML以构建DOM树：渲染引擎开始解析HTML文档，转换树中的html标签或js生成的标签到DOM节点，它被称为 – 内容树。</li><li>构建渲染树：解析CSS（包括外部CSS文件和样式元素以及js生成的样式）成样式结构体，根据CSS选择器计算出节点的样式，创建另一个树 —- 渲染树（render tree）。 注：在解析的过程中会去掉浏览器不能识别的样式，比如IE会去掉-moz开头的样式，而firefox会去掉_开头的样式。</li><li>布局渲染树: 从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标。</li><li><p>绘制渲染树: 遍历渲染树，每个节点将使用UI后端层来绘制。</p><a id="more"></a></li></ol><p>比较：<br>    render tree能识别样式，render tree中每个node都有自己的style，而且render tree不包含隐藏的节点(比如display:none的节点，还有head节点)，因为这些节点不会用于呈现，而且不会影响呈现的，所以就不会包含到 render tree中。注意 visibility:hidden隐藏的元素还是会包含到render tree中的，因为visibility:hidden 会影响布局(layout)，会占有空间。<br>定义<br>    我们可以看到 Reflow 和Repaint 分别出现在了第三和第四步。因此我们给出下面的定义： 对于DOM结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式（浏览器的、开发人员定义的等）来计算并根据计算结果将元素放到它该出现的<strong>位置</strong>，这个过程称之为<strong>reflow</strong>； 当各种盒子的<strong>位置、大小以及其他属性</strong>，例如颜色、字体大小等都确定下来后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称之为<strong>repaint</strong>。<br>回流与重绘总结：<br>        当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。<br>        <strong>每个页面至少需要一次回流</strong>，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为repaint重绘。 <strong>注意：回流必将引起重绘，而重绘不一定会引起回流。 引起Repain和Reflow的一些操作 Reflow 的成本比 Repaint 的成本高得多的多</strong>。DOM Tree 里的每个结点都会有 reflow 方法，一个结点的 reflow 很有可能导致子结点，甚至父点以及同级结点的 reflow。 当你增加、删除、修改 DOM 结点时，会导致 Reflow 或 Repaint。 当你移动 DOM 的位置，或是搞个动画的时候。 当你修改 /删除CSS 样式的时候。 当你 Resize 窗口的时候（移动端没有这个问题），或是滚动的时候。 当你修改网页的默认字体时。 当你设置 style 属性的值 （Setting a property of the style attribute）。 </p><blockquote><p>注：display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。</p></blockquote><h3 id="如何减少Repain和Reflow-Reflow是不可避免的，只能将Reflow对性能的影响减到最小-给出下面几条建议："><a href="#如何减少Repain和Reflow-Reflow是不可避免的，只能将Reflow对性能的影响减到最小-给出下面几条建议：" class="headerlink" title="如何减少Repain和Reflow? Reflow是不可避免的，只能将Reflow对性能的影响减到最小,给出下面几条建议："></a>如何减少Repain和Reflow? Reflow是不可避免的，只能将Reflow对性能的影响减到最小,给出下面几条建议：</h3><ol><li>不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className，即将多次改变样式属性的操作合并成一次操作：<br>// 不好的写法 var left = 10, top = 10; el.style.left = left + “px”; el.style.top = top + “px”; el.style.background = ‘#eee’; // 比较好的写法 el.className += “ theclassname”;</li><li>让要操作的元素进行”离线处理”，处理完后一起更新<br>使用DocumentFragment进行缓存操作,引发一次回流和重绘；<br>使用display:none技术，只引发两次回流和重绘;<br>原理：由于isplay属性为none的元素不在渲染树中，对隐藏的元素操 作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。<br>使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；</li><li>不要把 DOM 节点的属性值放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性。</li><li>尽可能的修改层级比较低的 DOM节点。当然，改变层级比较底的 DOM节点有可能会造成大面积的 reflow，但是也可能影响范围很小。 因为改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点。这导致大量时间耗费在执行 reflow 上面</li><li>将需要多次重排的元素，position属性设为absolute或fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素为动画的 HTML 元素，例如动画，那么修改他们的 CSS 是会大大减小 reflow 。因为,   它们不影响其他元素的布局，所它他们只会导致重新绘制，而不是一个完整回流。这样消耗会更低。</li><li>不要用tables布局的一个原因就是tables中某个元素一旦触发reflow就会导致table里所有的其它元素reflow。在适合用table的场合，可以设置table-layout为auto或fixed，这样可以让table一行一行的   渲染，这种做法也是为了限制reflow的影响范围。</li><li>避免使用CSS的JavaScript表达式，如果css里有expression，每次都会重新计算一遍。<blockquote><p>来源： <a href="https://blog.csdn.net/ClaireKe/article/details/51375622" target="_blank" rel="noopener">https://blog.csdn.net/ClaireKe/article/details/51375622</a></p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言： 为什么不能用CSS通配符 *，CSS选择器层叠为什么不能超过三层，CSS为什么尽量使用类选择器，书写HTML为什么少使用table，为什么结构要尽量简单-DOM树要小….&lt;/p&gt;
&lt;h3 id=&quot;浏览器解析大概的工作流程大致可归纳为四个步骤：&quot;&gt;&lt;a href=&quot;#浏览器解析大概的工作流程大致可归纳为四个步骤：&quot; class=&quot;headerlink&quot; title=&quot;浏览器解析大概的工作流程大致可归纳为四个步骤：&quot;&gt;&lt;/a&gt;浏览器解析大概的工作流程大致可归纳为四个步骤：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;解析HTML以构建DOM树：渲染引擎开始解析HTML文档，转换树中的html标签或js生成的标签到DOM节点，它被称为 – 内容树。&lt;/li&gt;
&lt;li&gt;构建渲染树：解析CSS（包括外部CSS文件和样式元素以及js生成的样式）成样式结构体，根据CSS选择器计算出节点的样式，创建另一个树 —- 渲染树（render tree）。 注：在解析的过程中会去掉浏览器不能识别的样式，比如IE会去掉-moz开头的样式，而firefox会去掉_开头的样式。&lt;/li&gt;
&lt;li&gt;布局渲染树: 从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;绘制渲染树: 遍历渲染树，每个节点将使用UI后端层来绘制。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://yongchao.tech:8080/tags/css/"/>
    
      <category term="渲染过程" scheme="http://yongchao.tech:8080/tags/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从url到页面渲染的流程</title>
    <link href="http://yongchao.tech:8080/2019/09/07/%E4%BB%8Eurl%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <id>http://yongchao.tech:8080/2019/09/07/从url到页面渲染的流程/</id>
    <published>2019-09-07T11:45:28.000Z</published>
    <updated>2019-09-15T10:25:44.397Z</updated>
    
    <content type="html"><![CDATA[<p>从用户在浏览器中输入一个URL，到整个页面渲染，这个过程中究竟发生了什么呢？今天先简单写下整个过程，后面再一点点完善。</p><h3 id="DNS解析获取IP地址"><a href="#DNS解析获取IP地址" class="headerlink" title="DNS解析获取IP地址"></a>DNS解析获取IP地址</h3><ol><li>首先会在浏览器的缓存中查找，是否缓存了URL，如果有，就直接向该URL对应的服务器发送请求；如果没有则进行下一步;</li><li>在本地的hosts文件中是否保存了该URL和其对应的IP地址，如果保存了，就直接向该URL对应的服务器发送请求；如果没有则进行下一步；</li><li>向本地DNS服务器（一般由本地网络接入服务器提供商ISP提供，比如移动、联通）发送DNS请求，本地DNS服务器会首先查询它的缓存记录，如果有就将该域名对应的IP地址返回给用户，如果没有则进行下一步；</li><li>首先向根域名服务器发送DNS查询请求，根域名服务器返回给可能保存了该域名的一级域名服务器地址；本地主机再根据返回的地址，向一级域名服务器发送DNS查询请求；…一直迭代，直到找到对应的域名存放的服务器，向其发送DNS查询请求，该域名服务器返回该域名对应的IP地址；</li></ol><a id="more"></a><h3 id="TCP-IP连接"><a href="#TCP-IP连接" class="headerlink" title="TCP/IP连接"></a>TCP/IP连接</h3><p>三次握手：<br>为什么要进行三次握手？如果是两次握手，如下面的对话只有前两句，有可能出现的问题是：客户端之前发送了一个连接请求报文，由于网络原因滞留在网络中，后来到达服务器端，服务器接收到该请求，就会建立连接，等待客户端传送数据。而此时客户端压根就不知道发生了什么，白白造成了服务器资源浪费。<br><img src="/images/三次握手.png" alt="三次握手"></p><ol><li>客户端：我要请求数据可以吗？</li><li>服务器：可以的</li><li>客户端：好的</li></ol><h3 id="浏览器向web服务器发送http请求"><a href="#浏览器向web服务器发送http请求" class="headerlink" title="浏览器向web服务器发送http请求"></a>浏览器向web服务器发送http请求</h3><p>  客户机与服务器建立连接后就可以通信了，这里就暂时先不详细展开说http请求了。讲下客户端请求静态资源和动态资源。</p><ol><li>静态资源：如果客户端请求的是静态资源，则web服务器根据URL地址到服务器的对应路径下查找文件，然后给客户端返回一个HTTP响应，包括状态行、响应头和响应正文。</li><li>动态资源：如果客户端请求的是动态资源，则web服务器会调用CGI/VM执行程序完成相应的操作，如查询数据库，然后返回查询结果数据集，并将运行的结果–HTML文件返回给web服务器。Web服务器再将HTML文件返回给用户。</li></ol><h3 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h3><p>  详情请看<a href="http://yongchao.tech:8080/2019/09/07/repaint重绘和reflow回流/">http://yongchao.tech:8080/2019/09/07/repaint重绘和reflow回流/</a><br>  浏览器拿到HTML文件后，根据渲染规则进行渲染：</p><ol><li>解析HTML，构建DOM树</li><li>解析CSS，生成CSS规则树</li><li>合并DOM树和CSS规则树，生成render树</li><li>布局render树</li><li>绘制render数、树，即绘制页面像素信息</li><li>GPU将各层合成，结果呈现在浏览器窗口中。</li></ol><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>客户端没有数据发送时就需要断开连接，以释放服务器资源。<br><img src="/images/四次挥手.png" alt="四次挥手"></p><ol><li>客户端：我没有数据要发送了，打算断开连接</li><li>服务器：你的请求我收到了，我这还有数据没有发送完成，你等下</li><li>服务器：我的数据发送完毕，可以断开连接了</li><li>客户端：ok，你断开连接吧（客户端独白：我将在2倍的最大报文段生存时间后关闭连接。如果我再次收到服务器的消息，我就知道服务器没有收到我的这句话，我就再发送一遍）。<br>最终服务器收到该客户端发送的消息断开连接，客户端也关闭连接。</li></ol><blockquote><p>注：本文摘自 <a href="https://segmentfault.com/a/1190000014311983" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014311983</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从用户在浏览器中输入一个URL，到整个页面渲染，这个过程中究竟发生了什么呢？今天先简单写下整个过程，后面再一点点完善。&lt;/p&gt;
&lt;h3 id=&quot;DNS解析获取IP地址&quot;&gt;&lt;a href=&quot;#DNS解析获取IP地址&quot; class=&quot;headerlink&quot; title=&quot;DNS解析获取IP地址&quot;&gt;&lt;/a&gt;DNS解析获取IP地址&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;首先会在浏览器的缓存中查找，是否缓存了URL，如果有，就直接向该URL对应的服务器发送请求；如果没有则进行下一步;&lt;/li&gt;
&lt;li&gt;在本地的hosts文件中是否保存了该URL和其对应的IP地址，如果保存了，就直接向该URL对应的服务器发送请求；如果没有则进行下一步；&lt;/li&gt;
&lt;li&gt;向本地DNS服务器（一般由本地网络接入服务器提供商ISP提供，比如移动、联通）发送DNS请求，本地DNS服务器会首先查询它的缓存记录，如果有就将该域名对应的IP地址返回给用户，如果没有则进行下一步；&lt;/li&gt;
&lt;li&gt;首先向根域名服务器发送DNS查询请求，根域名服务器返回给可能保存了该域名的一级域名服务器地址；本地主机再根据返回的地址，向一级域名服务器发送DNS查询请求；…一直迭代，直到找到对应的域名存放的服务器，向其发送DNS查询请求，该域名服务器返回该域名对应的IP地址；&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="渲染过程" scheme="http://yongchao.tech:8080/tags/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>reduce函数的应用</title>
    <link href="http://yongchao.tech:8080/2019/08/26/reduce%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://yongchao.tech:8080/2019/08/26/reduce函数的应用/</id>
    <published>2019-08-25T22:38:13.000Z</published>
    <updated>2019-08-25T14:41:26.454Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = [11,3,4,556,7,8,-4]</span><br></pre></td></tr></table></figure><h4 id="获得最大值-最小值"><a href="#获得最大值-最小值" class="headerlink" title="获得最大值/最小值"></a>获得最大值/最小值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a= arr.reduce((a, b) =&gt; &#123;</span><br><span class="line">  return a &gt; b ? a: b</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [1, 2, 3, 1, 1, 2, 3, 3, 4, 3, 4, 5]</span><br><span class="line">let ret1 = arr1.reduce((a, b) =&gt; &#123;</span><br><span class="line">  if(!a.includes(b)) &#123;</span><br><span class="line">    a.push(b)</span><br><span class="line">  &#125;</span><br><span class="line">  return a</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure><h4 id="实现map函数"><a href="#实现map函数" class="headerlink" title="实现map函数"></a>实现map函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype._map = function(cb) &#123;</span><br><span class="line">  if(typeof cb === &apos;function&apos;) &#123;</span><br><span class="line">    let arr = this</span><br><span class="line">    return arr.reduce((prev, next, index, array) =&gt; &#123;</span><br><span class="line">      prev.push(cb(next, index, array))</span><br><span class="line">      return prev</span><br><span class="line">    &#125;, [])</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    throw new Error(&apos;cb&apos; + &apos; is not function&apos; )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现一个filter函数"><a href="#实现一个filter函数" class="headerlink" title="实现一个filter函数"></a>实现一个filter函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype._filter = function(cb) &#123;</span><br><span class="line">  if(typeof cb === &apos;function&apos;) &#123;</span><br><span class="line">    let arr = this</span><br><span class="line">    return arr.reduce((prev, next, index, array) =&gt; &#123;</span><br><span class="line">      cb(next, index, array) &amp;&amp; prev.push(next)</span><br><span class="line">      return prev</span><br><span class="line">    &#125;, [])</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    throw new Error(&apos;cb&apos; + &apos; is not function&apos; )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let arr2 = [1, 2, &apos;3js&apos;, [4, 5, [6], [7, 8, [9, 10, 11], null, &apos;abc&apos;], &#123;age: 12&#125;, [13, 14]], &apos;[]&apos;];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">  if(Array.isArray(arr)) &#123;</span><br><span class="line">    return arr.reduce((prev, cur) =&gt; &#123;</span><br><span class="line">       // 如果遍历的当前项是数组，再迭代展平</span><br><span class="line">      return Array.isArray(cur) ? prev.concat(flatten(cur)) : prev.concat(cur)</span><br><span class="line">    &#125;, [])</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    throw new Error(arr + &apos; is not array&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="统计字符串中每个字符出现的次数"><a href="#统计字符串中每个字符出现的次数" class="headerlink" title="统计字符串中每个字符出现的次数"></a>统计字符串中每个字符出现的次数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const str = &apos;9kFZTQLbUWOjurz9IKRdeg28rYxULHWDUrIHxCY6tnHleoJ&apos;</span><br><span class="line"></span><br><span class="line">var ret3 = Array.from(str).reduce((accumulator, current) =&gt; &#123;</span><br><span class="line">  current in accumulator ? accumulator[current]++ : accumulator[current] = 1</span><br><span class="line">  return accumulator</span><br><span class="line">&#125;, &#123;&#125;)</span><br></pre></td></tr></table></figure><h4 id="过滤满足多个条件的数组"><a href="#过滤满足多个条件的数组" class="headerlink" title="过滤满足多个条件的数组"></a>过滤满足多个条件的数组</h4><blockquote><p>将过滤函数作为数组进行调用， 初始值为原数据数组</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const filter1 = (arr) =&gt; arr.filter(item =&gt; item.name.length === 3)</span><br><span class="line">const filter2 = (arr) =&gt; arr.filter(item =&gt; item.age &gt; 26)</span><br><span class="line">var ret5 = [filter1, filter2].reduce((accumulator, fn) =&gt; fn(accumulator), arr4)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var arr = [11,3,4,556,7,8,-4]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;获得最大值-最小值&quot;&gt;&lt;a href=&quot;#获得最大值-最小值&quot; class=&quot;headerlink&quot; title=&quot;获得最大值/最小值&quot;&gt;&lt;/a&gt;获得最大值/最小值&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var a= arr.reduce((a, b) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return a &amp;gt; b ? a: b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>css中的各种尺寸</title>
    <link href="http://yongchao.tech:8080/2019/08/21/css%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%B0%BA%E5%AF%B8/"/>
    <id>http://yongchao.tech:8080/2019/08/21/css中的各种尺寸/</id>
    <published>2019-08-20T22:11:46.000Z</published>
    <updated>2019-09-05T02:10:22.349Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/css/size.png" alt="css各种尺寸的说明图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/css/size.png&quot; alt=&quot;css各种尺寸的说明图&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="css" scheme="http://yongchao.tech:8080/tags/css/"/>
    
  </entry>
  
</feed>
